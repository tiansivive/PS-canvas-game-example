{"version":3,"file":"Main.js","sources":["../output/browserify.js","../bower_components/purescript-type-equality/src/Type/Equality.purs","../bower_components/purescript-prelude/src/Type/Data/RowList.purs","../bower_components/purescript-prelude/src/Type/Data/Row.purs","../src/core/Render.purs","../output/Record.Unsafe/foreign.js","../output/Math/foreign.js","../src/Main.purs","../bower_components/purescript-canvas/src/Graphics/Canvas.purs","../output/Graphics.Canvas/foreign.js","../bower_components/purescript-globals/src/Global.purs","../output/Global/foreign.js","../bower_components/purescript-effect/src/Effect.purs","../output/Effect/foreign.js","../output/Effect.Unsafe/foreign.js","../bower_components/purescript-refs/src/Effect/Ref.purs","../output/Effect.Ref/foreign.js","../bower_components/purescript-random/src/Effect/Random.purs","../output/Effect.Random/foreign.js","../bower_components/purescript-exceptions/src/Effect/Exception.purs","../output/Effect.Exception/foreign.js","../bower_components/purescript-exceptions/src/Effect/Exception/Unsafe.purs","../src/events/Events.purs","../output/Effect.Events/foreign.js","../bower_components/purescript-console/src/Effect/Console.purs","../output/Effect.Console/foreign.js","../bower_components/purescript-effect/src/Effect/Class.purs","../bower_components/purescript-prelude/src/Data/Void.purs","../bower_components/purescript-prelude/src/Data/Unit.purs","../output/Data.Unit/foreign.js","../bower_components/purescript-unfoldable/src/Data/Unfoldable1.purs","../output/Data.Unfoldable1/foreign.js","../bower_components/purescript-unfoldable/src/Data/Unfoldable.purs","../output/Data.Unfoldable/foreign.js","../bower_components/purescript-tuples/src/Data/Tuple.purs","../bower_components/purescript-foldable-traversable/src/Data/TraversableWithIndex.purs","../bower_components/purescript-foldable-traversable/src/Data/Traversable.purs","../output/Data.Traversable/foreign.js","../bower_components/purescript-foldable-traversable/src/Data/Traversable/Accum/Internal.purs","../bower_components/purescript-prelude/src/Data/Symbol.purs","../output/Data.Symbol/foreign.js","../bower_components/purescript-prelude/src/Data/Show.purs","../output/Data.Show/foreign.js","../bower_components/purescript-prelude/src/Data/Semiring.purs","../output/Data.Semiring/foreign.js","../bower_components/purescript-prelude/src/Data/Semigroup.purs","../output/Data.Semigroup/foreign.js","../bower_components/purescript-foldable-traversable/src/Data/Semigroup/Traversable.purs","../bower_components/purescript-prelude/src/Data/Semigroup/Last.purs","../bower_components/purescript-foldable-traversable/src/Data/Semigroup/Foldable.purs","../bower_components/purescript-prelude/src/Data/Semigroup/First.purs","../bower_components/purescript-prelude/src/Data/Ring.purs","../output/Data.Ring/foreign.js","../bower_components/purescript-prelude/src/Data/Ordering.purs","../bower_components/purescript-prelude/src/Data/Ord.purs","../output/Data.Ord/foreign.js","../bower_components/purescript-orders/src/Data/Ord/Min.purs","../bower_components/purescript-orders/src/Data/Ord/Max.purs","../bower_components/purescript-newtype/src/Data/Newtype.purs","../bower_components/purescript-prelude/src/Data/Monoid.purs","../bower_components/purescript-prelude/src/Data/Monoid/Multiplicative.purs","../bower_components/purescript-prelude/src/Data/Monoid/Endo.purs","../bower_components/purescript-prelude/src/Data/Monoid/Dual.purs","../bower_components/purescript-prelude/src/Data/Monoid/Disj.purs","../bower_components/purescript-prelude/src/Data/Monoid/Conj.purs","../bower_components/purescript-prelude/src/Data/Monoid/Additive.purs","../bower_components/purescript-maybe/src/Data/Maybe.purs","../bower_components/purescript-maybe/src/Data/Maybe/Last.purs","../bower_components/purescript-maybe/src/Data/Maybe/First.purs","../bower_components/purescript-integers/src/Data/Int.purs","../output/Data.Int/foreign.js","../bower_components/purescript-identity/src/Data/Identity.purs","../bower_components/purescript-prelude/src/Data/HeytingAlgebra.purs","../output/Data.HeytingAlgebra/foreign.js","../bower_components/purescript-foldable-traversable/src/Data/FunctorWithIndex.purs","../output/Data.FunctorWithIndex/foreign.js","../bower_components/purescript-prelude/src/Data/Functor.purs","../output/Data.Functor/foreign.js","../bower_components/purescript-invariant/src/Data/Functor/Invariant.purs","../bower_components/purescript-prelude/src/Data/Function.purs","../bower_components/purescript-foldable-traversable/src/Data/FoldableWithIndex.purs","../bower_components/purescript-foldable-traversable/src/Data/Foldable.purs","../output/Data.Foldable/foreign.js","../bower_components/purescript-prelude/src/Data/EuclideanRing.purs","../output/Data.EuclideanRing/foreign.js","../bower_components/purescript-prelude/src/Data/Eq.purs","../output/Data.Eq/foreign.js","../bower_components/purescript-either/src/Data/Either.purs","../bower_components/purescript-prelude/src/Data/DivisionRing.purs","../bower_components/purescript-distributive/src/Data/Distributive.purs","../bower_components/purescript-prelude/src/Data/CommutativeRing.purs","../bower_components/purescript-prelude/src/Data/Bounded.purs","../output/Data.Bounded/foreign.js","../bower_components/purescript-prelude/src/Data/BooleanAlgebra.purs","../bower_components/purescript-prelude/src/Data/Boolean.purs","../bower_components/purescript-foldable-traversable/src/Data/Bitraversable.purs","../bower_components/purescript-bifunctors/src/Data/Bifunctor.purs","../bower_components/purescript-bifunctors/src/Data/Bifunctor/Wrap.purs","../bower_components/purescript-bifunctors/src/Data/Bifunctor/Product.purs","../bower_components/purescript-bifunctors/src/Data/Bifunctor/Joker.purs","../bower_components/purescript-bifunctors/src/Data/Bifunctor/Flip.purs","../bower_components/purescript-bifunctors/src/Data/Bifunctor/Clown.purs","../bower_components/purescript-foldable-traversable/src/Data/Bifoldable.purs","../bower_components/purescript-arrays/src/Data/Array.purs","../output/Data.Array/foreign.js","../bower_components/purescript-arrays/src/Data/Array/ST.purs","../output/Data.Array.ST/foreign.js","../bower_components/purescript-arrays/src/Data/Array/ST/Iterator.purs","../bower_components/purescript-prelude/src/Control/Semigroupoid.purs","../bower_components/purescript-control/src/Control/Plus.purs","../bower_components/purescript-control/src/Control/MonadZero.purs","../bower_components/purescript-control/src/Control/MonadPlus.purs","../bower_components/purescript-prelude/src/Control/Monad.purs","../bower_components/purescript-transformers/src/Control/Monad/Writer/Class.purs","../bower_components/purescript-transformers/src/Control/Monad/Trans/Class.purs","../bower_components/purescript-transformers/src/Control/Monad/State/Trans.purs","../bower_components/purescript-transformers/src/Control/Monad/State/Class.purs","../bower_components/purescript-st/src/Control/Monad/ST/Internal.purs","../output/Control.Monad.ST.Internal/foreign.js","../bower_components/purescript-tailrec/src/Control/Monad/Rec/Class.purs","../bower_components/purescript-transformers/src/Control/Monad/Reader/Class.purs","../bower_components/purescript-transformers/src/Control/Monad/Error/Class.purs","../bower_components/purescript-transformers/src/Control/Monad/Cont/Class.purs","../bower_components/purescript-control/src/Control/Lazy.purs","../bower_components/purescript-control/src/Control/Extend.purs","../output/Control.Extend/foreign.js","../bower_components/purescript-control/src/Control/Comonad.purs","../bower_components/purescript-prelude/src/Control/Category.purs","../bower_components/purescript-prelude/src/Control/Bind.purs","../output/Control.Bind/foreign.js","../bower_components/purescript-bifunctors/src/Control/Biapply.purs","../bower_components/purescript-bifunctors/src/Control/Biapplicative.purs","../bower_components/purescript-prelude/src/Control/Apply.purs","../output/Control.Apply/foreign.js","../bower_components/purescript-prelude/src/Control/Applicative.purs","../bower_components/purescript-control/src/Control/Alternative.purs","../bower_components/purescript-control/src/Control/Alt.purs","../src/core/Character.purs","../src/core/Board.purs","../../../.nvm/versions/node/v12.10.0/lib/node_modules/pulp/node_modules/browser-pack/_prelude.js"],"sourcesContent":["require('Main').main();\n","module Type.Equality\n  ( class TypeEquals\n  , to\n  , from\n  ) where\n\n-- | This type class asserts that types `a` and `b`\n-- | are equal.\n-- |\n-- | The functional dependencies and the single\n-- | instance below will force the two type arguments\n-- | to unify when either one is known.\n-- |\n-- | Note: any instance will necessarily overlap with\n-- | `refl` below, so instances of this class should\n-- | not be defined in libraries.\nclass TypeEquals a b | a -> b, b -> a where\n  to :: a -> b\n  from :: b -> a\n\ninstance refl :: TypeEquals a a where\n  to a = a\n  from a = a\n","module Type.Data.RowList where\n\nimport Prim.RowList (kind RowList)\n\n-- | A proxy data type whose type parameter is a type of kind `RowList`.\n-- |\n-- | Commonly used for specialising a function with a quantified type.\ndata RLProxy (rowlist :: RowList)\n  = RLProxy\n","module Type.Data.Row where\n\n-- | A proxy data type whose type parameter is a type of kind `# Type` (a row\n-- | of types).\n-- |\n-- | Commonly used for specialising a function with a quantified type.\n-- | For example, suppose we have an identity function for records of type:\n-- | ```purescript\n-- | recordIdentity :: forall row . RProxy row -> Record row -> Record row\n-- | recordIdentity _ rec = rec\n-- | ```\n-- | Then applying this function to an `RProxy` with a specialised type\n-- | allows us to specify a concrete type for `row`:\n-- | ```purescript\n-- | :t recordIdentity (RProxy :: RProxy ( x :: Int, y :: Int ))\n-- | { x :: Int, y :: Int } -> { x :: Int, y :: Int }\n-- | ```\n-- | Here `row` has been specialised to `( x :: Int, y :: Int )`.\ndata RProxy (row :: # Type)\n  = RProxy\n","module Render where\n\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect)\nimport Effect.Console (log)\nimport Graphics.Canvas (Context2D, arc, fillPath, fillRect, getCanvasElementById, getContext2D, setFillStyle)\nimport Math (pi)\nimport Prelude (Unit, bind, discard, show, (<>), ($), (*))\nimport Utils (Color)\n\n\n\n\ntoStringCSS :: Color -> String\ntoStringCSS c = \"rgb(\" <> show c.r <> \",\" <> show c.g <> \",\" <> show c.b <> \")\"\n\n\nhandleCanvas :: (Context2D -> Effect Unit) -> Effect Unit\nhandleCanvas fn = do\n    maybe <- getCanvasElementById \"canvas\"\n    case maybe of\n        Nothing -> log \"Could not find canvas\"\n        Just canvas -> do \n            ctx <- getContext2D canvas\n            fn ctx\n\n\nrectangle :: Number -> Number -> Number -> Number -> Color -> Effect Unit\nrectangle x y width height color = \n    handleCanvas \\ctx -> do\n        setFillStyle ctx $ toStringCSS color\n        fillRect ctx  \n            { x\n            , y\n            , width\n            , height\n            }\n\n\n\ncircle :: Number -> Number -> Number -> Color -> Effect Unit\ncircle x y radius color =\n    handleCanvas \\ctx -> do\n        setFillStyle ctx $ toStringCSS color\n        fillPath ctx $ arc ctx \n            { x\n            , y\n            , radius\n            , start: 0.0\n            , end: 2.0 * pi\n            }","\"use strict\";\n\nexports.unsafeHas = function (label) {\n  return function (rec) {\n    return {}.hasOwnProperty.call(rec, label);\n  };\n};\n\nexports.unsafeGet = function (label) {\n  return function (rec) {\n    return rec[label];\n  };\n};\n\nexports.unsafeSet = function (label) {\n  return function (value) {\n    return function (rec) {\n      var copy = {};\n      for (var key in rec) {\n        if ({}.hasOwnProperty.call(rec, key)) {\n          copy[key] = rec[key];\n        }\n      }\n      copy[label] = value;\n      return copy;\n    };\n  };\n};\n\nexports.unsafeDelete = function (label) {\n  return function (rec) {\n    var copy = {};\n    for (var key in rec) {\n      if (key !== label && {}.hasOwnProperty.call(rec, key)) {\n        copy[key] = rec[key];\n      }\n    }\n    return copy;\n  };\n};\n","\"use strict\";\n\n// module Math\n\nexports.abs = Math.abs;\n\nexports.acos = Math.acos;\n\nexports.asin = Math.asin;\n\nexports.atan = Math.atan;\n\nexports.atan2 = function (y) {\n  return function (x) {\n    return Math.atan2(y, x);\n  };\n};\n\nexports.ceil = Math.ceil;\n\nexports.cos = Math.cos;\n\nexports.exp = Math.exp;\n\nexports.floor = Math.floor;\n\nexports.trunc = Math.trunc || function (n) {\n  return n < 0 ? Math.ceil(n) : Math.floor(n);\n};\n\nexports.log = Math.log;\n\nexports.max = function (n1) {\n  return function (n2) {\n    return Math.max(n1, n2);\n  };\n};\n\nexports.min = function (n1) {\n  return function (n2) {\n    return Math.min(n1, n2);\n  };\n};\n\nexports.pow = function (n) {\n  return function (p) {\n    return Math.pow(n, p);\n  };\n};\n\nexports.remainder = function (n) {\n  return function (m) {\n    return n % m;\n  };\n};\n\nexports.round = Math.round;\n\nexports.sin = Math.sin;\n\nexports.sqrt = Math.sqrt;\n\nexports.tan = Math.tan;\n\nexports.e = Math.E;\n\nexports.ln2 = Math.LN2;\n\nexports.ln10 = Math.LN10;\n\nexports.log2e = Math.LOG2E;\n\nexports.log10e = Math.LOG10E;\n\nexports.pi = Math.PI;\n\nexports.tau = 2 * Math.PI;\n\nexports.sqrt1_2 = Math.SQRT1_2;\n\nexports.sqrt2 = Math.SQRT2;\n","module Main where\n\nimport Prelude\n\nimport Board as Board\nimport Control.Monad.State.Trans (StateT, lift, runStateT)\nimport Character (Character, Direction(..))\nimport Character as Character\nimport Effect (Effect)\nimport Effect.Console (log)\nimport Effect.Events (onKeyDown)\n\n\nhandleKeyPress :: StateT Character Effect Unit\nhandleKeyPress = do\n    _ <- lift $ log \"key pressed\" \n    c <- Character.move Up\n    lift $ Character.draw c\n\n\nmain :: Effect Unit\nmain = do\n  log \"Starting Up!!\"\n  b <- Board.createBoard\n  c <- Character.create\n  Board.draw b\n  Character.draw c\n\n  res <- runStateT (Character.set c) c\n\n  onKeyDown \"ArrowUp\" handleKeyPress\n  log \"finish setting up\"","-- | This module defines foreign types and functions for working with the 2D\n-- | Canvas API.\n\nmodule Graphics.Canvas\n  ( CanvasElement\n  , Context2D\n  , ImageData\n  , CanvasImageSource\n  , Arc\n  , Composite(..)\n  , Dimensions\n  , LineCap(..)\n  , LineJoin(..)\n  , Rectangle\n  , ScaleTransform\n  , TextMetrics\n  , Transform\n  , TranslateTransform\n  , TextAlign(..)\n  , CanvasPattern\n  , PatternRepeat(..)\n  , CanvasGradient\n  , LinearGradient\n  , RadialGradient\n  , QuadraticCurve\n  , BezierCurve\n\n  , getCanvasElementById\n  , getContext2D\n  , getCanvasWidth\n  , setCanvasWidth\n  , getCanvasHeight\n  , setCanvasHeight\n  , getCanvasDimensions\n  , setCanvasDimensions\n  , canvasToDataURL\n\n  , setLineWidth\n  , setLineDash\n  , setFillStyle\n  , setStrokeStyle\n  , setShadowBlur\n  , setShadowOffsetX\n  , setShadowOffsetY\n  , setShadowColor\n  , setMiterLimit\n\n  , setLineCap\n  , setLineJoin\n  , setGlobalCompositeOperation\n  , setGlobalAlpha\n\n  , beginPath\n  , stroke\n  , fill\n  , clip\n  , lineTo\n  , moveTo\n  , closePath\n  , strokePath\n  , fillPath\n\n  , arc\n\n  , rect\n  , fillRect\n  , strokeRect\n  , clearRect\n\n  , scale\n  , rotate\n  , translate\n  , transform\n  , setTransform\n\n  , textAlign\n  , setTextAlign\n  , font\n  , setFont\n  , fillText\n  , strokeText\n  , measureText\n\n  , save\n  , restore\n  , withContext\n\n  , tryLoadImage\n  , getImageData\n  , putImageData\n  , putImageDataFull\n  , createImageData\n  , createImageDataCopy\n  , imageDataWidth\n  , imageDataHeight\n  , imageDataBuffer\n\n  , canvasElementToImageSource\n  , drawImage\n  , drawImageScale\n  , drawImageFull\n\n  , createPattern\n  , setPatternFillStyle\n\n  , createLinearGradient\n  , createRadialGradient\n  , addColorStop\n  , setGradientFillStyle\n\n  , quadraticCurveTo\n  , bezierCurveTo\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\nimport Effect.Exception.Unsafe (unsafeThrow)\nimport Data.ArrayBuffer.Types (Uint8ClampedArray)\nimport Data.Function.Uncurried (Fn3, runFn3)\nimport Data.Maybe (Maybe(..))\n\n-- | A canvas HTML element.\nforeign import data CanvasElement :: Type\n\n-- | A 2D graphics context.\nforeign import data Context2D :: Type\n\n-- | An image data object, used to store raster data outside the canvas.\nforeign import data ImageData :: Type\n\n-- | Opaque object for drawing elements and things to the canvas.\nforeign import data CanvasImageSource :: Type\n\n-- | Opaque object describing a pattern.\nforeign import data CanvasPattern :: Type\n\n-- | Opaque object describing a gradient.\nforeign import data CanvasGradient :: Type\n\nforeign import canvasElementToImageSource :: CanvasElement -> CanvasImageSource\n\nforeign import tryLoadImageImpl\n  :: String\n  -> Effect Unit\n  -> (CanvasImageSource -> Effect Unit)\n  -> Effect Unit\n\n-- | Asynchronously load an image file by specifying its path.\ntryLoadImage\n  :: String\n  -> (Maybe CanvasImageSource -> Effect Unit)\n  -> Effect Unit\ntryLoadImage path k = tryLoadImageImpl path (k Nothing) (k <<< Just)\n\nforeign import getCanvasElementByIdImpl\n  :: forall r\n   . Fn3 String\n         (CanvasElement -> r)\n         r\n         (Effect r)\n\n-- | Get a canvas element by ID, or `Nothing` if the element does not exist.\ngetCanvasElementById :: String -> Effect (Maybe CanvasElement)\ngetCanvasElementById elId = runFn3 getCanvasElementByIdImpl elId Just Nothing\n\n-- | Get the 2D graphics context for a canvas element.\nforeign import getContext2D :: CanvasElement -> Effect Context2D\n\n-- | Get the canvas width in pixels.\nforeign import getCanvasWidth :: CanvasElement -> Effect Number\n\n-- | Get the canvas height in pixels.\nforeign import getCanvasHeight :: CanvasElement -> Effect Number\n\n-- | Set the canvas width in pixels.\nforeign import setCanvasWidth :: CanvasElement -> Number -> Effect Unit\n\n-- | Set the canvas height in pixels.\nforeign import setCanvasHeight :: CanvasElement -> Number -> Effect Unit\n\n-- | Canvas dimensions (width and height) in pixels.\ntype Dimensions = { width :: Number, height :: Number }\n\n-- | Get the canvas dimensions in pixels.\ngetCanvasDimensions :: CanvasElement -> Effect Dimensions\ngetCanvasDimensions ce = do\n  w <- getCanvasWidth  ce\n  h <- getCanvasHeight ce\n  pure {width : w, height : h}\n\n-- | Set the canvas dimensions in pixels.\nsetCanvasDimensions :: CanvasElement -> Dimensions -> Effect Unit\nsetCanvasDimensions ce d = setCanvasHeight ce d.height *> setCanvasWidth ce d.width\n\n-- | Create a data URL for the current canvas contents\nforeign import canvasToDataURL :: CanvasElement -> Effect String\n\n-- | Set the current line width.\nforeign import setLineWidth :: Context2D -> Number -> Effect Unit\n\n-- | Set the current line dash pattern.\nforeign import setLineDash :: Context2D -> Array Number -> Effect Unit\n\n-- | Set the current fill style/color.\nforeign import setFillStyle :: Context2D -> String -> Effect Unit\n\n-- | Set the current stroke style/color.\nforeign import setStrokeStyle :: Context2D -> String -> Effect Unit\n\n-- | Set the current shadow color.\nforeign import setShadowColor :: Context2D -> String -> Effect Unit\n\n-- | Set the current shadow blur radius.\nforeign import setShadowBlur :: Context2D -> Number -> Effect Unit\n\n-- | Set the current shadow x-offset.\nforeign import setShadowOffsetX :: Context2D -> Number -> Effect Unit\n\n-- | Set the current shadow y-offset.\nforeign import setShadowOffsetY :: Context2D -> Number -> Effect Unit\n\n-- | Set the current miter limit.\nforeign import setMiterLimit :: Context2D -> Number -> Effect Unit\n\n-- | Enumerates the different types of line cap.\ndata LineCap = Round | Square | Butt\n\nderive instance eqLineCap :: Eq LineCap\n\nforeign import setLineCapImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current line cap type.\nsetLineCap :: Context2D -> LineCap -> Effect Unit\nsetLineCap context Round  = setLineCapImpl context \"round\"\nsetLineCap context Square = setLineCapImpl context \"square\"\nsetLineCap context Butt   = setLineCapImpl context \"butt\"\n\n-- Note that we can't re-use `Round` from LineCap, so I've added `Join` to all of these\n\n-- | Enumerates the different types of line join\ndata LineJoin = BevelJoin | RoundJoin | MiterJoin\n\nforeign import setLineJoinImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current line join type.\nsetLineJoin :: Context2D -> LineJoin -> Effect Unit\nsetLineJoin context BevelJoin = setLineJoinImpl context \"bevel\"\nsetLineJoin context RoundJoin = setLineJoinImpl context \"round\"\nsetLineJoin context MiterJoin = setLineJoinImpl context \"miter\"\n\n-- | Enumerates the different types of composite operations and blend modes.\ndata Composite\n  -- Composite Operations\n   = SourceOver\n   | SourceIn\n   | SourceOut\n   | SourceAtop\n   | DestinationOver\n   | DestinationIn\n   | DestinationOut\n   | DestinationAtop\n   | Lighter\n   | Copy\n   | Xor\n\n   -- Blend Modes\n   | Multiply\n   | Screen\n   | Overlay\n   | Darken\n   | Lighten\n   | ColorDodge\n   | ColorBurn\n   | HardLight\n   | SoftLight\n   | Difference\n   | Exclusion\n   | Hue\n   | Saturation\n   | Color\n   | Luminosity\n\ninstance showComposite :: Show Composite where\n  show SourceOver      = \"SourceOver\"\n  show SourceIn        = \"SourceIn\"\n  show SourceOut       = \"SourceOut\"\n  show SourceAtop      = \"SourceAtop\"\n  show DestinationOver = \"DestinationOver\"\n  show DestinationIn   = \"DestinationIn\"\n  show DestinationOut  = \"DestinationOut\"\n  show DestinationAtop = \"DestinationAtop\"\n  show Lighter         = \"Lighter\"\n  show Copy            = \"Copy\"\n  show Xor             = \"Xor\"\n  show Multiply        = \"Multiply\"\n  show Screen          = \"Screen\"\n  show Overlay         = \"Overlay\"\n  show Darken          = \"Darken\"\n  show Lighten         = \"Lighten\"\n  show ColorDodge      = \"ColorDodge\"\n  show ColorBurn       = \"ColorBurn\"\n  show HardLight       = \"HardLight\"\n  show SoftLight       = \"SoftLight\"\n  show Difference      = \"Difference\"\n  show Exclusion       = \"Exclusion\"\n  show Hue             = \"Hue\"\n  show Saturation      = \"Saturation\"\n  show Color           = \"Color\"\n  show Luminosity      = \"Luminosity\"\n\nforeign import setGlobalCompositeOperationImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current composite operation.\nsetGlobalCompositeOperation :: Context2D -> Composite -> Effect Unit\nsetGlobalCompositeOperation ctx composite = setGlobalCompositeOperationImpl ctx (toString composite)\n  where\n    toString SourceOver      = \"source-over\"\n    toString SourceIn        = \"source-in\"\n    toString SourceOut       = \"source-out\"\n    toString SourceAtop      = \"source-atop\"\n    toString DestinationOver = \"destination-over\"\n    toString DestinationIn   = \"destination-in\"\n    toString DestinationOut  = \"destination-out\"\n    toString DestinationAtop = \"destination-atop\"\n    toString Lighter         = \"lighter\"\n    toString Copy            = \"copy\"\n    toString Xor             = \"xor\"\n    toString Multiply        = \"multiply\"\n    toString Screen          = \"screen\"\n    toString Overlay         = \"overlay\"\n    toString Darken          = \"darken\"\n    toString Lighten         = \"lighten\"\n    toString ColorDodge      = \"color-dodge\"\n    toString ColorBurn       = \"color-burn\"\n    toString HardLight       = \"hard-light\"\n    toString SoftLight       = \"soft-light\"\n    toString Difference      = \"difference\"\n    toString Exclusion       = \"exclusion\"\n    toString Hue             = \"hue\"\n    toString Saturation      = \"saturation\"\n    toString Color           = \"color\"\n    toString Luminosity      = \"luminosity\"\n\n-- | Set the current global alpha level.\nforeign import setGlobalAlpha :: Context2D -> Number -> Effect Unit\n\n-- | Begin a path object.\nforeign import beginPath :: Context2D -> Effect Unit\n\n-- | Stroke the current object.\nforeign import stroke :: Context2D -> Effect Unit\n\n-- | Fill the current object.\nforeign import fill :: Context2D -> Effect Unit\n\n-- | Clip to the current object.\nforeign import clip :: Context2D -> Effect Unit\n\n-- | Move the path to the specified coordinates, drawing a line segment.\nforeign import lineTo  :: Context2D -> Number -> Number -> Effect Unit\n\n-- | Move the path to the specified coordinates, without drawing a line segment.\nforeign import moveTo  :: Context2D -> Number -> Number -> Effect Unit\n\n-- | Close the current path.\nforeign import closePath  :: Context2D -> Effect Unit\n\n-- | A convenience function for drawing a stroked path.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | strokePath ctx $ do\n-- |   moveTo ctx 10.0 10.0\n-- |   lineTo ctx 20.0 20.0\n-- |   lineTo ctx 10.0 20.0\n-- |   closePath ctx\n-- | ```\nstrokePath :: forall a. Context2D -> Effect a -> Effect a\nstrokePath ctx path = do\n  _ <- beginPath ctx\n  a <- path\n  _ <- stroke ctx\n  pure a\n\n-- | A convenience function for drawing a filled path.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | fillPath ctx $ do\n-- |   moveTo ctx 10.0 10.0\n-- |   lineTo ctx 20.0 20.0\n-- |   lineTo ctx 10.0 20.0\n-- |   closePath ctx\n-- | ```\nfillPath :: forall a. Context2D -> Effect a -> Effect a\nfillPath ctx path = do\n  _ <- beginPath ctx\n  a <- path\n  _ <- fill ctx\n  pure a\n\n-- | A type representing an arc object:\n-- |\n-- | - The center coordinates `x` and `y`,\n-- | - The radius `r`,\n-- | - The starting and ending angles, `start` and `end`.\ntype Arc =\n  { x :: Number\n  , y :: Number\n  , radius :: Number\n  , start :: Number\n  , end   :: Number\n  }\n\n-- | Render an arc object.\nforeign import arc :: Context2D -> Arc -> Effect Unit\n\n-- | A type representing a rectangle object:\n-- |\n-- | - The top-left corner coordinates `x` and `y`,\n-- | - The width and height `w` and `h`.\ntype Rectangle =\n  { x :: Number\n  , y :: Number\n  , width :: Number\n  , height :: Number\n  }\n\n-- | Render a rectangle.\nforeign import rect :: Context2D -> Rectangle -> Effect Unit\n\n-- | Fill a rectangle.\nforeign import fillRect :: Context2D -> Rectangle -> Effect Unit\n\n-- | Stroke a rectangle.\nforeign import strokeRect :: Context2D -> Rectangle -> Effect Unit\n\n-- | Clear a rectangle.\nforeign import clearRect :: Context2D -> Rectangle -> Effect Unit\n\n-- | An object representing a scaling transform:\n-- |\n-- | - The scale factors in the `x` and `y` directions, `scaleX` and `scaleY`.\ntype ScaleTransform =\n  { scaleX :: Number\n  , scaleY :: Number\n  }\n\n-- | Apply a scaling transform.\nforeign import scale  :: Context2D -> ScaleTransform -> Effect Unit\n\n-- | Apply a rotation.\nforeign import rotate :: Context2D -> Number -> Effect Unit\n\n-- | An object representing a translation:\n-- |\n-- | - The translation amounts in the `x` and `y` directions, `translateX` and `translateY`.\ntype TranslateTransform =\n  { translateX :: Number\n  , translateY :: Number\n  }\n\n-- | Apply a translation\nforeign import translate :: Context2D -> TranslateTransform -> Effect Unit\n\n-- | An object representing a general transformation as a homogeneous matrix.\ntype Transform =\n  { m11 :: Number\n  , m12 :: Number\n  , m21 :: Number\n  , m22 :: Number\n  , m31 :: Number\n  , m32 :: Number\n  }\n\n-- | Apply a general transformation to the current transformation matrix\nforeign import transform :: Context2D -> Transform -> Effect Unit\n\n-- | Set the transformation matrix\nforeign import setTransform :: Context2D -> Transform -> Effect Unit\n\n-- | Enumerates types of text alignment.\ndata TextAlign\n  = AlignLeft | AlignRight | AlignCenter | AlignStart | AlignEnd\n\ninstance showTextAlign :: Show TextAlign where\n  show AlignLeft = \"AlignLeft\"\n  show AlignRight = \"AlignRight\"\n  show AlignCenter = \"AlignCenter\"\n  show AlignStart = \"AlignStart\"\n  show AlignEnd = \"AlignEnd\"\n\nforeign import textAlignImpl :: Context2D -> Effect String\n\n-- | Get the current text alignment.\ntextAlign :: Context2D -> Effect TextAlign\ntextAlign ctx = unsafeParseTextAlign <$> textAlignImpl ctx\n  where\n  unsafeParseTextAlign :: String -> TextAlign\n  unsafeParseTextAlign \"left\" = AlignLeft\n  unsafeParseTextAlign \"right\" = AlignRight\n  unsafeParseTextAlign \"center\" = AlignCenter\n  unsafeParseTextAlign \"start\" = AlignStart\n  unsafeParseTextAlign \"end\" = AlignEnd\n  unsafeParseTextAlign align = unsafeThrow $ \"invalid TextAlign: \" <> align\n  -- ^ dummy to silence compiler warnings\n\nforeign import setTextAlignImpl :: Context2D -> String -> Effect Unit\n\n-- | Set the current text alignment.\nsetTextAlign :: Context2D -> TextAlign -> Effect Unit\nsetTextAlign ctx textalign =\n  setTextAlignImpl ctx (toString textalign)\n  where\n    toString AlignLeft = \"left\"\n    toString AlignRight = \"right\"\n    toString AlignCenter = \"center\"\n    toString AlignStart = \"start\"\n    toString AlignEnd = \"end\"\n\n-- | Text metrics:\n-- |\n-- | - The text width in pixels.\ntype TextMetrics = { width :: Number }\n\n-- | Get the current font.\nforeign import font :: Context2D -> Effect String\n\n-- | Set the current font.\nforeign import setFont :: Context2D -> String -> Effect Unit\n\n-- | Fill some text.\nforeign import fillText :: Context2D -> String -> Number -> Number -> Effect Unit\n\n-- | Stroke some text.\nforeign import strokeText :: Context2D -> String -> Number -> Number -> Effect Unit\n\n-- | Measure some text.\nforeign import measureText :: Context2D -> String -> Effect TextMetrics\n\n-- | Save the current context.\nforeign import save  :: Context2D -> Effect Unit\n\n-- | Restore the previous context.\nforeign import restore  :: Context2D -> Effect Unit\n\n-- | A convenience function: run the action, preserving the existing context.\n-- |\n-- | For example, outside this block, the fill style is preseved:\n-- |\n-- | ```purescript\n-- | withContext ctx $ do\n-- |   setFillStyle \"red\" ctx\n-- |   ...\n-- | ```\nwithContext :: forall a. Context2D -> Effect a -> Effect a\nwithContext ctx action = do\n  _ <- save ctx\n  a <- action\n  _ <- restore ctx\n  pure a\n\n-- | Get image data for a portion of the canvas.\nforeign import getImageData :: Context2D -> Number -> Number -> Number -> Number -> Effect ImageData\n\n-- | Set image data for a portion of the canvas.\nforeign import putImageDataFull :: Context2D -> ImageData -> Number -> Number -> Number -> Number -> Number -> Number -> Effect Unit\n\n-- | Set image data for a portion of the canvas.\nforeign import putImageData :: Context2D -> ImageData -> Number -> Number -> Effect Unit\n\n-- | Create an image data object.\nforeign import createImageData :: Context2D -> Number -> Number -> Effect ImageData\n\n-- | Create a copy of an image data object.\nforeign import createImageDataCopy :: Context2D -> ImageData -> Effect ImageData\n\n-- | Get the width of an `ImageData` object.\nforeign import imageDataWidth :: ImageData -> Int\n\n-- | Get the height of an `ImageData` object.\nforeign import imageDataHeight :: ImageData -> Int\n\n-- | Get the underlying buffer from an `ImageData` object.\nforeign import imageDataBuffer :: ImageData -> Uint8ClampedArray\n\nforeign import drawImage :: Context2D -> CanvasImageSource -> Number -> Number -> Effect Unit\n\nforeign import drawImageScale :: Context2D -> CanvasImageSource -> Number -> Number -> Number -> Number -> Effect Unit\n\nforeign import drawImageFull :: Context2D -> CanvasImageSource -> Number -> Number -> Number -> Number -> Number -> Number -> Number -> Number -> Effect Unit\n\n-- | Enumerates the different types of pattern repetitions.\ndata PatternRepeat = Repeat | RepeatX | RepeatY | NoRepeat\n\ninstance showPatternRepeat :: Show PatternRepeat where\n  show Repeat = \"Repeat\"\n  show RepeatX = \"RepeatX\"\n  show RepeatY = \"RepeatY\"\n  show NoRepeat = \"NoRepeat\"\n\nforeign import createPatternImpl :: Context2D -> CanvasImageSource -> String ->  Effect CanvasPattern\n\n-- | Create a new canvas pattern (repeatable image).\ncreatePattern :: Context2D -> CanvasImageSource -> PatternRepeat -> Effect CanvasPattern\ncreatePattern context img repeat = createPatternImpl context img (toString repeat)\n  where\n    toString Repeat = \"repeat\"\n    toString RepeatX = \"repeat-x\"\n    toString RepeatY = \"repeat-y\"\n    toString NoRepeat = \"no-repeat\"\n\n-- | Set the Context2D fillstyle to the CanvasPattern.\nforeign import setPatternFillStyle :: Context2D -> CanvasPattern -> Effect Unit\n\n-- | A type representing a linear gradient.\n-- |  -  Starting point coordinates: (`x0`, `y0`)\n-- |  -  Ending point coordinates: (`x1`, `y1`)\n\ntype LinearGradient =\n    { x0 :: Number\n    , y0 :: Number\n    , x1 :: Number\n    , y1 :: Number\n    }\n\n-- | Create a linear CanvasGradient.\nforeign import createLinearGradient :: Context2D -> LinearGradient -> Effect CanvasGradient\n\n-- | A type representing a radial gradient.\n-- |  -  Starting circle center coordinates: (`x0`, `y0`)\n-- |  -  Starting circle radius: `r0`\n-- |  -  Ending circle center coordinates: (`x1`, `y1`)\n-- |  -  Ending circle radius: `r1`\n\ntype RadialGradient =\n    { x0 :: Number\n    , y0 :: Number\n    , r0 :: Number\n    , x1 :: Number\n    , y1 :: Number\n    , r1 :: Number\n    }\n\n-- | Create a radial CanvasGradient.\nforeign import createRadialGradient :: Context2D -> RadialGradient -> Effect CanvasGradient\n\n-- | Add a single color stop to a CanvasGradient.\nforeign import addColorStop :: CanvasGradient -> Number -> String -> Effect Unit\n\n-- | Set the Context2D fillstyle to the CanvasGradient.\nforeign import setGradientFillStyle :: Context2D -> CanvasGradient -> Effect Unit\n\n-- | A type representing a quadratic Bézier curve.\n-- |  - Bézier control point: (`cpx`, `cpy`)\n-- |  - Ending point coordinates: (`x`, `y`)\n\ntype QuadraticCurve =\n    { cpx :: Number\n    , cpy :: Number\n    , x   :: Number\n    , y   :: Number\n    }\n\n-- | Draw a quadratic Bézier curve.\nforeign import quadraticCurveTo :: Context2D -> QuadraticCurve -> Effect Unit\n\n-- | A type representing a cubic Bézier curve.\n-- |  - First Bézier control point: (`cp1x`, `cp1y`)\n-- |  - Second Bézier control point: (`cp2x`, `cp2y`)\n-- |  - Ending point: (`x`, `y`)\n\ntype BezierCurve =\n    { cp1x :: Number\n    , cp1y :: Number\n    , cp2x :: Number\n    , cp2y :: Number\n    , x    :: Number\n    , y    :: Number\n    }\n\n-- | Draw a cubic Bézier curve.\nforeign import bezierCurveTo :: Context2D -> BezierCurve -> Effect Unit\n","/* global exports */\n\"use strict\";\n\nexports.canvasElementToImageSource = function(e) {\n    return e;\n};\n\nexports.tryLoadImageImpl = function (src) {\n  return function(e) {\n        return function(f) {\n            return function () {\n                var img = new Image();\n                img.src = src;\n                img.addEventListener(\"load\", function() {\n                    f(img)();\n                }, false);\n                img.addEventListener(\"error\", function(error) {\n                    e();\n                }, false);\n            }\n        }\n    };\n};\n\nexports.getCanvasElementByIdImpl = function(id, Just, Nothing) {\n    return function() {\n        var el = document.getElementById(id);\n        if (el && el instanceof HTMLCanvasElement) {\n            return Just(el);\n        } else {\n            return Nothing;\n        }\n    };\n};\n\nexports.getContext2D = function(c) {\n    return function() {\n        return c.getContext('2d');\n    };\n};\n\nexports.getCanvasWidth = function(canvas) {\n    return function() {\n        return canvas.width;\n    };\n};\n\nexports.getCanvasHeight = function(canvas) {\n    return function() {\n        return canvas.height;\n    };\n};\n\nexports.setCanvasWidth = function(canvas) {\n    return function(width) {\n        return function() {\n            canvas.width = width;\n        };\n    };\n};\n\nexports.setCanvasHeight = function(canvas) {\n    return function(height) {\n        return function() {\n            canvas.height = height;\n        };\n    };\n};\n\nexports.canvasToDataURL = function(canvas) {\n    return function() {\n        return canvas.toDataURL();\n    };\n};\n\nexports.setLineWidth = function(ctx) {\n    return function(width) {\n        return function() {\n            ctx.lineWidth = width;\n        };\n    };\n};\n\nexports.setLineDash = function(ctx) {\n    return function(dash) {\n        return function() {\n            ctx.setLineDash(dash);\n        };\n    };\n};\n\nexports.setFillStyle = function(ctx) {\n    return function(style) {\n        return function() {\n            ctx.fillStyle = style;\n        };\n    };\n};\n\nexports.setStrokeStyle = function(ctx) {\n    return function(style) {\n        return function() {\n            ctx.strokeStyle = style;\n        };\n    };\n};\n\nexports.setShadowColor = function(ctx) {\n    return function(color) {\n        return function() {\n            ctx.shadowColor = color;\n        };\n    };\n};\n\nexports.setShadowBlur = function(ctx) {\n    return function(blur) {\n        return function() {\n            ctx.shadowBlur = blur;\n        };\n    };\n};\n\nexports.setShadowOffsetX = function(ctx) {\n    return function(offsetX) {\n        return function() {\n            ctx.shadowOffsetX = offsetX;\n        };\n    };\n};\n\nexports.setShadowOffsetY = function(ctx) {\n    return function(offsetY) {\n        return function() {\n            ctx.shadowOffsetY = offsetY;\n        };\n    };\n};\n\nexports.setMiterLimit = function(ctx) {\n    return function(limit) {\n        return function() {\n            ctx.miterLimit = limit;\n        };\n    };\n};\n\nexports.setLineCapImpl = function(ctx) {\n    return function(cap) {\n        return function() {\n            ctx.lineCap = cap;\n        };\n    };\n};\n\nexports.setLineJoinImpl = function(ctx) {\n    return function(join) {\n        return function() {\n            ctx.lineJoin = join;\n        };\n    };\n};\n\nexports.setGlobalCompositeOperationImpl = function(ctx) {\n    return function(op) {\n        return function() {\n            ctx.globalCompositeOperation = op;\n        };\n    };\n};\n\nexports.setGlobalAlpha = function(ctx) {\n    return function(alpha) {\n        return function() {\n            ctx.globalAlpha = alpha;\n        };\n    };\n};\n\nexports.beginPath = function(ctx) {\n    return function() {\n        ctx.beginPath();\n    };\n};\n\nexports.stroke = function(ctx) {\n    return function() {\n        ctx.stroke();\n    };\n};\n\nexports.fill = function(ctx) {\n    return function() {\n        ctx.fill();\n    };\n};\n\nexports.clip = function(ctx) {\n    return function() {\n        ctx.clip();\n    };\n};\n\nexports.lineTo = function(ctx) {\n    return function(x) {\n        return function(y) {\n            return function() {\n                ctx.lineTo(x, y);\n            };\n        };\n    };\n};\n\nexports.moveTo = function(ctx) {\n    return function(x) {\n        return function(y) {\n            return function() {\n                ctx.moveTo(x, y);\n            };\n        };\n    };\n};\n\nexports.closePath = function(ctx) {\n    return function() {\n        ctx.closePath();\n    };\n};\n\nexports.arc = function(ctx) {\n    return function(a) {\n        return function() {\n            ctx.arc(a.x, a.y, a.radius, a.start, a.end);\n        };\n    };\n};\n\nexports.rect = function(ctx) {\n    return function(r) {\n        return function() {\n            ctx.rect(r.x, r.y, r.width, r.height);\n        };\n    };\n};\n\nexports.fillRect = function(ctx) {\n    return function(r) {\n        return function() {\n            ctx.fillRect(r.x, r.y, r.width, r.height);\n        };\n    };\n};\n\nexports.strokeRect = function(ctx) {\n    return function(r) {\n        return function() {\n            ctx.strokeRect(r.x, r.y, r.width, r.height);\n        };\n    };\n};\n\nexports.clearRect = function(ctx) {\n    return function(r) {\n        return function() {\n            ctx.clearRect(r.x, r.y, r.width, r.height);\n        };\n    };\n};\n\nexports.scale = function(ctx) {\n    return function(t) {\n        return function() {\n            ctx.scale(t.scaleX, t.scaleY);\n        };\n    };\n};\n\nexports.rotate = function(ctx) {\n    return function(angle) {\n        return function() {\n            ctx.rotate(angle);\n        };\n    };\n};\n\nexports.translate = function(ctx) {\n    return function(t) {\n        return function() {\n            ctx.translate(t.translateX, t.translateY);\n        };\n    };\n};\n\nexports.transform = function(ctx) {\n    return function(t) {\n        return function() {\n            ctx.transform(t.m11, t.m12, t.m21, t.m22, t.m31, t.m32);\n        };\n    };\n};\n\nexports.setTransform = function(ctx) {\n    return function(t) {\n        return function() {\n            ctx.setTransform(t.m11, t.m12, t.m21, t.m22, t.m31, t.m32);\n        };\n    };\n};\n\nexports.textAlignImpl = function(ctx) {\n    return function() {\n        return ctx.textAlign;\n    }\n};\n\nexports.setTextAlignImpl = function(ctx) {\n    return function(textAlign) {\n        return function() {\n            ctx.textAlign = textAlign;\n        }\n    }\n};\n\nexports.font = function(ctx) {\n    return function() {\n        return ctx.font;\n    };\n};\n\nexports.setFont = function(ctx) {\n    return function(fontspec) {\n        return function() {\n            ctx.font = fontspec;\n        };\n    };\n};\n\nexports.fillText = function(ctx) {\n    return function(text) {\n        return function(x) {\n            return function(y) {\n                return function() {\n                    ctx.fillText(text, x, y);\n                };\n            };\n        };\n    };\n};\n\nexports.strokeText = function(ctx) {\n    return function(text) {\n        return function(x) {\n            return function(y) {\n                return function() {\n                    ctx.strokeText(text, x, y);\n                };\n            };\n        };\n    };\n};\n\nexports.measureText = function(ctx) {\n    return function(text) {\n        return function() {\n            return ctx.measureText(text);\n        };\n    };\n};\n\nexports.save = function(ctx) {\n    return function() {\n        ctx.save();\n    };\n};\n\nexports.restore = function(ctx) {\n    return function() {\n        ctx.restore();\n    };\n};\n\nexports.imageDataWidth = function(image) {\n    return image.width;\n};\n\nexports.imageDataHeight = function(image) {\n    return image.height;\n};\n\nexports.imageDataBuffer = function(image) {\n    return image.data;\n};\n\nexports.getImageData = function(ctx) {\n    return function(x) {\n        return function(y) {\n            return function(w) {\n                return function(h) {\n                    return function() {\n                        return ctx.getImageData(x, y, w, h);\n                    };\n                };\n            };\n        };\n    };\n};\n\nexports.putImageDataFull = function(ctx) {\n    return function(image_data) {\n        return function(x) {\n            return function(y) {\n                return function(dx) {\n                    return function(dy) {\n                        return function(dw) {\n                            return function(dh) {\n                                return function() {\n                                    ctx.putImageData(image_data, x, y, dx, dy, dw, dh);\n                                };\n                            };\n                        };\n                    };\n                };\n            };\n        };\n    };\n};\n\nexports.putImageData = function(ctx) {\n    return function(image_data) {\n        return function(x) {\n            return function(y) {\n                return function() {\n                    ctx.putImageData(image_data, x, y);\n                };\n            };\n        };\n    };\n};\n\nexports.createImageData = function(ctx) {\n    return function(sw) {\n        return function(sh) {\n            return function() {\n                return ctx.createImageData(sw, sh);\n            };\n        };\n    };\n};\n\nexports.createImageDataCopy = function(ctx) {\n    return function(image_data) {\n        return function() {\n            return ctx.createImageData(image_data);\n        };\n    };\n};\n\nexports.drawImage = function(ctx) {\n    return function(image_source) {\n        return function(dx) {\n            return function(dy) {\n                return function() {\n                    ctx.drawImage(image_source, dx, dy);\n                };\n            };\n        };\n    };\n};\n\nexports.drawImageScale = function(ctx) {\n    return function(image_source) {\n        return function(dx) {\n            return function(dy) {\n                return function(dWidth) {\n                    return function(dHeight) {\n                        return function() {\n                            ctx.drawImage(image_source, dx, dy, dWidth, dHeight);\n                        };\n                    };\n                };\n            };\n        };\n    };\n};\n\nexports.drawImageFull = function(ctx) {\n    return function(image_source) {\n        return function(sx) {\n            return function(sy) {\n                return function(sWidth) {\n                    return function(sHeight) {\n                        return function(dx) {\n                            return function(dy) {\n                                return function(dWidth) {\n                                    return function(dHeight) {\n                                        return function() {\n                                            ctx.drawImage(image_source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n                                        };\n                                    };\n                                };\n                            };\n                        };\n                    };\n                };\n            };\n        };\n    };\n};\n\nexports.createPatternImpl = function(ctx) {\n    return function(img) {\n        return function(repeat) {\n            return function() {\n                return ctx.createPattern(img, repeat);\n            };\n        };\n    };\n};\n\nexports.setPatternFillStyle = function(ctx) {\n    return function(pattern) {\n        return function() {\n            ctx.fillStyle = pattern;\n        };\n    };\n};\n\nexports.createLinearGradient = function(ctx) {\n    return function(linearGradient) {\n        return function() {\n            return ctx.createLinearGradient(linearGradient.x0, linearGradient.y0, linearGradient.x1, linearGradient.y1);\n        };\n    };\n};\n\nexports.createRadialGradient = function(ctx) {\n    return function(radialGradient) {\n        return function() {\n            return ctx.createRadialGradient(radialGradient.x0, radialGradient.y0, radialGradient.r0, radialGradient.x1, radialGradient.y1, radialGradient.r1);\n        };\n    };\n};\n\nexports.addColorStop = function(gradient) {\n    return function(stop) {\n        return function(color) {\n            return function() {\n                gradient.addColorStop(stop, color);\n            };\n        };\n    };\n};\n\nexports.setGradientFillStyle = function(ctx) {\n    return function(gradient) {\n        return function() {\n            ctx.fillStyle = gradient;\n        };\n    };\n};\n\nexports.quadraticCurveTo = function(ctx) {\n    return function(qCurve) {\n        return function() {\n            ctx.quadraticCurveTo(qCurve.cpx, qCurve.cpy, qCurve.x, qCurve.y);\n        };\n    };\n};\n\nexports.bezierCurveTo = function(ctx) {\n    return function(bCurve) {\n        return function() {\n            ctx.bezierCurveTo(bCurve.cp1x, bCurve.cp1y, bCurve.cp2x, bCurve.cp2y, bCurve.x, bCurve.y);\n        };\n    };\n};\n","-- | This module defines types for some global Javascript functions\n-- | and values.\nmodule Global\n  ( nan\n  , isNaN\n  , infinity\n  , isFinite\n  , readInt\n  , readFloat\n  , toFixed\n  , toExponential\n  , toPrecision\n  , decodeURI\n  , encodeURI\n  , decodeURIComponent\n  , encodeURIComponent\n  ) where\n\nimport Prelude\nimport Data.Function.Uncurried (Fn3, Fn4, runFn3, runFn4)\nimport Data.Maybe (Maybe(..))\n\n-- | Not a number (NaN)\nforeign import nan :: Number\n\n-- | Test whether a number is NaN\nforeign import isNaN :: Number -> Boolean\n\n-- | Positive infinity\nforeign import infinity :: Number\n\n-- | Test whether a number is finite\nforeign import isFinite :: Number -> Boolean\n\n-- | Parse an integer from a `String` in the specified base\nforeign import readInt :: Int -> String -> Number\n\n-- | Parse a floating point value from a `String`\nforeign import readFloat :: String -> Number\n\nforeign import _toFixed :: forall a. Fn4 (String -> a) (String -> a) Int Number a\n\nforeign import _toExponential :: forall a. Fn4 (String -> a) (String -> a) Int Number a\n\nforeign import _toPrecision :: forall a. Fn4 (String -> a) (String -> a) Int Number a\n\n-- | Formats Number as a String with limited number of digits after the dot.\n-- | May return `Nothing` when specified number of digits is less than 0 or\n-- | greater than 20. See ECMA-262 for more information.\ntoFixed :: Int -> Number -> Maybe String\ntoFixed digits n = runFn4 _toFixed (const Nothing) Just digits n\n\n-- | Formats Number as String in exponential notation limiting number of digits\n-- | after the decimal dot. May return `Nothing` when specified number of\n-- | digits is less than 0 or greater than 20 depending on the implementation.\n-- | See ECMA-262 for more information.\ntoExponential :: Int -> Number -> Maybe String\ntoExponential digits n = runFn4 _toExponential (const Nothing) Just digits n\n\n-- | Formats Number as String in fixed-point or exponential notation rounded\n-- | to specified number of significant digits. May return `Nothing` when\n-- | precision is less than 1 or greater than 21 depending on the\n-- | implementation. See ECMA-262 for more information.\ntoPrecision :: Int -> Number -> Maybe String\ntoPrecision digits n = runFn4 _toPrecision (const Nothing) Just digits n\n\nforeign import _decodeURI :: forall a. Fn3 (String -> a) (String -> a) String a\n\nforeign import _encodeURI :: forall a. Fn3 (String -> a) (String -> a) String a\n\nforeign import _decodeURIComponent :: forall a. Fn3 (String -> a) (String -> a) String a\n\nforeign import _encodeURIComponent :: forall a. Fn3 (String -> a) (String -> a) String a\n\n-- | URI decoding. Returns `Nothing` when given a value with undecodeable\n-- | escape sequences.\ndecodeURI :: String -> Maybe String\ndecodeURI s = runFn3 _decodeURI (const Nothing) Just s\n\n-- | URI encoding. Returns `Nothing` when given a value with unencodeable\n-- | characters.\nencodeURI :: String -> Maybe String\nencodeURI s = runFn3 _encodeURI (const Nothing) Just s\n\n-- | URI component decoding. Returns `Nothing` when given a value with\n-- | undecodeable escape sequences.\ndecodeURIComponent :: String -> Maybe String\ndecodeURIComponent s = runFn3 _decodeURIComponent (const Nothing) Just s\n\n-- | URI component encoding. Returns `Nothing` when given a value with\n-- | unencodeable characters.\nencodeURIComponent :: String -> Maybe String\nencodeURIComponent s = runFn3 _encodeURIComponent (const Nothing) Just s\n","/* globals exports */\n\"use strict\";\n\nexports.nan = NaN;\n\nexports.isNaN = isNaN;\n\nexports.infinity = Infinity;\n\nexports.isFinite = isFinite;\n\nexports.readInt = function (radix) {\n  return function (n) {\n    return parseInt(n, radix);\n  };\n};\n\nexports.readFloat = parseFloat;\n\nvar formatNumber = function (format) {\n  return function (fail, succ, digits, n) {\n    try {\n      return succ(n[format](digits));\n    }\n    catch (e) {\n      return fail(e.message);\n    }\n  };\n};\n\nexports._toFixed = formatNumber(\"toFixed\");\nexports._toExponential = formatNumber(\"toExponential\");\nexports._toPrecision = formatNumber(\"toPrecision\");\n\nvar encdecURI = function (encdec) {\n  return function (fail, succ, s) {\n    try {\n      return succ(encdec(s));\n    }\n    catch (e) {\n      return fail(e.message);\n    }\n  };\n};\n\nexports._decodeURI = encdecURI(decodeURI);\nexports._encodeURI = encdecURI(encodeURI);\nexports._decodeURIComponent = encdecURI(decodeURIComponent);\nexports._encodeURIComponent = encdecURI(encodeURIComponent);\n","-- | This module provides the `Effect` type, which is used to represent\n-- | _native_ effects. The `Effect` type provides a typed API for effectful\n-- | computations, while at the same time generating efficient JavaScript.\nmodule Effect\n  ( Effect\n  , untilE, whileE, forE, foreachE\n  ) where\n\nimport Prelude\n\nimport Control.Apply (lift2)\n\n-- | A native effect. The type parameter denotes the return type of running the\n-- | effect, that is, an `Effect Int` is a possibly-effectful computation which\n-- | eventually produces a value of the type `Int` when it finishes.\nforeign import data Effect :: Type -> Type\n\ninstance functorEffect :: Functor Effect where\n  map = liftA1\n\ninstance applyEffect :: Apply Effect where\n  apply = ap\n\ninstance applicativeEffect :: Applicative Effect where\n  pure = pureE\n\nforeign import pureE :: forall a. a -> Effect a\n\ninstance bindEffect :: Bind Effect where\n  bind = bindE\n\nforeign import bindE :: forall a b. Effect a -> (a -> Effect b) -> Effect b\n\ninstance monadEffect :: Monad Effect\n\n-- | The `Semigroup` instance for effects allows you to run two effects, one\n-- | after the other, and then combine their results using the result type's\n-- | `Semigroup` instance.\ninstance semigroupEffect :: Semigroup a => Semigroup (Effect a) where\n  append = lift2 append\n\n-- | If you have a `Monoid a` instance, then `mempty :: Effect a` is defined as\n-- | `pure mempty`.\ninstance monoidEffect :: Monoid a => Monoid (Effect a) where\n  mempty = pureE mempty\n\n-- | Loop until a condition becomes `true`.\n-- |\n-- | `untilE b` is an effectful computation which repeatedly runs the effectful\n-- | computation `b`, until its return value is `true`.\nforeign import untilE :: Effect Boolean -> Effect Unit\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `whileE b m` is effectful computation which runs the effectful computation\n-- | `b`. If its result is `true`, it runs the effectful computation `m` and\n-- | loops. If not, the computation ends.\nforeign import whileE :: forall a. Effect Boolean -> Effect a -> Effect Unit\n\n-- | Loop over a consecutive collection of numbers.\n-- |\n-- | `forE lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import forE :: Int -> Int -> (Int -> Effect Unit) -> Effect Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `foreachE xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreachE :: forall a. Array a -> (a -> Effect Unit) -> Effect Unit\n","\"use strict\";\n\nexports.pureE = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexports.bindE = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexports.untilE = function (f) {\n  return function () {\n    while (!f());\n    return {};\n  };\n};\n\nexports.whileE = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n      return {};\n    };\n  };\n};\n\nexports.forE = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexports.foreachE = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n","\"use strict\";\n\nexports.unsafePerformEffect = function (f) {\n  return f();\n};\n","-- | This module defines an effect and actions for working with\n-- | global mutable variables.\n-- |\n-- | _Note_: `Control.Monad.ST` provides a _safe_ alternative\n-- | to global mutable variables when mutation is restricted to a\n-- | local scope.\nmodule Effect.Ref where\n\nimport Prelude\n\nimport Effect (Effect)\n\n-- | A value of type `Ref a` represents a mutable reference\n-- | which holds a value of type `a`.\nforeign import data Ref :: Type -> Type\n\n-- | Create a new mutable reference containing the specified value.\nforeign import new :: forall s. s -> Effect (Ref s)\n\n-- | Read the current value of a mutable reference\nforeign import read :: forall s. Ref s -> Effect s\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value.\nforeign import modify' :: forall s b. (s -> { state :: s, value :: b }) -> Ref s -> Effect b\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value. The updated value is returned.\nmodify :: forall s. (s -> s) -> Ref s -> Effect s\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\nmodify_ :: forall s. (s -> s) -> Ref s -> Effect Unit\nmodify_ f s = void $ modify f s\n\n-- | Update the value of a mutable reference to the specified value.\nforeign import write :: forall s. s -> Ref s -> Effect Unit\n","\"use strict\";\n\nexports.new = function (val) {\n  return function () {\n    return { value: val };\n  };\n};\n\nexports.read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexports[\"modify'\"] = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexports.write = function (val) {\n  return function (ref) {\n    return function () {\n      ref.value = val;\n      return {};\n    };\n  };\n};\n","module Effect.Random where\n\nimport Prelude\n\nimport Effect (Effect)\n\nimport Data.Int (toNumber, floor)\n\n-- | Returns a random number between 0 (inclusive) and 1 (exclusive). This is\n-- | a direct wrapper around JavaScript's `Math.random()`.\nforeign import random :: Effect Number\n\n-- | Takes a range specified by `low` (the first argument) and `high` (the\n-- | second), and returns a random integer uniformly distributed in the closed\n-- | interval `[low, high]`. It is unspecified what happens if `low > high`,\n-- | or if either of `low` or `high` is not an integer.\n-- |\n-- | For example:\n-- | ``` purescript\n-- | randomInt 1 10 >>= Console.print\n-- | ```\n-- | will print a random integer between 1 and 10.\nrandomInt :: Int -> Int -> Effect Int\nrandomInt low high = do\n  n <- random\n  let asNumber = (toNumber high - toNumber low + one) * n + toNumber low\n  pure $ floor asNumber\n\n-- | Returns a random number between a minimum value (inclusive) and a maximum\n-- | value (exclusive). It is unspecified what happens if `maximum < minimum`.\n-- |\n-- | For example:\n-- | ``` purescript\n-- | randomRange 1.0 2.0 >>= Console.print\n-- | ```\n-- | will print a random number between 1 and 2.\nrandomRange :: Number -> Number -> Effect Number\nrandomRange min max = do\n    n <- random\n    pure (n * (max - min) + min)\n\n-- | Returns a random boolean value with an equal chance of being `true` or\n-- | `false`.\nrandomBool :: Effect Boolean\nrandomBool = (_ < 0.5) <$> random\n","\"use strict\";\n\nexports.random = Math.random;\n","-- | This module defines an effect, actions and handlers for working\n-- | with JavaScript exceptions.\n\nmodule Effect.Exception\n  ( Error\n  , error\n  , message\n  , name\n  , stack\n  , throwException\n  , catchException\n  , throw\n  , try\n  ) where\n\nimport Prelude\n\nimport Effect (Effect)\n\nimport Data.Either (Either(..))\nimport Data.Maybe (Maybe(..))\n\n-- | The type of JavaScript errors\nforeign import data Error :: Type\n\ninstance showError :: Show Error where\n  show = showErrorImpl\n\nforeign import showErrorImpl :: Error -> String\n\n-- | Create a JavaScript error, specifying a message\nforeign import error :: String -> Error\n\n-- | Get the error message from a JavaScript error\nforeign import message :: Error -> String\n\n-- | Get the error name when defined, or fallback to 'Error'\nforeign import name :: Error -> String\n\n-- | Get the stack trace from a JavaScript error\nstack :: Error -> Maybe String\nstack = stackImpl Just Nothing\n\nforeign import stackImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Error\n  -> Maybe String\n\n-- | Throw an exception\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = do\n-- |   x <- readNumber\n-- |   when (x < 0) $ throwException $\n-- |     error \"Expected a non-negative number\"\n-- | ```\nforeign import throwException\n  :: forall a\n   . Error\n  -> Effect a\n\n-- | Catch an exception by providing an exception handler.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = catchException print do\n-- |   Console.log \"Exceptions thrown in this block will be logged to the console\"\n-- | ```\nforeign import catchException\n  :: forall a\n   . (Error -> Effect a)\n  -> Effect a\n  -> Effect a\n\n-- | A shortcut allowing you to throw an error in one step. Defined as\n-- | `throwException <<< error`.\nthrow :: forall a. String -> Effect a\nthrow = throwException <<< error\n\n-- | Runs an Eff and returns eventual Exceptions as a `Left` value. If the\n-- | computation succeeds the result gets wrapped in a `Right`.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main :: forall eff. Effect Unit\n-- | main = do\n-- |   result <- try (readTextFile UTF8 \"README.md\")\n-- |   case result of\n-- |     Right lines ->\n-- |       Console.log (\"README: \\n\" <> lines )\n-- |     Left error ->\n-- |       Console.error (\"Couldn't open README.md. Error was: \" <> show error)\n-- | ```\n\ntry :: forall a. Effect a -> Effect (Either Error a)\ntry action = catchException (pure <<< Left) (Right <$> action)\n","\"use strict\";\n\nexports.showErrorImpl = function (err) {\n  return err.stack || err.toString();\n};\n\nexports.error = function (msg) {\n  return new Error(msg);\n};\n\nexports.message = function (e) {\n  return e.message;\n};\n\nexports.name = function (e) {\n  return e.name || \"Error\";\n};\n\nexports.stackImpl = function (just) {\n  return function (nothing) {\n    return function (e) {\n      return e.stack ? just(e.stack) : nothing;\n    };\n  };\n};\n\nexports.throwException = function (e) {\n  return function () {\n    throw e;\n  };\n};\n\nexports.catchException = function (c) {\n  return function (t) {\n    return function () {\n      try {\n        return t();\n      } catch (e) {\n        if (e instanceof Error || Object.prototype.toString.call(e) === \"[object Error]\") {\n          return c(e)();\n        } else {\n          return c(new Error(e.toString()))();\n        }\n      }\n    };\n  };\n};\n","module Effect.Exception.Unsafe where\n\nimport Effect.Exception (Error, error, throwException)\nimport Effect.Unsafe (unsafePerformEffect)\nimport Control.Semigroupoid ((<<<))\n\n-- | Throw an exception in pure code. This function should be used very\n-- | sparingly, as it can cause unexpected crashes at runtime.\nunsafeThrowException :: forall a. Error -> a\nunsafeThrowException = unsafePerformEffect <<< throwException\n\n-- | Defined as `unsafeThrowException <<< error`.\nunsafeThrow :: forall a. String -> a\nunsafeThrow = unsafeThrowException <<< error\n","module Effect.Events where\n\nimport Effect\nimport Effect.Class (class MonadEffect)\nimport Prelude (Unit)\n\ndata Key = Up | Down | Left | Right\n\nforeign import onKeyDown :: forall m. MonadEffect m => String -> m Unit -> Effect Unit","\"use strict\"\n\n\n\n\nexports.onKeyDown = mEffect => key => handler => _ => {\n    window.addEventListener(\"keydown\", e => {\n        if (e.code === key) {\n            handler()\n        }\n    })\n}","module Effect.Console where\n\nimport Effect (Effect)\n\nimport Data.Show (class Show, show)\nimport Data.Unit (Unit)\n\n-- | Write a message to the console.\nforeign import log\n  :: String\n  -> Effect Unit\n\n-- | Write a value to the console, using its `Show` instance to produce a\n-- | `String`.\nlogShow :: forall a. Show a => a -> Effect Unit\nlogShow a = log (show a)\n\n-- | Write an warning to the console.\nforeign import warn\n  :: String\n  -> Effect Unit\n\n-- | Write an warning value to the console, using its `Show` instance to produce\n-- | a `String`.\nwarnShow :: forall a. Show a => a -> Effect Unit\nwarnShow a = warn (show a)\n\n-- | Write an error to the console.\nforeign import error\n  :: String\n  -> Effect Unit\n\n-- | Write an error value to the console, using its `Show` instance to produce a\n-- | `String`.\nerrorShow :: forall a. Show a => a -> Effect Unit\nerrorShow a = error (show a)\n\n-- | Write an info message to the console.\nforeign import info\n  :: String\n  -> Effect Unit\n\n-- | Write an info value to the console, using its `Show` instance to produce a\n-- | `String`.\ninfoShow :: forall a. Show a => a -> Effect Unit\ninfoShow a = info (show a)\n\n-- | Start a named timer.\nforeign import time :: String -> Effect Unit\n\n-- | Stop a named timer and print time since it started in milliseconds.\nforeign import timeEnd :: String -> Effect Unit\n","\"use strict\";\n\nexports.log = function (s) {\n  return function () {\n    console.log(s);\n    return {};\n  };\n};\n\nexports.warn = function (s) {\n  return function () {\n    console.warn(s);\n    return {};\n  };\n};\n\nexports.error = function (s) {\n  return function () {\n    console.error(s);\n    return {};\n  };\n};\n\nexports.info = function (s) {\n  return function () {\n    console.info(s);\n    return {};\n  };\n};\n\nexports.time = function (s) {\n  return function () {\n    console.time(s);\n    return {};\n  };\n};\n\nexports.timeEnd = function (s) {\n  return function () {\n    console.timeEnd(s);\n    return {};\n  };\n};\n","module Effect.Class where\n\nimport Control.Category (identity)\nimport Control.Monad (class Monad)\nimport Effect (Effect)\n\n-- | The `MonadEffect` class captures those monads which support native effects.\n-- |\n-- | Instances are provided for `Effect` itself, and the standard monad\n-- | transformers.\n-- |\n-- | `liftEffect` can be used in any appropriate monad transformer stack to lift an\n-- | action of type `Effect a` into the monad.\n-- |\nclass Monad m <= MonadEffect m where\n  liftEffect :: forall a. Effect a -> m a\n\ninstance monadEffectEffect :: MonadEffect Effect where\n  liftEffect = identity\n","module Data.Void (Void, absurd) where\n\nimport Data.Show (class Show)\n\n-- | An uninhabited data type.\n-- |\n-- | `Void` is useful to eliminate the possibility of a value being created.\n-- | For example, a value of type `Either Void Boolean` can never have\n-- | a Left value created in PureScript.\nnewtype Void = Void Void\n\ninstance showVoid :: Show Void where\n  show = absurd\n\n-- | Eliminator for the `Void` type.\n-- | Useful for stating that some code branch is impossible because you've\n-- | \"acquired\" a value of type `Void` (which you can't).\n-- |\n-- | ```purescript\n-- | rightOnly :: forall t . Either Void t -> t\n-- | rightOnly (Left v) = absurd v\n-- | rightOnly (Right t) = t\n-- | ```\nabsurd :: forall a. Void -> a\nabsurd a = spin a\n  where\n  spin (Void b) = spin b\n","module Data.Unit where\n\nimport Data.Show (class Show)\n\n-- | The `Unit` type has a single inhabitant, called `unit`. It represents\n-- | values with no computational content.\n-- |\n-- | `Unit` is often used, wrapped in a monadic type constructor, as the\n-- | return type of a computation where only the _effects_ are important.\nforeign import data Unit :: Type\n\n-- | `unit` is the sole inhabitant of the `Unit` type.\nforeign import unit :: Unit\n\ninstance showUnit :: Show Unit where\n  show _ = \"unit\"\n","\"use strict\";\n\nexports.unit = {};\n","module Data.Unfoldable1\n  ( class Unfoldable1, unfoldr1\n  , replicate1\n  , replicate1A\n  , singleton\n  , range\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..), fromJust, isNothing)\nimport Data.Semigroup.Traversable (class Traversable1, sequence1)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Partial.Unsafe (unsafePartial)\n\n-- | This class identifies data structures which can be _unfolded_.\n-- |\n-- | The generating function `f` in `unfoldr1 f` corresponds to the `uncons`\n-- | operation of a non-empty list or array; it always returns a value, and\n-- | then optionally a value to continue unfolding from.\n-- |\n-- | Note that, in order to provide an `Unfoldable1 t` instance, `t` need not\n-- | be a type which is guaranteed to be non-empty. For example, the fact that\n-- | lists can be empty does not prevent us from providing an\n-- | `Unfoldable1 List` instance. However, the result of `unfoldr1` should\n-- | always be non-empty.\n-- |\n-- | Every type which has an `Unfoldable` instance can be given an\n-- | `Unfoldable1` instance (and, in fact, is required to, because\n-- | `Unfoldable1` is a superclass of `Unfoldable`). However, there are types\n-- | which have `Unfoldable1` instances but cannot have `Unfoldable` instances.\n-- | In particular, types which are guaranteed to be non-empty, such as\n-- | `NonEmptyList`, cannot be given `Unfoldable` instances.\n-- |\n-- | The utility of this class, then, is that it provides an `Unfoldable`-like\n-- | interface while still permitting instances for guaranteed-non-empty types\n-- | like `NonEmptyList`.\nclass Unfoldable1 t where\n  unfoldr1 :: forall a b. (b -> Tuple a (Maybe b)) -> b -> t a\n\ninstance unfoldable1Array :: Unfoldable1 Array where\n  unfoldr1 = unfoldr1ArrayImpl isNothing (unsafePartial fromJust) fst snd\n\nforeign import unfoldr1ArrayImpl\n  :: forall a b\n   . (forall x. Maybe x -> Boolean)\n  -> (forall x. Maybe x -> x)\n  -> (forall x y. Tuple x y -> x)\n  -> (forall x y. Tuple x y -> y)\n  -> (b -> Tuple a (Maybe b))\n  -> b\n  -> Array a\n\n-- | Replicate a value `n` times. At least one value will be produced, so values\n-- | `n` less than 1 will be treated as 1.\n-- |\n-- | ``` purescript\n-- | replicate1 2 \"foo\" == (NEL.cons \"foo\" (NEL.singleton \"foo\") :: NEL.NonEmptyList String)\n-- | replicate1 0 \"foo\" == (NEL.singleton \"foo\" :: NEL.NonEmptyList String)\n-- | ```\nreplicate1 :: forall f a. Unfoldable1 f => Int -> a -> f a\nreplicate1 n v = unfoldr1 step (n - 1)\n  where\n    step :: Int -> Tuple a (Maybe Int)\n    step i\n      | i <= 0 = Tuple v Nothing\n      | otherwise = Tuple v (Just (i - 1))\n\n-- | Perform an `Apply` action `n` times (at least once, so values `n` less\n-- | than 1 will be treated as 1), and accumulate the results.\n-- |\n-- | ``` purescript\n-- | > replicate1A 2 (randomInt 1 10) :: Effect (NEL.NonEmptyList Int)\n-- | (NonEmptyList (NonEmpty 8 (2 : Nil)))\n-- | > replicate1A 0 (randomInt 1 10) :: Effect (NEL.NonEmptyList Int)\n-- | (NonEmptyList (NonEmpty 4 Nil))\n-- | ```\nreplicate1A\n  :: forall m f a\n   . Apply m\n  => Unfoldable1 f\n  => Traversable1 f\n  => Int\n  -> m a\n  -> m (f a)\nreplicate1A n m = sequence1 (replicate1 n m)\n\n-- | Contain a single value. For example:\n-- |\n-- | ``` purescript\n-- | singleton \"foo\" == (NEL.singleton \"foo\" :: NEL.NonEmptyList String)\n-- | ```\nsingleton :: forall f a. Unfoldable1 f => a -> f a\nsingleton = replicate1 1\n\n-- | Create an `Unfoldable1` containing a range of values, including both\n-- | endpoints.\n-- |\n-- | ``` purescript\n-- | range 0 0 == (NEL.singleton 0 :: NEL.NonEmptyList Int)\n-- | range 1 2 == (NEL.cons 1 (NEL.singleton 2) :: NEL.NonEmptyList Int)\n-- | range 2 0 == (NEL.cons 2 (NEL.cons 1 (NEL.singleton 0)) :: NEL.NonEmptyList Int)\n-- | ```\nrange :: forall f. Unfoldable1 f => Int -> Int -> f Int\nrange start end =\n  let delta = if end >= start then 1 else -1 in unfoldr1 (go delta) start\n  where\n    go delta i =\n      let i' = i + delta\n      in Tuple i (if i == end then Nothing else Just i')\n","\"use strict\";\n\nexports.unfoldr1ArrayImpl = function (isNothing) {\n  return function (fromJust) {\n    return function (fst) {\n      return function (snd) {\n        return function (f) {\n          return function (b) {\n            var result = [];\n            var value = b;\n            while (true) { // eslint-disable-line no-constant-condition\n              var tuple = f(value);\n              result.push(fst(tuple));\n              var maybe = snd(tuple);\n              if (isNothing(maybe)) return result;\n              value = fromJust(maybe);\n            }\n          };\n        };\n      };\n    };\n  };\n};\n","-- | This module provides a type class for _unfoldable functors_, i.e.\n-- | functors which support an `unfoldr` operation.\n-- |\n-- | This allows us to unify various operations on arrays, lists,\n-- | sequences, etc.\n\nmodule Data.Unfoldable\n  ( class Unfoldable, unfoldr\n  , replicate\n  , replicateA\n  , none\n  , fromMaybe\n  , module Data.Unfoldable1\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..), isNothing, fromJust)\nimport Data.Traversable (class Traversable, sequence)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable1 (class Unfoldable1, unfoldr1, singleton, range, replicate1, replicate1A)\nimport Partial.Unsafe (unsafePartial)\n\n-- | This class identifies (possibly empty) data structures which can be\n-- | _unfolded_.\n-- |\n-- | The generating function `f` in `unfoldr f` is understood as follows:\n-- |\n-- | - If `f b` is `Nothing`, then `unfoldr f b` should be empty.\n-- | - If `f b` is `Just (Tuple a b1)`, then `unfoldr f b` should consist of `a`\n-- |   appended to the result of `unfoldr f b1`.\n-- |\n-- | Note that it is not possible to give `Unfoldable` instances to types which\n-- | represent structures which are guaranteed to be non-empty, such as\n-- | `NonEmptyArray`: consider what `unfoldr (const Nothing)` should produce.\n-- | Structures which are guaranteed to be non-empty can instead be given\n-- | `Unfoldable1` instances.\nclass Unfoldable1 t <= Unfoldable t where\n  unfoldr :: forall a b. (b -> Maybe (Tuple a b)) -> b -> t a\n\ninstance unfoldableArray :: Unfoldable Array where\n  unfoldr = unfoldrArrayImpl isNothing (unsafePartial fromJust) fst snd\n\nforeign import unfoldrArrayImpl\n  :: forall a b\n   . (forall x. Maybe x -> Boolean)\n  -> (forall x. Maybe x -> x)\n  -> (forall x y. Tuple x y -> x)\n  -> (forall x y. Tuple x y -> y)\n  -> (b -> Maybe (Tuple a b))\n  -> b\n  -> Array a\n\n-- | Replicate a value some natural number of times.\n-- | For example:\n-- |\n-- | ``` purescript\n-- | replicate 2 \"foo\" == ([\"foo\", \"foo\"] :: Array String)\n-- | ```\nreplicate :: forall f a. Unfoldable f => Int -> a -> f a\nreplicate n v = unfoldr step n\n  where\n    step :: Int -> Maybe (Tuple a Int)\n    step i =\n      if i <= 0 then Nothing\n      else Just (Tuple v (i - 1))\n\n-- | Perform an Applicative action `n` times, and accumulate all the results.\n-- |\n-- | ``` purescript\n-- | > replicateA 5 (randomInt 1 10) :: Effect (Array Int)\n-- | [1,3,2,7,5]\n-- | ```\nreplicateA\n  :: forall m f a\n   . Applicative m\n  => Unfoldable f\n  => Traversable f\n  => Int\n  -> m a\n  -> m (f a)\nreplicateA n m = sequence (replicate n m)\n\n-- | The container with no elements - unfolded with zero iterations.\n-- | For example:\n-- |\n-- | ``` purescript\n-- | none == ([] :: Array Unit)\n-- | ```\nnone :: forall f a. Unfoldable f => f a\nnone = unfoldr (const Nothing) unit\n\n-- | Convert a Maybe to any Unfoldable, such as lists or arrays.\n-- |\n-- | ``` purescript\n-- | fromMaybe (Nothing :: Maybe Int) == []\n-- | fromMaybe (Just 1) == [1]\n-- | ```\nfromMaybe :: forall f a. Unfoldable f => Maybe a -> f a\nfromMaybe = unfoldr (\\b -> flip Tuple Nothing <$> b)\n","\"use strict\";\n\nexports.unfoldrArrayImpl = function (isNothing) {\n  return function (fromJust) {\n    return function (fst) {\n      return function (snd) {\n        return function (f) {\n          return function (b) {\n            var result = [];\n            var value = b;\n            while (true) { // eslint-disable-line no-constant-condition\n              var maybe = f(value);\n              if (isNothing(maybe)) return result;\n              var tuple = fromJust(maybe);\n              result.push(fst(tuple));\n              value = snd(tuple);\n            }\n          };\n        };\n      };\n    };\n  };\n};\n","-- | A data type and functions for working with ordered pairs.\nmodule Data.Tuple where\n\nimport Prelude\n\nimport Control.Biapplicative (class Biapplicative)\nimport Control.Biapply (class Biapply)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy, defer)\nimport Data.Bifoldable (class Bifoldable)\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Bitraversable (class Bitraversable)\nimport Data.Distributive (class Distributive, collectDefault)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable, foldMap)\nimport Data.FoldableWithIndex (class FoldableWithIndex)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.HeytingAlgebra (implies, ff, tt)\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Newtype (unwrap)\nimport Data.Ord (class Ord1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Traversable (class Traversable1)\nimport Data.Traversable (class Traversable)\nimport Data.TraversableWithIndex (class TraversableWithIndex)\nimport Type.Equality (class TypeEquals, from)\n\n-- | A simple product type for wrapping a pair of component values.\ndata Tuple a b = Tuple a b\n\n-- | Allows `Tuple`s to be rendered as a string with `show` whenever there are\n-- | `Show` instances for both component types.\ninstance showTuple :: (Show a, Show b) => Show (Tuple a b) where\n  show (Tuple a b) = \"(Tuple \" <> show a <> \" \" <> show b <> \")\"\n\n-- | Allows `Tuple`s to be checked for equality with `==` and `/=` whenever\n-- | there are `Eq` instances for both component types.\nderive instance eqTuple :: (Eq a, Eq b) => Eq (Tuple a b)\n\nderive instance eq1Tuple :: Eq a => Eq1 (Tuple a)\n\n-- | Allows `Tuple`s to be compared with `compare`, `>`, `>=`, `<` and `<=`\n-- | whenever there are `Ord` instances for both component types. To obtain\n-- | the result, the `fst`s are `compare`d, and if they are `EQ`ual, the\n-- | `snd`s are `compare`d.\nderive instance ordTuple :: (Ord a, Ord b) => Ord (Tuple a b)\n\nderive instance ord1Tuple :: Ord a => Ord1 (Tuple a)\n\ninstance boundedTuple :: (Bounded a, Bounded b) => Bounded (Tuple a b) where\n  top = Tuple top top\n  bottom = Tuple bottom bottom\n\ninstance semigroupoidTuple :: Semigroupoid Tuple where\n  compose (Tuple _ c) (Tuple a _) = Tuple a c\n\n-- | The `Semigroup` instance enables use of the associative operator `<>` on\n-- | `Tuple`s whenever there are `Semigroup` instances for the component\n-- | types. The `<>` operator is applied pairwise, so:\n-- | ```purescript\n-- | (Tuple a1 b1) <> (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n-- | ```\ninstance semigroupTuple :: (Semigroup a, Semigroup b) => Semigroup (Tuple a b) where\n  append (Tuple a1 b1) (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)\n\ninstance monoidTuple :: (Monoid a, Monoid b) => Monoid (Tuple a b) where\n  mempty = Tuple mempty mempty\n\ninstance semiringTuple :: (Semiring a, Semiring b) => Semiring (Tuple a b) where\n  add (Tuple x1 y1) (Tuple x2 y2) = Tuple (add x1 x2) (add y1 y2)\n  one = Tuple one one\n  mul (Tuple x1 y1) (Tuple x2 y2) = Tuple (mul x1 x2) (mul y1 y2)\n  zero = Tuple zero zero\n\ninstance ringTuple :: (Ring a, Ring b) => Ring (Tuple a b) where\n  sub (Tuple x1 y1) (Tuple x2 y2) = Tuple (sub x1 x2) (sub y1 y2)\n\ninstance commutativeRingTuple :: (CommutativeRing a, CommutativeRing b) => CommutativeRing (Tuple a b)\n\ninstance heytingAlgebraTuple :: (HeytingAlgebra a, HeytingAlgebra b) => HeytingAlgebra (Tuple a b) where\n  tt = Tuple tt tt\n  ff = Tuple ff ff\n  implies (Tuple x1 y1) (Tuple x2 y2) = Tuple (x1 `implies` x2) (y1 `implies` y2)\n  conj (Tuple x1 y1) (Tuple x2 y2) = Tuple (conj x1 x2) (conj y1 y2)\n  disj (Tuple x1 y1) (Tuple x2 y2) = Tuple (disj x1 x2) (disj y1 y2)\n  not (Tuple x y) = Tuple (not x) (not y)\n\ninstance booleanAlgebraTuple :: (BooleanAlgebra a, BooleanAlgebra b) => BooleanAlgebra (Tuple a b)\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<$>` operator, applying the function to the second\n-- | component, so:\n-- | ```purescript\n-- | f <$> (Tuple x y) = Tuple x (f y)\n-- | ````\nderive instance functorTuple :: Functor (Tuple a)\n\ninstance functorWithIndexTuple :: FunctorWithIndex Unit (Tuple a) where\n  mapWithIndex f = map $ f unit\n\ninstance invariantTuple :: Invariant (Tuple a) where\n  imap = imapF\n\ninstance bifunctorTuple :: Bifunctor Tuple where\n  bimap f g (Tuple x y) = Tuple (f x) (g y)\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Tuple` with the `<*>` operator whenever there is a `Semigroup` instance\n-- | for the `fst` component, so:\n-- | ```purescript\n-- | (Tuple a1 f) <*> (Tuple a2 x) == Tuple (a1 <> a2) (f x)\n-- | ```\ninstance applyTuple :: (Semigroup a) => Apply (Tuple a) where\n  apply (Tuple a1 f) (Tuple a2 x) = Tuple (a1 <> a2) (f x)\n\ninstance biapplyTuple :: Biapply Tuple where\n  biapply (Tuple f g) (Tuple a b) = Tuple (f a) (g b)\n\ninstance applicativeTuple :: (Monoid a) => Applicative (Tuple a) where\n  pure = Tuple mempty\n\ninstance biapplicativeTuple :: Biapplicative Tuple where\n  bipure = Tuple\n\ninstance bindTuple :: (Semigroup a) => Bind (Tuple a) where\n  bind (Tuple a1 b) f = case f b of\n    Tuple a2 c -> Tuple (a1 <> a2) c\n\ninstance monadTuple :: (Monoid a) => Monad (Tuple a)\n\ninstance extendTuple :: Extend (Tuple a) where\n  extend f t@(Tuple a b) = Tuple a (f t)\n\ninstance comonadTuple :: Comonad (Tuple a) where\n  extract = snd\n\ninstance lazyTuple :: (Lazy a, Lazy b) => Lazy (Tuple a b) where\n  defer f = Tuple (defer $ \\_ -> fst (f unit)) (defer $ \\_ -> snd (f unit))\n\ninstance foldableTuple :: Foldable (Tuple a) where\n  foldr f z (Tuple _ x) = f x z\n  foldl f z (Tuple _ x) = f z x\n  foldMap f (Tuple _ x) = f x\n\ninstance foldable1Tuple :: Foldable1 (Tuple a) where\n  foldMap1 f (Tuple _ x) = f x\n  fold1 (Tuple _ x) = x\n\ninstance foldableWithIndexTuple :: FoldableWithIndex Unit (Tuple a) where\n  foldrWithIndex f z (Tuple _ x) = f unit x z\n  foldlWithIndex f z (Tuple _ x) = f unit z x\n  foldMapWithIndex f (Tuple _ x) = f unit x\n\ninstance bifoldableTuple :: Bifoldable Tuple where\n  bifoldMap f g (Tuple a b) = f a <> g b\n  bifoldr f g z (Tuple a b) = f a (g b z)\n  bifoldl f g z (Tuple a b) = g (f z a) b\n\ninstance traversableTuple :: Traversable (Tuple a) where\n  traverse f (Tuple x y) = Tuple x <$> f y\n  sequence (Tuple x y) = Tuple x <$> y\n\ninstance traversable1Tuple :: Traversable1 (Tuple a) where\n  traverse1 f (Tuple x y) = Tuple x <$> f y\n  sequence1 (Tuple x y) = Tuple x <$> y\n\ninstance traversableWithIndexTuple :: TraversableWithIndex Unit (Tuple a) where\n  traverseWithIndex f (Tuple x y) = Tuple x <$> f unit y\n\ninstance bitraversableTuple :: Bitraversable Tuple where\n  bitraverse f g (Tuple a b) = Tuple <$> f a <*> g b\n  bisequence (Tuple a b) = Tuple <$> a <*> b\n\ninstance distributiveTuple :: TypeEquals a Unit => Distributive (Tuple a) where\n  collect = collectDefault\n  distribute = Tuple (from unit) <<< map snd\n\n-- | Returns the first component of a tuple.\nfst :: forall a b. Tuple a b -> a\nfst (Tuple a _) = a\n\n-- | Returns the second component of a tuple.\nsnd :: forall a b. Tuple a b -> b\nsnd (Tuple _ b) = b\n\n-- | Turn a function that expects a tuple into a function of two arguments.\ncurry :: forall a b c. (Tuple a b -> c) -> a -> b -> c\ncurry f a b = f (Tuple a b)\n\n-- | Turn a function of two arguments into a function that expects a tuple.\nuncurry :: forall a b c. (a -> b -> c) -> Tuple a b -> c\nuncurry f (Tuple a b) = f a b\n\n-- | Exchange the first and second components of a tuple.\nswap :: forall a b. Tuple a b -> Tuple b a\nswap (Tuple a b) = Tuple b a\n\n-- | Lookup a value in a data structure of `Tuple`s, generalizing association lists.\nlookup :: forall a b f. Foldable f => Eq a => a -> f (Tuple a b) -> Maybe b\nlookup a = unwrap <<< foldMap \\(Tuple a' b) -> First (if a == a' then Just b else Nothing)\n","module Data.TraversableWithIndex \n  ( class TraversableWithIndex, traverseWithIndex\n  , traverseWithIndexDefault\n  , forWithIndex\n  , scanlWithIndex\n  , mapAccumLWithIndex\n  , scanrWithIndex\n  , mapAccumRWithIndex\n  , traverseDefault\n  , module Data.Traversable.Accum\n  ) where\n\nimport Prelude\n\nimport Data.FoldableWithIndex (class FoldableWithIndex)\nimport Data.FunctorWithIndex (class FunctorWithIndex, mapWithIndex)\nimport Data.Maybe (Maybe)\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj)\nimport Data.Monoid.Disj (Disj)\nimport Data.Monoid.Dual (Dual)\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Traversable (class Traversable, sequence, traverse)\nimport Data.Traversable.Accum (Accum)\nimport Data.Traversable.Accum.Internal (StateL(..), StateR(..), stateL, stateR)\n\n\n-- | A `Traversable` with an additional index.  \n-- | A `TraversableWithIndex` instance must be compatible with its\n-- | `Traversable` instance\n-- | ```purescript\n-- | traverse f = traverseWithIndex (const f)\n-- | ```\n-- | with its `FoldableWithIndex` instance\n-- | ```\n-- | foldMapWithIndex f = unwrap <<< traverseWithIndex (\\i -> Const <<< f i)\n-- | ```\n-- | and with its `FunctorWithIndex` instance\n-- | ```\n-- | mapWithIndex f = unwrap <<< traverseWithIndex (\\i -> Identity <<< f i)\n-- | ```\n-- |\n-- | A default implementation is provided by `traverseWithIndexDefault`.\nclass (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) <= TraversableWithIndex i t | t -> i where\n  traverseWithIndex :: forall a b m. Applicative m => (i -> a -> m b) -> t a -> m (t b)\n\n-- | A default implementation of `traverseWithIndex` using `sequence` and `mapWithIndex`.\ntraverseWithIndexDefault\n  :: forall i t a b m\n   . TraversableWithIndex i t\n  => Applicative m\n  => (i -> a -> m b)\n  -> t a\n  -> m (t b)\ntraverseWithIndexDefault f = sequence <<< mapWithIndex f\n\ninstance traversableWithIndexArray :: TraversableWithIndex Int Array where\n  traverseWithIndex = traverseWithIndexDefault\n\ninstance traversableWithIndexMaybe :: TraversableWithIndex Unit Maybe where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexFirst :: TraversableWithIndex Unit First where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexLast :: TraversableWithIndex Unit Last where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexAdditive :: TraversableWithIndex Unit Additive where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexDual :: TraversableWithIndex Unit Dual where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexConj :: TraversableWithIndex Unit Conj where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexDisj :: TraversableWithIndex Unit Disj where\n  traverseWithIndex f = traverse $ f unit\n\ninstance traversableWithIndexMultiplicative :: TraversableWithIndex Unit Multiplicative where\n  traverseWithIndex f = traverse $ f unit\n\n-- | A version of `traverseWithIndex` with its arguments flipped.\n-- |\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for [1, 2, 3] \\i x -> do\n-- |   logShow i\n-- |   pure (x * x)\n-- | ```\nforWithIndex\n  :: forall i a b m t\n   . Applicative m\n  => TraversableWithIndex i t\n  => t a\n  -> (i -> a -> m b)\n  -> m (t b)\nforWithIndex = flip traverseWithIndex\n\n-- | Fold a data structure from the left with access to the indices, keeping\n-- | all intermediate results instead of only the final result. Note that the\n-- | initial value does not appear in the result (unlike Haskell's\n-- | `Prelude.scanl`).\n-- |\n-- | ```purescript\n-- | scanlWithIndex (\\i y x -> i + y + x) 0 [1, 2, 3] = [1, 4, 9]\n-- | ```\nscanlWithIndex\n  :: forall i a b f\n   . TraversableWithIndex i f\n  => (i -> b -> a -> b)\n  -> b\n  -> f a\n  -> f b\nscanlWithIndex f b0 xs =\n  (mapAccumLWithIndex (\\i b a -> let b' = f i b a in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the left with access to the indices, keeping\n-- | all intermediate results instead of only the final result.\n-- |\n-- | Unlike `scanlWithIndex`, `mapAccumLWithIndex` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumLWithIndex\n  :: forall i a b s f\n   . TraversableWithIndex i f\n  => (i -> s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumLWithIndex f s0 xs = stateL (traverseWithIndex (\\i a -> StateL \\s -> f i s a) xs) s0\n\n-- | Fold a data structure from the right with access to the indices, keeping\n-- | all intermediate results instead of only the final result. Note that the\n-- | initial value does not appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```purescript\n-- | scanrWithIndex (\\i x y -> i + x + y) 0 [1, 2, 3] = [9, 8, 5]\n-- | ```\nscanrWithIndex\n  :: forall i a b f\n   . TraversableWithIndex i f\n  => (i -> a -> b -> b)\n  -> b\n  -> f a\n  -> f b\nscanrWithIndex f b0 xs =\n  (mapAccumRWithIndex (\\i b a -> let b' = f i a b in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the right with access to the indices, keeping\n-- | all intermediate results instead of only the final result.\n-- |\n-- | Unlike `scanrWithIndex`, `imapAccumRWithIndex` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumRWithIndex\n  :: forall i a b s f\n   . TraversableWithIndex i f\n  => (i -> s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumRWithIndex f s0 xs = stateR (traverseWithIndex (\\i a -> StateR \\s -> f i s a) xs) s0\n\n-- | A default implementation of `traverse` in terms of `traverseWithIndex`\ntraverseDefault\n  :: forall i t a b m\n   . TraversableWithIndex i t\n  => Applicative m\n  => (a -> m b) -> t a -> m (t b)\ntraverseDefault f = traverseWithIndex (const f)\n","module Data.Traversable\n  ( class Traversable, traverse, sequence\n  , traverseDefault, sequenceDefault\n  , for\n  , scanl\n  , scanr\n  , mapAccumL\n  , mapAccumR\n  , module Data.Foldable\n  , module Data.Traversable.Accum\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable, all, and, any, elem, find, fold, foldMap, foldMapDefaultL, foldMapDefaultR, foldl, foldlDefault, foldr, foldrDefault, for_, intercalate, maximum, maximumBy, minimum, minimumBy, notElem, oneOf, or, product, sequence_, sum, traverse_)\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Traversable.Accum (Accum)\nimport Data.Traversable.Accum.Internal (StateL(..), StateR(..), stateL, stateR)\n\n-- | `Traversable` represents data structures which can be _traversed_,\n-- | accumulating results and effects in some `Applicative` functor.\n-- |\n-- | - `traverse` runs an action for every element in a data structure,\n-- |   and accumulates the results.\n-- | - `sequence` runs the actions _contained_ in a data structure,\n-- |   and accumulates the results.\n-- |\n-- | The `traverse` and `sequence` functions should be compatible in the\n-- | following sense:\n-- |\n-- | - `traverse f xs = sequence (f <$> xs)`\n-- | - `sequence = traverse identity`\n-- |\n-- | `Traversable` instances should also be compatible with the corresponding\n-- | `Foldable` instances, in the following sense:\n-- |\n-- | - `foldMap f = runConst <<< traverse (Const <<< f)`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `traverseDefault`\n-- | - `sequenceDefault`\nclass (Functor t, Foldable t) <= Traversable t where\n  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n\n-- | A default implementation of `traverse` using `sequence` and `map`.\ntraverseDefault\n  :: forall t a b m\n   . Traversable t\n  => Applicative m\n  => (a -> m b)\n  -> t a\n  -> m (t b)\ntraverseDefault f ta = sequence (f <$> ta)\n\n-- | A default implementation of `sequence` using `traverse`.\nsequenceDefault\n  :: forall t a m\n   . Traversable t\n  => Applicative m\n  => t (m a)\n  -> m (t a)\nsequenceDefault = traverse identity\n\ninstance traversableArray :: Traversable Array where\n  traverse = traverseArrayImpl apply map pure\n  sequence = sequenceDefault\n\nforeign import traverseArrayImpl\n  :: forall m a b\n   . (m (a -> b) -> m a -> m b)\n  -> ((a -> b) -> m a -> m b)\n  -> (a -> m a)\n  -> (a -> m b)\n  -> Array a\n  -> m (Array b)\n\ninstance traversableMaybe :: Traversable Maybe where\n  traverse _ Nothing  = pure Nothing\n  traverse f (Just x) = Just <$> f x\n  sequence Nothing  = pure Nothing\n  sequence (Just x) = Just <$> x\n\ninstance traversableFirst :: Traversable First where\n  traverse f (First x) = First <$> traverse f x\n  sequence (First x) = First <$> sequence x\n\ninstance traversableLast :: Traversable Last where\n  traverse f (Last x) = Last <$> traverse f x\n  sequence (Last x) = Last <$> sequence x\n\ninstance traversableAdditive :: Traversable Additive where\n  traverse f (Additive x) = Additive <$> f x\n  sequence (Additive x) = Additive <$> x\n\ninstance traversableDual :: Traversable Dual where\n  traverse f (Dual x) = Dual <$> f x\n  sequence (Dual x) = Dual <$> x\n\ninstance traversableConj :: Traversable Conj where\n  traverse f (Conj x) = Conj <$> f x\n  sequence (Conj x) = Conj <$> x\n\ninstance traversableDisj :: Traversable Disj where\n  traverse f (Disj x) = Disj <$> f x\n  sequence (Disj x) = Disj <$> x\n\ninstance traversableMultiplicative :: Traversable Multiplicative where\n  traverse f (Multiplicative x) = Multiplicative <$> f x\n  sequence (Multiplicative x) = Multiplicative <$> x\n\n-- | A version of `traverse` with its arguments flipped.\n-- |\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for [1, 2, 3] \\n -> do\n-- |   print n\n-- |   return (n * n)\n-- | ```\nfor\n  :: forall a b m t\n   . Applicative m\n  => Traversable t\n  => t a\n  -> (a -> m b)\n  -> m (t b)\nfor x f = traverse f x\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanl`).\n-- |\n-- | ```purescript\n-- | scanl (+) 0  [1,2,3] = [1,3,6]\n-- | scanl (-) 10 [1,2,3] = [9,7,4]\n-- | ```\nscanl :: forall a b f. Traversable f => (b -> a -> b) -> b -> f a -> f b\nscanl f b0 xs = (mapAccumL (\\b a -> let b' = f b a in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the left, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanl`, `mapAccumL` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumL\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumL f s0 xs = stateL (traverse (\\a -> StateL \\s -> f s a) xs) s0\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result. Note that the initial value does not\n-- | appear in the result (unlike Haskell's `Prelude.scanr`).\n-- |\n-- | ```purescript\n-- | scanr (+) 0 [1,2,3] = [6,5,3]\n-- | scanr (flip (-)) 10 [1,2,3] = [4,5,7]\n-- | ```\nscanr :: forall a b f. Traversable f => (a -> b -> b) -> b -> f a -> f b\nscanr f b0 xs = (mapAccumR (\\b a -> let b' = f a b in { accum: b', value: b' }) b0 xs).value\n\n-- | Fold a data structure from the right, keeping all intermediate results\n-- | instead of only the final result.\n-- |\n-- | Unlike `scanr`, `mapAccumR` allows the type of accumulator to differ\n-- | from the element type of the final data structure.\nmapAccumR\n  :: forall a b s f\n   . Traversable f\n  => (s -> a -> Accum s b)\n  -> s\n  -> f a\n  -> Accum s (f b)\nmapAccumR f s0 xs = stateR (traverse (\\a -> StateR \\s -> f s a) xs) s0\n","\"use strict\";\n\n// jshint maxparams: 3\n\nexports.traverseArrayImpl = function () {\n  function array1(a) {\n    return [a];\n  }\n\n  function array2(a) {\n    return function (b) {\n      return [a, b];\n    };\n  }\n\n  function array3(a) {\n    return function (b) {\n      return function (c) {\n        return [a, b, c];\n      };\n    };\n  }\n\n  function concat2(xs) {\n    return function (ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (pure) {\n        return function (f) {\n          return function (array) {\n            function go(bot, top) {\n              switch (top - bot) {\n              case 0: return pure([]);\n              case 1: return map(array1)(f(array[bot]));\n              case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));\n              case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));\n              default:\n                // This slightly tricky pivot selection aims to produce two\n                // even-length partitions where possible.\n                var pivot = bot + Math.floor((top - bot) / 4) * 2;\n                return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));\n              }\n            }\n            return go(0, array.length);\n          };\n        };\n      };\n    };\n  };\n}();\n","module Data.Traversable.Accum.Internal\n  ( StateL(..)\n  , stateL\n  , StateR(..)\n  , stateR\n  ) where\n\nimport Prelude\nimport Data.Traversable.Accum (Accum)\n\nnewtype StateL s a = StateL (s -> Accum s a)\n\nstateL :: forall s a. StateL s a -> s -> Accum s a\nstateL (StateL k) = k\n\ninstance functorStateL :: Functor (StateL s) where\n  map f k = StateL \\s -> case stateL k s of\n    { accum: s1, value: a } -> { accum: s1, value: f a }\n\ninstance applyStateL :: Apply (StateL s) where\n  apply f x = StateL \\s -> case stateL f s of\n    { accum: s1, value: f' } -> case stateL x s1 of\n      { accum: s2, value: x' } -> { accum: s2, value: f' x' }\n\ninstance applicativeStateL :: Applicative (StateL s) where\n  pure a = StateL \\s -> { accum: s, value: a }\n\n\nnewtype StateR s a = StateR (s -> Accum s a)\n\nstateR :: forall s a. StateR s a -> s -> Accum s a\nstateR (StateR k) = k\n\ninstance functorStateR :: Functor (StateR s) where\n  map f k = StateR \\s -> case stateR k s of\n    { accum: s1, value: a } -> { accum: s1, value: f a }\n\ninstance applyStateR :: Apply (StateR s) where\n  apply f x = StateR \\s -> case stateR x s of\n    { accum: s1, value: x' } -> case stateR f s1 of\n      { accum: s2, value: f' } -> { accum: s2, value: f' x' }\n\ninstance applicativeStateR :: Applicative (StateR s) where\n  pure a = StateR \\s -> { accum: s, value: a }\n","module Data.Symbol\n  ( class IsSymbol\n  , reflectSymbol\n  , reifySymbol\n  , SProxy(..)\n  ) where\n\n-- | A value-level proxy for a type-level symbol.\ndata SProxy (sym :: Symbol) = SProxy\n\n-- | A class for known symbols\nclass IsSymbol (sym :: Symbol) where\n  reflectSymbol :: SProxy sym -> String\n\n-- local definition for use in `reifySymbol`\nforeign import unsafeCoerce :: forall a b. a -> b\n\nreifySymbol :: forall r. String -> (forall sym. IsSymbol sym => SProxy sym -> r) -> r\nreifySymbol s f = coerce f { reflectSymbol: \\_ -> s } SProxy where\n  coerce\n    :: (forall sym1. IsSymbol sym1              => SProxy sym1 -> r)\n    -> { reflectSymbol :: SProxy \"\" -> String } -> SProxy \"\"   -> r\n  coerce = unsafeCoerce\n\n","\"use strict\";\n\n// module Data.Symbol\n\nexports.unsafeCoerce = function (arg) {\n  return arg;\n};\n\n","module Data.Show\n  ( class Show, show\n  , class ShowRecordFields, showRecordFields\n  ) where\n\nimport Data.Symbol (class IsSymbol, SProxy(..), reflectSymbol)\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Data.RowList (RLProxy(..))\n\n-- | The `Show` type class represents those types which can be converted into\n-- | a human-readable `String` representation.\n-- |\n-- | While not required, it is recommended that for any expression `x`, the\n-- | string `show x` be executable PureScript code which evaluates to the same\n-- | value as the expression `x`.\nclass Show a where\n  show :: a -> String\n\ninstance showBoolean :: Show Boolean where\n  show true = \"true\"\n  show false = \"false\"\n\ninstance showInt :: Show Int where\n  show = showIntImpl\n\ninstance showNumber :: Show Number where\n  show = showNumberImpl\n\ninstance showChar :: Show Char where\n  show = showCharImpl\n\ninstance showString :: Show String where\n  show = showStringImpl\n\ninstance showArray :: Show a => Show (Array a) where\n  show = showArrayImpl show\n\ninstance showRecord :: (RL.RowToList rs ls, ShowRecordFields ls rs) => Show (Record rs) where\n  show record = case showRecordFields (RLProxy :: RLProxy ls) record of\n    [] -> \"{}\"\n    fields -> join \" \" [\"{\", join \", \" fields, \"}\"]\n\n-- | A class for records where all fields have `Show` instances, used to\n-- | implement the `Show` instance for records.\nclass ShowRecordFields rowlist row where\n  showRecordFields :: RLProxy rowlist -> Record row -> Array String\n\ninstance showRecordFieldsNil :: ShowRecordFields RL.Nil row where\n  showRecordFields _ _ = []\n\ninstance showRecordFieldsCons\n    :: ( IsSymbol key\n       , ShowRecordFields rowlistTail row\n       , Show focus\n       )\n    => ShowRecordFields (RL.Cons key focus rowlistTail) row where\n  showRecordFields _ record\n    = cons (join \": \" [ key, show focus ]) tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      focus = unsafeGet key record :: focus\n      tail = showRecordFields (RLProxy :: RLProxy rowlistTail) record\n\nforeign import showIntImpl :: Int -> String\nforeign import showNumberImpl :: Number -> String\nforeign import showCharImpl :: Char -> String\nforeign import showStringImpl :: String -> String\nforeign import showArrayImpl :: forall a. (a -> String) -> Array a -> String\nforeign import cons :: forall a. a -> Array a -> Array a\nforeign import join :: String -> Array String -> String\n","\"use strict\";\n\nexports.showIntImpl = function (n) {\n  return n.toString();\n};\n\nexports.showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexports.showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexports.showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexports.showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n\nexports.cons = function (head) {\n  return function (tail) {\n    return [head].concat(tail);\n  };\n};\n\nexports.join = function (separator) {\n  return function (xs) {\n    return xs.join(separator);\n  };\n};\n","module Data.Semiring\n  ( class Semiring, add, (+), zero, mul, (*), one\n  , class SemiringRecord, addRecord, mulRecord, oneRecord, zeroRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, SProxy(..), reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Data.Row (RProxy(..))\nimport Type.Data.RowList (RLProxy(..))\n\n-- | The `Semiring` class is for types that support an addition and\n-- | multiplication operation.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Commutative monoid under addition:\n-- |   - Associativity: `(a + b) + c = a + (b + c)`\n-- |   - Identity: `zero + a = a + zero = a`\n-- |   - Commutative: `a + b = b + a`\n-- | - Monoid under multiplication:\n-- |   - Associativity: `(a * b) * c = a * (b * c)`\n-- |   - Identity: `one * a = a * one = a`\n-- | - Multiplication distributes over addition:\n-- |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n-- |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n-- | - Annihilation: `zero * a = a * zero = zero`\n-- |\n-- | **Note:** The `Number` and `Int` types are not fully law abiding\n-- | members of this class hierarchy due to the potential for arithmetic\n-- | overflows, and in the case of `Number`, the presence of `NaN` and\n-- | `Infinity` values. The behaviour is unspecified in these cases.\nclass Semiring a where\n  add  :: a -> a -> a\n  zero :: a\n  mul  :: a -> a -> a\n  one  :: a\n\ninfixl 6 add as +\ninfixl 7 mul as *\n\ninstance semiringInt :: Semiring Int where\n  add = intAdd\n  zero = 0\n  mul = intMul\n  one = 1\n\ninstance semiringNumber :: Semiring Number where\n  add = numAdd\n  zero = 0.0\n  mul = numMul\n  one = 1.0\n\ninstance semiringFn :: Semiring b => Semiring (a -> b) where\n  add f g x = f x + g x\n  zero = \\_ -> zero\n  mul f g x = f x * g x\n  one = \\_ -> one\n\ninstance semiringUnit :: Semiring Unit where\n  add _ _ = unit\n  zero = unit\n  mul _ _ = unit\n  one = unit\n\ninstance semiringRecord :: (RL.RowToList row list, SemiringRecord list row row) => Semiring (Record row) where\n  add = addRecord (RLProxy :: RLProxy list)\n  mul = mulRecord (RLProxy :: RLProxy list)\n  one = oneRecord (RLProxy :: RLProxy list) (RProxy :: RProxy row)\n  zero = zeroRecord (RLProxy :: RLProxy list) (RProxy :: RProxy row)\n\nforeign import intAdd :: Int -> Int -> Int\nforeign import intMul :: Int -> Int -> Int\nforeign import numAdd :: Number -> Number -> Number\nforeign import numMul :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Semiring` instances, used to\n-- | implement the `Semiring` instance for records.\nclass SemiringRecord rowlist row subrow | rowlist -> subrow where\n  addRecord :: RLProxy rowlist -> Record row -> Record row -> Record subrow\n  mulRecord :: RLProxy rowlist -> Record row -> Record row -> Record subrow\n  oneRecord :: RLProxy rowlist -> RProxy row -> Record subrow\n  zeroRecord :: RLProxy rowlist -> RProxy row -> Record subrow\n\ninstance semiringRecordNil :: SemiringRecord RL.Nil row () where\n  addRecord  _ _ _ = {}\n  mulRecord  _ _ _ = {}\n  oneRecord  _ _ = {}\n  zeroRecord _ _ = {}\n\ninstance semiringRecordCons\n    :: ( IsSymbol key\n       , Row.Cons key focus subrowTail subrow\n       , SemiringRecord rowlistTail row subrowTail\n       , Semiring focus\n       )\n    => SemiringRecord (RL.Cons key focus rowlistTail) row subrow where\n  addRecord _ ra rb = insert (get ra + get rb) tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      tail = addRecord (RLProxy :: RLProxy rowlistTail) ra rb\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  mulRecord _ ra rb = insert (get ra * get rb) tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      tail = mulRecord (RLProxy :: RLProxy rowlistTail) ra rb\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  oneRecord _ _ = insert one tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      tail = oneRecord (RLProxy :: RLProxy rowlistTail) (RProxy :: RProxy row)\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n\n  zeroRecord _ _ = insert zero tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      tail = zeroRecord (RLProxy :: RLProxy rowlistTail) (RProxy :: RProxy row)\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n","\"use strict\";\n\nexports.intAdd = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x + y | 0;\n  };\n};\n\nexports.intMul = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x * y | 0;\n  };\n};\n\nexports.numAdd = function (n1) {\n  return function (n2) {\n    return n1 + n2;\n  };\n};\n\nexports.numMul = function (n1) {\n  return function (n2) {\n    return n1 * n2;\n  };\n};\n","module Data.Semigroup\n  ( class Semigroup, append, (<>)\n  , class SemigroupRecord, appendRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, SProxy(..), reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Data.Void (Void, absurd)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Data.RowList (RLProxy(..))\n\n-- | The `Semigroup` type class identifies an associative operation on a type.\n-- |\n-- | Instances are required to satisfy the following law:\n-- |\n-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`\n-- |\n-- | One example of a `Semigroup` is `String`, with `(<>)` defined as string\n-- | concatenation.\nclass Semigroup a where\n  append :: a -> a -> a\n\ninfixr 5 append as <>\n\ninstance semigroupString :: Semigroup String where\n  append = concatString\n\ninstance semigroupUnit :: Semigroup Unit where\n  append _ _ = unit\n\ninstance semigroupVoid :: Semigroup Void where\n  append _ = absurd\n\ninstance semigroupFn :: Semigroup s' => Semigroup (s -> s') where\n  append f g x = f x <> g x\n\ninstance semigroupArray :: Semigroup (Array a) where\n  append = concatArray\n\ninstance semigroupRecord :: (RL.RowToList row list, SemigroupRecord list row row) => Semigroup (Record row) where\n  append = appendRecord (RLProxy :: RLProxy list)\n\nforeign import concatString :: String -> String -> String\nforeign import concatArray :: forall a. Array a -> Array a -> Array a\n\n-- | A class for records where all fields have `Semigroup` instances, used to\n-- | implement the `Semigroup` instance for records.\nclass SemigroupRecord rowlist row subrow | rowlist -> subrow where\n  appendRecord :: RLProxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance semigroupRecordNil :: SemigroupRecord RL.Nil row () where\n  appendRecord _ _ _ = {}\n\ninstance semigroupRecordCons\n    :: ( IsSymbol key\n       , Row.Cons key focus subrowTail subrow\n       , SemigroupRecord rowlistTail row subrowTail\n       , Semigroup focus\n       )\n    => SemigroupRecord (RL.Cons key focus rowlistTail) row subrow where\n  appendRecord _ ra rb = insert (get ra <> get rb) tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      tail = appendRecord (RLProxy :: RLProxy rowlistTail) ra rb\n","\"use strict\";\n\nexports.concatString = function (s1) {\n  return function (s2) {\n    return s1 + s2;\n  };\n};\n\nexports.concatArray = function (xs) {\n  return function (ys) {\n    if (xs.length === 0) return ys;\n    if (ys.length === 0) return xs;\n    return xs.concat(ys);\n  };\n};\n","module Data.Semigroup.Traversable where\n\nimport Prelude\n\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Traversable (class Traversable)\n\n-- | `Traversable1` represents data structures with a minimum of one element that can be _traversed_,\n-- | accumulating results and effects in some `Applicative` functor.\n-- |\n-- | - `traverse1` runs an action for every element in a data structure,\n-- |   and accumulates the results.\n-- | - `sequence1` runs the actions _contained_ in a data structure,\n-- |   and accumulates the results.\n-- |\n-- | The `traverse1` and `sequence1` functions should be compatible in the\n-- | following sense:\n-- |\n-- | - `traverse1 f xs = sequence1 (f <$> xs)`\n-- | - `sequence1 = traverse1 identity`\n-- |\n-- | `Traversable1` instances should also be compatible with the corresponding\n-- | `Foldable1` instances, in the following sense:\n-- |\n-- | - `foldMap1 f = runConst <<< traverse1 (Const <<< f)`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `traverse1Default`\n-- | - `sequence1Default`\nclass (Foldable1 t, Traversable t) <= Traversable1 t where\n  traverse1 :: forall a b f. Apply f => (a -> f b) -> t a -> f (t b)\n  sequence1 :: forall b f. Apply f => t (f b) -> f (t b)\n\ninstance traversableDual :: Traversable1 Dual where\n  traverse1 f (Dual x) = Dual <$> f x\n  sequence1 = sequence1Default\n\ninstance traversableMultiplicative :: Traversable1 Multiplicative where\n  traverse1 f (Multiplicative x) = Multiplicative <$> f x\n  sequence1 = sequence1Default\n\n-- | A default implementation of `traverse1` using `sequence1`.\ntraverse1Default\n  :: forall t a b m\n   . Traversable1 t\n  => Apply m\n  => (a -> m b)\n  -> t a\n  -> m (t b)\ntraverse1Default f ta = sequence1 (f <$> ta)\n\n-- | A default implementation of `sequence1` using `traverse1`.\nsequence1Default\n  :: forall t a m\n   . Traversable1 t\n  => Apply m\n  => t (m a)\n  -> m (t a)\nsequence1Default = traverse1 identity\n","module Data.Semigroup.Last where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Ord (class Ord1)\n\n-- | Semigroup where `append` always takes the second option.\n-- |\n-- | ``` purescript\n-- | Last x <> Last y == Last y\n-- | ```\nnewtype Last a = Last a\n\nderive newtype instance eqLast :: Eq a => Eq (Last a)\nderive instance eq1Last :: Eq1 Last\n\nderive newtype instance ordLast :: Ord a => Ord (Last a)\nderive instance ord1Last :: Ord1 Last\n\nderive newtype instance boundedLast :: Bounded a => Bounded (Last a)\n\ninstance showLast :: Show a => Show (Last a) where\n  show (Last a) = \"(Last \" <> show a <> \")\"\n\nderive instance functorLast :: Functor Last\n\ninstance applyLast :: Apply Last where\n  apply (Last f) (Last x) = Last (f x)\n\ninstance applicativeLast :: Applicative Last where\n  pure = Last\n\ninstance bindLast :: Bind Last where\n  bind (Last x) f = f x\n\ninstance monadLast :: Monad Last\n\ninstance semigroupLast :: Semigroup (Last a) where\n  append _ x = x\n","module Data.Semigroup.Foldable\n  ( class Foldable1\n  , foldMap1\n  , fold1\n  , traverse1_\n  , for1_\n  , sequence1_\n  , foldMap1Default\n  , fold1Default\n  , intercalate\n  , intercalateMap\n  , maximum\n  , minimum\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable)\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (ala)\nimport Data.Ord.Max (Max(..))\nimport Data.Ord.Min (Min(..))\n\n-- | `Foldable1` represents data structures with a minimum of one element that can be _folded_.\n-- |\n-- | - `fold1` folds a structure using a `Semigroup` instance\n-- | - `foldMap1` folds a structure by accumulating values in a `Semigroup`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `fold1Default`\n-- | - `foldMap1Default`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable t <= Foldable1 t where\n  foldMap1 :: forall a m. Semigroup m => (a -> m) -> t a -> m\n  fold1 :: forall m. Semigroup m => t m -> m\n\n-- | A default implementation of `fold1` using `foldMap1`.\nfold1Default :: forall t m. Foldable1 t => Semigroup m => t m -> m\nfold1Default = foldMap1 identity\n\n-- | A default implementation of `foldMap1` using `fold1`.\nfoldMap1Default :: forall t m a. Foldable1 t => Functor t => Semigroup m => (a -> m) -> t a -> m\nfoldMap1Default f = (map f) >>> fold1\n\ninstance foldableDual :: Foldable1 Dual where\n  foldMap1 f (Dual x) = f x\n  fold1 = fold1Default\n\ninstance foldableMultiplicative :: Foldable1 Multiplicative where\n  foldMap1 f (Multiplicative x) = f x\n  fold1 = fold1Default\n\nnewtype Act f a = Act (f a)\n\ngetAct :: forall f a. Act f a -> f a\ngetAct (Act f) = f\n\ninstance semigroupAct :: Apply f => Semigroup (Act f a) where\n  append (Act a) (Act b) = Act (a *> b)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Apply` instance at each value, ignoring the final result.\ntraverse1_ :: forall t f a b. Foldable1 t => Apply f => (a -> f b) -> t a -> f Unit\ntraverse1_ f t = unit <$ getAct (foldMap1 (Act <<< f) t)\n\n-- | A version of `traverse1_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\nfor1_ :: forall t f a b. Foldable1 t => Apply f => t a -> (a -> f b) -> f Unit\nfor1_ = flip traverse1_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable1` instance, ignoring the final result.\nsequence1_ :: forall t f a. Foldable1 t => Apply f => t (f a) -> f Unit\nsequence1_ = traverse1_ identity\n\nmaximum :: forall f a. Ord a => Foldable1 f => f a -> a\nmaximum = ala Max foldMap1\n\nminimum :: forall f a. Ord a => Foldable1 f => f a -> a\nminimum = ala Min foldMap1\n\n-- | Internal. Used by intercalation functions.\nnewtype JoinWith a = JoinWith (a -> a)\n\njoinee :: forall a. JoinWith a -> a -> a\njoinee (JoinWith x) = x\n\ninstance semigroupJoinWith :: Semigroup a => Semigroup (JoinWith a) where\n  append (JoinWith a) (JoinWith b) = JoinWith $ \\j -> a j <> j <> b j\n\n-- | Fold a data structure using a `Semigroup` instance,\n-- | combining adjacent elements using the specified separator.\nintercalate :: forall f m. Foldable1 f => Semigroup m => m -> f m -> m\nintercalate = flip intercalateMap identity\n\n-- | Fold a data structure, accumulating values in some `Semigroup`,\n-- | combining adjacent elements using the specified separator.\nintercalateMap\n  :: forall f m a\n   . Foldable1 f\n  => Semigroup m\n  => m -> (a -> m) -> f a -> m\nintercalateMap j f foldable =\n  joinee (foldMap1 (JoinWith <<< const <<< f) foldable) j\n","module Data.Semigroup.First where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Ord (class Ord1)\n\n-- | Semigroup where `append` always takes the first option.\n-- |\n-- | ``` purescript\n-- | First x <> First y == First x\n-- | ```\nnewtype First a = First a\n\nderive newtype instance eqFirst :: Eq a => Eq (First a)\nderive instance eq1First :: Eq1 First\n\nderive newtype instance ordFirst :: Ord a => Ord (First a)\nderive instance ord1First :: Ord1 First\n\nderive newtype instance boundedFirst :: Bounded a => Bounded (First a)\n\ninstance showFirst :: Show a => Show (First a) where\n  show (First a) = \"(First \" <> show a <> \")\"\n\nderive instance functorFirst :: Functor First\n\ninstance applyFirst :: Apply First where\n  apply (First f) (First x) = First (f x)\n\ninstance applicativeFirst :: Applicative First where\n  pure = First\n\ninstance bindFirst :: Bind First where\n  bind (First x) f = f x\n\ninstance monadFirst :: Monad First\n\ninstance semigroupFirst :: Semigroup (First a) where\n  append x _ = x\n","module Data.Ring\n  ( class Ring, sub, negate, (-)\n  , module Data.Semiring\n  , class RingRecord, subRecord\n  ) where\n\nimport Data.Semiring (class Semiring, class SemiringRecord, add, mul, one, zero, (*), (+))\nimport Data.Symbol (class IsSymbol, SProxy(..), reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Data.RowList (RLProxy(..))\n\n-- | The `Ring` class is for types that support addition, multiplication,\n-- | and subtraction operations.\n-- |\n-- | Instances must satisfy the following law in addition to the `Semiring`\n-- | laws:\n-- |\n-- | - Additive inverse: `a - a = (zero - a) + a = zero`\nclass Semiring a <= Ring a where\n  sub :: a -> a -> a\n\ninfixl 6 sub as -\n\ninstance ringInt :: Ring Int where\n  sub = intSub\n\ninstance ringNumber :: Ring Number where\n  sub = numSub\n\ninstance ringUnit :: Ring Unit where\n  sub _ _ = unit\n\ninstance ringFn :: Ring b => Ring (a -> b) where\n  sub f g x = f x - g x\n\ninstance ringRecord :: (RL.RowToList row list, RingRecord list row row) => Ring (Record row) where\n  sub = subRecord (RLProxy :: RLProxy list)\n\n-- | `negate x` can be used as a shorthand for `zero - x`.\nnegate :: forall a. Ring a => a -> a\nnegate a = zero - a\n\nforeign import intSub :: Int -> Int -> Int\nforeign import numSub :: Number -> Number -> Number\n\n-- | A class for records where all fields have `Ring` instances, used to\n-- | implement the `Ring` instance for records.\nclass SemiringRecord rowlist row subrow <= RingRecord rowlist row subrow | rowlist -> subrow where\n  subRecord :: RLProxy rowlist -> Record row -> Record row -> Record subrow\n\ninstance ringRecordNil :: RingRecord RL.Nil row () where\n  subRecord _ _ _ = {}\n\ninstance ringRecordCons\n    :: ( IsSymbol key\n       , Row.Cons key focus subrowTail subrow\n       , RingRecord rowlistTail row subrowTail\n       , Ring focus\n       )\n    => RingRecord (RL.Cons key focus rowlistTail) row subrow where\n  subRecord _ ra rb = insert (get ra - get rb) tail\n    where\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      tail = subRecord (RLProxy :: RLProxy rowlistTail) ra rb\n","\"use strict\";\n\nexports.intSub = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x - y | 0;\n  };\n};\n\nexports.numSub = function (n1) {\n  return function (n2) {\n    return n1 - n2;\n  };\n};\n","module Data.Ordering (Ordering(..), invert) where\n\nimport Data.Eq (class Eq)\nimport Data.Semigroup (class Semigroup)\nimport Data.Show (class Show)\n\n-- | The `Ordering` data type represents the three possible outcomes of\n-- | comparing two values:\n-- |\n-- | `LT` - The first value is _less than_ the second.\n-- | `GT` - The first value is _greater than_ the second.\n-- | `EQ` - The first value is _equal to_ the second.\ndata Ordering = LT | GT | EQ\n\ninstance eqOrdering :: Eq Ordering where\n  eq LT LT = true\n  eq GT GT = true\n  eq EQ EQ = true\n  eq _  _  = false\n\ninstance semigroupOrdering :: Semigroup Ordering where\n  append LT _ = LT\n  append GT _ = GT\n  append EQ y = y\n\ninstance showOrdering :: Show Ordering where\n  show LT = \"LT\"\n  show GT = \"GT\"\n  show EQ = \"EQ\"\n\n-- | Reverses an `Ordering` value, flipping greater than for less than while\n-- | preserving equality.\ninvert :: Ordering -> Ordering\ninvert GT = LT\ninvert EQ = EQ\ninvert LT = GT\n","module Data.Ord\n  ( class Ord, compare\n  , class Ord1, compare1\n  , lessThan, (<)\n  , lessThanOrEq, (<=)\n  , greaterThan, (>)\n  , greaterThanOrEq, (>=)\n  , comparing\n  , min, max\n  , clamp\n  , between\n  , abs\n  , signum\n  , module Data.Ordering\n  , class OrdRecord, compareRecord\n  ) where\n\nimport Data.Eq (class Eq, class Eq1, class EqRecord, (/=))\nimport Data.Symbol (class IsSymbol, SProxy(..), reflectSymbol)\nimport Data.Ordering (Ordering(..))\nimport Data.Ring (class Ring, zero, one, negate)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Data.RowList (RLProxy(..))\n\n-- | The `Ord` type class represents types which support comparisons with a\n-- | _total order_.\n-- |\n-- | `Ord` instances should satisfy the laws of total orderings:\n-- |\n-- | - Reflexivity: `a <= a`\n-- | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`\n-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`\nclass Eq a <= Ord a where\n  compare :: a -> a -> Ordering\n\ninstance ordBoolean :: Ord Boolean where\n  compare = ordBooleanImpl LT EQ GT\n\ninstance ordInt :: Ord Int where\n  compare = ordIntImpl LT EQ GT\n\ninstance ordNumber :: Ord Number where\n  compare = ordNumberImpl LT EQ GT\n\ninstance ordString :: Ord String where\n  compare = ordStringImpl LT EQ GT\n\ninstance ordChar :: Ord Char where\n  compare = ordCharImpl LT EQ GT\n\ninstance ordUnit :: Ord Unit where\n  compare _ _ = EQ\n\ninstance ordVoid :: Ord Void where\n  compare _ _ = EQ\n\ninstance ordArray :: Ord a => Ord (Array a) where\n  compare = \\xs ys -> compare 0 (ordArrayImpl toDelta xs ys)\n    where\n    toDelta x y =\n      case compare x y of\n        EQ -> 0\n        LT -> 1\n        GT -> -1\n\nforeign import ordBooleanImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Boolean\n  -> Boolean\n  -> Ordering\n\nforeign import ordIntImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Int\n  -> Int\n  -> Ordering\n\nforeign import ordNumberImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Number\n  -> Number\n  -> Ordering\n\nforeign import ordStringImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> String\n  -> String\n  -> Ordering\n\nforeign import ordCharImpl\n  :: Ordering\n  -> Ordering\n  -> Ordering\n  -> Char\n  -> Char\n  -> Ordering\n\nforeign import ordArrayImpl :: forall a. (a -> a -> Int) -> Array a -> Array a -> Int\n\ninstance ordOrdering :: Ord Ordering where\n  compare LT LT = EQ\n  compare EQ EQ = EQ\n  compare GT GT = EQ\n  compare LT _  = LT\n  compare EQ LT = GT\n  compare EQ GT = LT\n  compare GT _  = GT\n\n-- | Test whether one value is _strictly less than_ another.\nlessThan :: forall a. Ord a => a -> a -> Boolean\nlessThan a1 a2 = case a1 `compare` a2 of\n  LT -> true\n  _ -> false\n\n-- | Test whether one value is _strictly greater than_ another.\ngreaterThan :: forall a. Ord a => a -> a -> Boolean\ngreaterThan a1 a2 = case a1 `compare` a2 of\n  GT -> true\n  _ -> false\n\n-- | Test whether one value is _non-strictly less than_ another.\nlessThanOrEq :: forall a. Ord a => a -> a -> Boolean\nlessThanOrEq a1 a2 = case a1 `compare` a2 of\n  GT -> false\n  _ -> true\n\n-- | Test whether one value is _non-strictly greater than_ another.\ngreaterThanOrEq :: forall a. Ord a => a -> a -> Boolean\ngreaterThanOrEq a1 a2 = case a1 `compare` a2 of\n  LT -> false\n  _ -> true\n\ninfixl 4 lessThan as <\ninfixl 4 lessThanOrEq as <=\ninfixl 4 greaterThan as >\ninfixl 4 greaterThanOrEq as >=\n\n-- | Compares two values by mapping them to a type with an `Ord` instance.\ncomparing :: forall a b. Ord b => (a -> b) -> (a -> a -> Ordering)\ncomparing f x y = compare (f x) (f y)\n\n-- | Take the minimum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmin :: forall a. Ord a => a -> a -> a\nmin x y =\n  case compare x y of\n    LT -> x\n    EQ -> x\n    GT -> y\n\n-- | Take the maximum of two values. If they are considered equal, the first\n-- | argument is chosen.\nmax :: forall a. Ord a => a -> a -> a\nmax x y =\n  case compare x y of\n    LT -> y\n    EQ -> x\n    GT -> x\n\n-- | Clamp a value between a minimum and a maximum. For example:\n-- |\n-- | ``` purescript\n-- | let f = clamp 0 10\n-- | f (-5) == 0\n-- | f 5    == 5\n-- | f 15   == 10\n-- | ```\nclamp :: forall a. Ord a => a -> a -> a -> a\nclamp low hi x = min hi (max low x)\n\n-- | Test whether a value is between a minimum and a maximum (inclusive).\n-- | For example:\n-- |\n-- | ``` purescript\n-- | let f = between 0 10\n-- | f 0    == true\n-- | f (-5) == false\n-- | f 5    == true\n-- | f 10   == true\n-- | f 15   == false\n-- | ```\nbetween :: forall a. Ord a => a -> a -> a -> Boolean\nbetween low hi x\n  | x < low = false\n  | x > hi = false\n  | true = true\n\n-- | The absolute value function. `abs x` is defined as `if x >= zero then x\n-- | else negate x`.\nabs :: forall a. Ord a => Ring a => a -> a\nabs x = if x >= zero then x else negate x\n\n-- | The sign function; always evaluates to either `one` or `negate one`. For\n-- | any `x`, we should have `signum x * abs x == x`.\nsignum :: forall a. Ord a => Ring a => a -> a\nsignum x = if x >= zero then one else negate one\n\n-- | The `Ord1` type class represents totally ordered type constructors.\nclass Eq1 f <= Ord1 f where\n  compare1 :: forall a. Ord a => f a -> f a -> Ordering\n\ninstance ord1Array :: Ord1 Array where\n  compare1 = compare\n\nclass EqRecord rowlist row <= OrdRecord rowlist row where\n  compareRecord :: RLProxy rowlist -> Record row -> Record row -> Ordering\n\ninstance ordRecordNil :: OrdRecord RL.Nil row where\n  compareRecord _ _ _ = EQ\n\ninstance ordRecordCons\n    :: ( OrdRecord rowlistTail row\n       , Row.Cons key focus rowTail row\n       , IsSymbol key\n       , Ord focus\n       )\n    => OrdRecord (RL.Cons key focus rowlistTail) row where\n  compareRecord _ ra rb\n    = if left /= EQ\n        then left\n        else compareRecord (RLProxy :: RLProxy rowlistTail) ra rb\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      unsafeGet' = unsafeGet :: String -> Record row -> focus\n      left = unsafeGet' key ra `compare` unsafeGet' key rb\n\ninstance ordRecord\n    :: ( RL.RowToList row list\n       , OrdRecord list row\n       )\n    => Ord (Record row) where\n  compare = compareRecord (RLProxy :: RLProxy list)\n\n","\"use strict\";\n\nvar unsafeCompareImpl = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (x) {\n        return function (y) {\n          return x < y ? lt : x === y ? eq : gt;\n        };\n      };\n    };\n  };\n};\n\nexports.ordBooleanImpl = unsafeCompareImpl;\nexports.ordIntImpl = unsafeCompareImpl;\nexports.ordNumberImpl = unsafeCompareImpl;\nexports.ordStringImpl = unsafeCompareImpl;\nexports.ordCharImpl = unsafeCompareImpl;\n\nexports.ordArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var i = 0;\n      var xlen = xs.length;\n      var ylen = ys.length;\n      while (i < xlen && i < ylen) {\n        var x = xs[i];\n        var y = ys[i];\n        var o = f(x)(y);\n        if (o !== 0) {\n          return o;\n        }\n        i++;\n      }\n      if (xlen === ylen) {\n        return 0;\n      } else if (xlen > ylen) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n  };\n};\n","module Data.Ord.Min where\n\nimport Prelude\n\nimport Data.Newtype (class Newtype)\n\n-- | Provides a `Semigroup` based on the `min` function. If the type has a\n-- | `Bounded` instance, then a `Monoid` instance is provided too. For example:\n-- |\n-- |     unwrap (Min 5 <> Min 6) = 5\n-- |     mempty :: Min Ordering = Min GT\n-- |\nnewtype Min a = Min a\n\nderive instance newtypeMin :: Newtype (Min a) _\n\nderive newtype instance eqMin :: Eq a => Eq (Min a)\n\ninstance ordMin :: Ord a => Ord (Min a) where\n  compare (Min x) (Min y) = compare x y\n\ninstance semigroupMin :: Ord a => Semigroup (Min a) where\n  append (Min x) (Min y) = Min (min x y)\n\ninstance monoidMin :: Bounded a => Monoid (Min a) where\n  mempty = Min top\n\ninstance showMin :: Show a => Show (Min a) where\n  show (Min a) = \"(Min \" <> show a <> \")\"\n","module Data.Ord.Max where\n\nimport Prelude\n\nimport Data.Newtype (class Newtype)\n\n-- | Provides a `Semigroup` based on the `max` function. If the type has a\n-- | `Bounded` instance, then a `Monoid` instance is provided too. For example:\n-- |\n-- |     unwrap (Max 5 <> Max 6) = 6\n-- |     mempty :: Max Ordering = Max LT\n-- |\nnewtype Max a = Max a\n\nderive instance newtypeMax :: Newtype (Max a) _\n\nderive newtype instance eqMax :: Eq a => Eq (Max a)\n\ninstance ordMax :: Ord a => Ord (Max a) where\n  compare (Max x) (Max y) = compare x y\n\ninstance semigroupMax :: Ord a => Semigroup (Max a) where\n  append (Max x) (Max y) = Max (max x y)\n\ninstance monoidMax :: Bounded a => Monoid (Max a) where\n  mempty = Max bottom\n\ninstance showMax :: Show a => Show (Max a) where\n  show (Max a) = \"(Max \" <> show a <> \")\"\n","module Data.Newtype where\n\nimport Prelude\n\nimport Data.Function (on)\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Semigroup.First (First(..))\nimport Data.Semigroup.Last (Last(..))\n\n-- | A type class for `newtype`s to enable convenient wrapping and unwrapping,\n-- | and the use of the other functions in this module.\n-- |\n-- | The compiler can derive instances of `Newtype` automatically:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- |\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- | ```\n-- |\n-- | Note that deriving for `Newtype` instances requires that the type be\n-- | defined as `newtype` rather than `data` declaration (even if the `data`\n-- | structurally fits the rules of a `newtype`), and the use of a wildcard for\n-- | the wrapped type.\n-- |\n-- | Instances must obey the following laws:\n-- | ``` purescript\n-- | unwrap <<< wrap = id\n-- | wrap <<< unwrap = id\n-- | ```\nclass Newtype t a | t -> a where\n  wrap :: a -> t\n  unwrap :: t -> a\n\ninstance newtypeAdditive :: Newtype (Additive a) a where\n  wrap = Additive\n  unwrap (Additive a) = a\n\ninstance newtypeMultiplicative :: Newtype (Multiplicative a) a where\n  wrap = Multiplicative\n  unwrap (Multiplicative a) = a\n\ninstance newtypeConj :: Newtype (Conj a) a where\n  wrap = Conj\n  unwrap (Conj a) = a\n\ninstance newtypeDisj :: Newtype (Disj a) a where\n  wrap = Disj\n  unwrap (Disj a) = a\n\ninstance newtypeDual :: Newtype (Dual a) a where\n  wrap = Dual\n  unwrap (Dual a) = a\n\ninstance newtypeEndo :: Newtype (Endo c a) (c a a) where\n  wrap = Endo\n  unwrap (Endo a) = a\n\ninstance newtypeFirst :: Newtype (First a) a where\n  wrap = First\n  unwrap (First a) = a\n\ninstance newtypeLast :: Newtype (Last a) a where\n  wrap = Last\n  unwrap (Last a) = a\n\n-- | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`\n-- | function.\nun :: forall t a. Newtype t a => (a -> t) -> t -> a\nun _ = unwrap\n\n-- | Deprecated previous name of `un`.\nop :: forall t a. Newtype t a => (a -> t) -> t -> a\nop = un\n\n-- | This combinator is for when you have a higher order function that you want\n-- | to use in the context of some newtype - `foldMap` being a common example:\n-- |\n-- | ``` purescript\n-- | ala Additive foldMap [1,2,3,4] -- 10\n-- | ala Multiplicative foldMap [1,2,3,4] -- 24\n-- | ala Conj foldMap [true, false] -- false\n-- | ala Disj foldMap [true, false] -- true\n-- | ```\nala\n  :: forall f t a s b\n   . Functor f\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> ((b -> s) -> f t)\n  -> f a\nala _ f = map unwrap (f wrap)\n\n-- | Similar to `ala` but useful for cases where you want to use an additional\n-- | projection with the higher order function:\n-- |\n-- | ``` purescript\n-- | alaF Additive foldMap String.length [\"hello\", \"world\"] -- 10\n-- | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0\n-- | ```\n-- |\n-- | The type admits other possibilities due to the polymorphic `Functor`\n-- | constraints, but the case described above works because ((->) a) is a\n-- | `Functor`.\nalaF\n  :: forall f g t a s b\n   . Functor f\n  => Functor g\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nalaF _ f = map unwrap <<< f <<< map wrap\n\n-- | Lifts a function operate over newtypes. This can be used to lift a\n-- | function to manipulate the contents of a single newtype, somewhat like\n-- | `map` does for a `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype Label = Label String\n-- | derive instance newtypeLabel :: Newtype Label _\n-- |\n-- | toUpperLabel :: Label -> Label\n-- | toUpperLabel = over Label String.toUpper\n-- | ```\n-- |\n-- | But the result newtype is polymorphic, meaning the result can be returned\n-- | as an alternative newtype:\n-- |\n-- | ``` purescript\n-- | newtype UppercaseLabel = UppercaseLabel String\n-- | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _\n-- |\n-- | toUpperLabel' :: Label -> UppercaseLabel\n-- | toUpperLabel' = over Label String.toUpper\n-- | ```\nover\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> b)\n  -> t\n  -> s\nover _ f = wrap <<< f <<< unwrap\n\n-- | Much like `over`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | findLabel :: String -> Array Label -> Maybe Label\n-- | findLabel s = overF Label (Foldable.find (_ == s))\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\noverF\n  :: forall f g t a s b\n   . Functor f\n  => Functor g\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> g b)\n  -> f t\n  -> g s\noverF _ f = map wrap <<< f <<< map unwrap\n\n-- | The opposite of `over`: lowers a function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\n-- |\n-- | ``` purescript\n-- | newtype Degrees = Degrees Number\n-- | derive instance newtypeDegrees :: Newtype Degrees _\n-- |\n-- | newtype NormalDegrees = NormalDegrees Number\n-- | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _\n-- |\n-- | normaliseDegrees :: Degrees -> NormalDegrees\n-- | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)\n-- |\n-- | asNormalDegrees :: Number -> Number\n-- | asNormalDegrees = under Degrees normaliseDegrees\n-- | ```\n-- |\n-- | As with `over` the `Newtype` is polymorphic, as illustrated in the example\n-- | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,\n-- | so even though `normaliseDegrees` changes the result type we can still put\n-- | a `Number` in and get a `Number` out via `under`.\nunder\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> s)\n  -> a\n  -> b\nunder _ f = unwrap <<< f <<< wrap\n\n-- | Much like `under`, but where the lifted function operates on values in a\n-- | `Functor`:\n-- |\n-- | ``` purescript\n-- | newtype EmailAddress = EmailAddress String\n-- | derive instance newtypeEmailAddress :: Newtype EmailAddress _\n-- |\n-- | isValid :: EmailAddress -> Boolean\n-- | isValid x = false -- imagine a slightly less strict predicate here\n-- |\n-- | findValidEmailString :: Array String -> Maybe String\n-- | findValidEmailString = underF EmailAddress (Foldable.find isValid)\n-- | ```\n-- |\n-- | The above example also demonstrates that the functor type is polymorphic\n-- | here too, the input is an `Array` but the result is a `Maybe`.\nunderF\n  :: forall f g t a s b\n   . Functor f\n  => Functor g\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> g s)\n  -> f a\n  -> g b\nunderF _ f = map unwrap <<< f <<< map wrap\n\n-- | Lifts a binary function to operate over newtypes.\n-- |\n-- | ``` purescript\n-- | newtype Meter = Meter Int\n-- | derive newtype instance newtypeMeter :: Newtype Meter _\n-- | newtype SquareMeter = SquareMeter Int\n-- | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _\n-- |\n-- | area :: Meter -> Meter -> SquareMeter\n-- | area = over2 Meter (*)\n-- | ```\n-- |\n-- | The above example also demonstrates that the return type is polymorphic\n-- | here too.\nover2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (a -> a -> b)\n  -> t\n  -> t\n  -> s\nover2 _ f = compose wrap <<< f `on` unwrap\n\n-- | Much like `over2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\noverF2\n  :: forall f g t a s b\n   . Functor f\n  => Functor g\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f a -> f a -> g b)\n  -> f t\n  -> f t\n  -> g s\noverF2 _ f = compose (map wrap) <<< f `on` map unwrap\n\n-- | The opposite of `over2`: lowers a binary function that operates on `Newtype`d\n-- | values to operate on the wrapped value instead.\nunder2\n  :: forall t a s b\n   . Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (t -> t -> s)\n  -> a\n  -> a\n  -> b\nunder2 _ f = compose unwrap <<< f `on` wrap\n\n-- | Much like `under2`, but where the lifted binary function operates on\n-- | values in a `Functor`.\nunderF2\n  :: forall f g t a s b\n   . Functor f\n  => Functor g\n  => Newtype t a\n  => Newtype s b\n  => (a -> t)\n  -> (f t -> f t -> g s)\n  -> f a\n  -> f a\n  -> g b\nunderF2 _ f = compose (map unwrap) <<< f `on` map wrap\n\n-- | Similar to the function from the `Traversable` class, but operating within\n-- | a newtype instead.\ntraverse\n  :: forall f t a\n   . Functor f\n  => Newtype t a\n  => (a -> t)\n  -> (a -> f a)\n  -> t\n  -> f t\ntraverse _ f = map wrap <<< f <<< unwrap\n\n-- | Similar to the function from the `Distributive` class, but operating within\n-- | a newtype instead.\ncollect\n  :: forall f t a\n   . Functor f\n  => Newtype t a\n  => (a -> t)\n  -> (f a -> a)\n  -> f t\n  -> t\ncollect _ f = wrap <<< f <<< map unwrap\n","module Data.Monoid\n  ( class Monoid, mempty\n  , power\n  , guard\n  , module Data.Semigroup\n  , class MonoidRecord, memptyRecord\n  ) where\n\nimport Data.Boolean (otherwise)\nimport Data.Eq ((==))\nimport Data.EuclideanRing (mod, (/))\nimport Data.Ord ((<=))\nimport Data.Ordering (Ordering(..))\nimport Data.Semigroup (class Semigroup, class SemigroupRecord, (<>))\nimport Data.Symbol (class IsSymbol, SProxy(..), reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeSet)\nimport Type.Data.RowList (RLProxy(..))\n\n-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a\n-- | left and right unit for the associative operation `<>`:\n-- |\n-- | - Left unit: `(mempty <> x) = x`\n-- | - Right unit: `(x <> mempty) = x`\n-- |\n-- | `Monoid`s are commonly used as the result of fold operations, where\n-- | `<>` is used to combine individual results, and `mempty` gives the result\n-- | of folding an empty collection of elements.\nclass Semigroup m <= Monoid m where\n  mempty :: m\n\ninstance monoidUnit :: Monoid Unit where\n  mempty = unit\n\ninstance monoidOrdering :: Monoid Ordering where\n  mempty = EQ\n\ninstance monoidFn :: Monoid b => Monoid (a -> b) where\n  mempty _ = mempty\n\ninstance monoidString :: Monoid String where\n  mempty = \"\"\n\ninstance monoidArray :: Monoid (Array a) where\n  mempty = []\n\ninstance monoidRecord :: (RL.RowToList row list, MonoidRecord list row row) => Monoid (Record row) where\n  mempty = memptyRecord (RLProxy :: RLProxy list)\n\n-- | Append a value to itself a certain number of times. For the\n-- | `Multiplicative` type, and for a non-negative power, this is the same as\n-- | normal number exponentiation.\n-- |\n-- | If the second argument is negative this function will return `mempty`\n-- | (*unlike* normal number exponentiation). The `Monoid` constraint alone\n-- | is not enough to write a `power` function with the property that `power x\n-- | n` cancels with `power x (-n)`, i.e. `power x n <> power x (-n) = mempty`.\n-- | For that, we would additionally need the ability to invert elements, i.e.\n-- | a Group.\npower :: forall m. Monoid m => m -> Int -> m\npower x = go\n  where\n  go :: Int -> m\n  go p\n    | p <= 0 = mempty\n    | p == 1 = x\n    | p `mod` 2 == 0 = let x' = go (p / 2) in x' <> x'\n    | otherwise = let x' = go (p / 2) in x' <> x' <> x\n\n-- | Allow or \"truncate\" a Monoid to its `mempty` value based on a condition.\nguard :: forall m. Monoid m => Boolean -> m -> m\nguard true a = a\nguard false _ = mempty\n\n-- | A class for records where all fields have `Monoid` instances, used to\n-- | implement the `Monoid` instance for records.\nclass SemigroupRecord rowlist row subrow <= MonoidRecord rowlist row subrow | rowlist -> row subrow where\n  memptyRecord :: RLProxy rowlist -> Record subrow\n\ninstance monoidRecordNil :: MonoidRecord RL.Nil row () where\n  memptyRecord _ = {}\n\ninstance monoidRecordCons\n    :: ( IsSymbol key\n       , Monoid focus\n       , Row.Cons key focus subrowTail subrow\n       , MonoidRecord rowlistTail row subrowTail\n       )\n    => MonoidRecord (RL.Cons key focus rowlistTail) row subrow where\n  memptyRecord _\n    = insert mempty tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      tail = memptyRecord (RLProxy :: RLProxy rowlistTail)\n","module Data.Monoid.Multiplicative where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup for semirings under multiplication.\n-- |\n-- | ``` purescript\n-- | Multiplicative x <> Multiplicative y == Multiplicative (x * y)\n-- | (mempty :: Multiplicative _) == Multiplicative one\n-- | ```\nnewtype Multiplicative a = Multiplicative a\n\nderive newtype instance eqMultiplicative :: Eq a => Eq (Multiplicative a)\nderive instance eq1Multiplicative :: Eq1 Multiplicative\n\nderive newtype instance ordMultiplicative :: Ord a => Ord (Multiplicative a)\nderive instance ord1Multiplicative :: Ord1 Multiplicative\n\nderive newtype instance boundedMultiplicative :: Bounded a => Bounded (Multiplicative a)\n\ninstance showMultiplicative :: Show a => Show (Multiplicative a) where\n  show (Multiplicative a) = \"(Multiplicative \" <> show a <> \")\"\n\nderive instance functorMultiplicative :: Functor Multiplicative\n\ninstance applyMultiplicative :: Apply Multiplicative where\n  apply (Multiplicative f) (Multiplicative x) = Multiplicative (f x)\n\ninstance applicativeMultiplicative :: Applicative Multiplicative where\n  pure = Multiplicative\n\ninstance bindMultiplicative :: Bind Multiplicative where\n  bind (Multiplicative x) f = f x\n\ninstance monadMultiplicative :: Monad Multiplicative\n\ninstance semigroupMultiplicative :: Semiring a => Semigroup (Multiplicative a) where\n  append (Multiplicative a) (Multiplicative b) = Multiplicative (a * b)\n\ninstance monoidMultiplicative :: Semiring a => Monoid (Multiplicative a) where\n  mempty = Multiplicative one\n","module Data.Monoid.Endo where\n\nimport Prelude\n\n-- | Monoid and semigroup for category endomorphisms.\n-- |\n-- | When `c` is instantiated with `->` this composes functions of type\n-- | `a -> a`:\n-- |\n-- | ``` purescript\n-- | Endo f <> Endo g == Endo (f <<< g)\n-- | (mempty :: Endo _) == Endo identity\n-- | ```\nnewtype Endo c a = Endo (c a a)\n\nderive newtype instance eqEndo :: Eq (c a a) => Eq (Endo c a)\n\nderive newtype instance ordEndo :: Ord (c a a) => Ord (Endo c a)\n\nderive newtype instance boundedEndo :: Bounded (c a a) => Bounded (Endo c a)\n\ninstance showEndo :: Show (c a a) => Show (Endo c a) where\n  show (Endo x) = \"(Endo \" <> show x <> \")\"\n\ninstance semigroupEndo :: Semigroupoid c => Semigroup (Endo c a) where\n  append (Endo a) (Endo b) = Endo (a <<< b)\n\ninstance monoidEndo :: Category c => Monoid (Endo c a) where\n  mempty = Endo identity\n","module Data.Monoid.Dual where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Ord (class Ord1)\n\n-- | The dual of a monoid.\n-- |\n-- | ``` purescript\n-- | Dual x <> Dual y == Dual (y <> x)\n-- | (mempty :: Dual _) == Dual mempty\n-- | ```\nnewtype Dual a = Dual a\n\nderive newtype instance eqDual :: Eq a => Eq (Dual a)\nderive instance eq1Dual :: Eq1 Dual\n\nderive newtype instance ordDual :: Ord a => Ord (Dual a)\nderive instance ord1Dual :: Ord1 Dual\n\nderive newtype instance boundedDual :: Bounded a => Bounded (Dual a)\n\ninstance showDual :: Show a => Show (Dual a) where\n  show (Dual a) = \"(Dual \" <> show a <> \")\"\n\nderive instance functorDual :: Functor Dual\n\ninstance applyDual :: Apply Dual where\n  apply (Dual f) (Dual x) = Dual (f x)\n\ninstance applicativeDual :: Applicative Dual where\n  pure = Dual\n\ninstance bindDual :: Bind Dual where\n  bind (Dual x) f = f x\n\ninstance monadDual :: Monad Dual\n\ninstance semigroupDual :: Semigroup a => Semigroup (Dual a) where\n  append (Dual x) (Dual y) = Dual (y <> x)\n\ninstance monoidDual :: Monoid a => Monoid (Dual a) where\n  mempty = Dual mempty\n","module Data.Monoid.Disj where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.HeytingAlgebra (ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup for disjunction.\n-- |\n-- | ``` purescript\n-- | Disj x <> Disj y == Disj (x || y)\n-- | (mempty :: Disj _) == Disj bottom\n-- | ```\nnewtype Disj a = Disj a\n\nderive newtype instance eqDisj :: Eq a => Eq (Disj a)\nderive instance eq1Disj :: Eq1 Disj\n\nderive newtype instance ordDisj :: Ord a => Ord (Disj a)\nderive instance ord1Disj :: Ord1 Disj\n\nderive newtype instance boundedDisj :: Bounded a => Bounded (Disj a)\n\ninstance showDisj :: Show a => Show (Disj a) where\n  show (Disj a) = \"(Disj \" <> show a <> \")\"\n\nderive instance functorDisj :: Functor Disj\n\ninstance applyDisj :: Apply Disj where\n  apply (Disj f) (Disj x) = Disj (f x)\n\ninstance applicativeDisj :: Applicative Disj where\n  pure = Disj\n\ninstance bindDisj :: Bind Disj where\n  bind (Disj x) f = f x\n\ninstance monadDisj :: Monad Disj\n\ninstance semigroupDisj :: HeytingAlgebra a => Semigroup (Disj a) where\n  append (Disj a) (Disj b) = Disj (disj a b)\n\ninstance monoidDisj :: HeytingAlgebra a => Monoid (Disj a) where\n  mempty = Disj ff\n\ninstance semiringDisj :: HeytingAlgebra a => Semiring (Disj a) where\n  zero = Disj ff\n  one = Disj tt\n  add (Disj a) (Disj b) = Disj (disj a b)\n  mul (Disj a) (Disj b) = Disj (conj a b)\n","module Data.Monoid.Conj where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.HeytingAlgebra (ff, tt)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup for conjunction.\n-- |\n-- | ``` purescript\n-- | Conj x <> Conj y == Conj (x && y)\n-- | (mempty :: Conj _) == Conj tt\n-- | ```\nnewtype Conj a = Conj a\n\nderive newtype instance eqConj :: Eq a => Eq (Conj a)\nderive instance eq1Conj :: Eq1 Conj\n\nderive newtype instance ordConj :: Ord a => Ord (Conj a)\nderive instance ord1Conj :: Ord1 Conj\n\nderive newtype instance boundedConj :: Bounded a => Bounded (Conj a)\n\ninstance showConj :: (Show a) => Show (Conj a) where\n  show (Conj a) = \"(Conj \" <> show a <> \")\"\n\nderive instance functorConj :: Functor Conj\n\ninstance applyConj :: Apply Conj where\n  apply (Conj f) (Conj x) = Conj (f x)\n\ninstance applicativeConj :: Applicative Conj where\n  pure = Conj\n\ninstance bindConj :: Bind Conj where\n  bind (Conj x) f = f x\n\ninstance monadConj :: Monad Conj\n\ninstance semigroupConj :: HeytingAlgebra a => Semigroup (Conj a) where\n  append (Conj a) (Conj b) = Conj (conj a b)\n\ninstance monoidConj :: HeytingAlgebra a => Monoid (Conj a) where\n  mempty = Conj tt\n\ninstance semiringConj :: HeytingAlgebra a => Semiring (Conj a) where\n  zero = Conj tt\n  one = Conj ff\n  add (Conj a) (Conj b) = Conj (conj a b)\n  mul (Conj a) (Conj b) = Conj (disj a b)\n","module Data.Monoid.Additive where\n\nimport Prelude\n\nimport Data.Eq (class Eq1)\nimport Data.Ord (class Ord1)\n\n-- | Monoid and semigroup for semirings under addition.\n-- |\n-- | ``` purescript\n-- | Additive x <> Additive y == Additive (x + y)\n-- | (mempty :: Additive _) == Additive zero\n-- | ```\nnewtype Additive a = Additive a\n\nderive newtype instance eqAdditive :: Eq a => Eq (Additive a)\nderive instance eq1Additive :: Eq1 Additive\n\nderive newtype instance ordAdditive :: Ord a => Ord (Additive a)\nderive instance ord1Additive :: Ord1 Additive\n\nderive newtype instance boundedAdditive :: Bounded a => Bounded (Additive a)\n\ninstance showAdditive :: Show a => Show (Additive a) where\n  show (Additive a) = \"(Additive \" <> show a <> \")\"\n\nderive instance functorAdditive :: Functor Additive\n\ninstance applyAdditive :: Apply Additive where\n  apply (Additive f) (Additive x) = Additive (f x)\n\ninstance applicativeAdditive :: Applicative Additive where\n  pure = Additive\n\ninstance bindAdditive :: Bind Additive where\n  bind (Additive x) f = f x\n\ninstance monadAdditive :: Monad Additive\n\ninstance semigroupAdditive :: Semiring a => Semigroup (Additive a) where\n  append (Additive a) (Additive b) = Additive (a + b)\n\ninstance monoidAdditive :: Semiring a => Monoid (Additive a) where\n  mempty = Additive zero\n","module Data.Maybe where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Extend (class Extend)\nimport Control.MonadZero (class MonadZero)\nimport Control.Plus (class Plus)\n\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.Ord (class Ord1)\n\n-- | The `Maybe` type is used to represent optional values and can be seen as\n-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`\n-- | is the non-null value `x`.\ndata Maybe a = Nothing | Just a\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Just` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing == Nothing\n-- | ```\ninstance functorMaybe :: Functor Maybe where\n  map fn (Just x) = Just (fn x)\n  map _  _        = Nothing\n\n-- | The `Apply` instance allows functions contained within a `Just` to\n-- | transform a value contained within a `Just` using the `apply` operator:\n-- |\n-- | ``` purescript\n-- | Just f <*> Just x == Just (f x)\n-- | ```\n-- |\n-- | `Nothing` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Just f <*> Nothing == Nothing\n-- | Nothing <*> Just x == Nothing\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a\n-- | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Maybe a -> Maybe b -> Maybe c`:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> Just y == Just (f x y)\n-- | ```\n-- |\n-- | The `Nothing`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Nothing`\n-- | means the whole result becomes `Nothing` also:\n-- |\n-- | ``` purescript\n-- | f <$> Nothing <*> Just y == Nothing\n-- | f <$> Just x <*> Nothing == Nothing\n-- | f <$> Nothing <*> Nothing == Nothing\n-- | ```\ninstance applyMaybe :: Apply Maybe where\n  apply (Just fn) x = fn <$> x\n  apply Nothing   _ = Nothing\n\n-- | The `Applicative` instance enables lifting of values into `Maybe` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Maybe _ == Just x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Maybe` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Just x <*> pure y == Just (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Just` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Just` with a new constructor.\ninstance applicativeMaybe :: Applicative Maybe where\n  pure = Just\n\n-- | The `Alt` instance allows for a choice to be made between two `Maybe`\n-- | values with the `<|>` operator, where the first `Just` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Just x <|> Just y == Just x\n-- | Nothing <|> Just y == Just y\n-- | Nothing <|> Nothing == Nothing\n-- | ```\ninstance altMaybe :: Alt Maybe where\n  alt Nothing r = r\n  alt l       _ = l\n\n-- | The `Plus` instance provides a default `Maybe` value:\n-- |\n-- | ``` purescript\n-- | empty :: Maybe _ == Nothing\n-- | ```\ninstance plusMaybe :: Plus Maybe where\n  empty = Nothing\n\n-- | The `Alternative` instance guarantees that there are both `Applicative` and\n-- | `Plus` instances for `Maybe`.\ninstance alternativeMaybe :: Alternative Maybe\n\n-- | The `Bind` instance allows sequencing of `Maybe` values and functions that\n-- | return a `Maybe` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Just x >>= f = f x\n-- | Nothing >>= f = Nothing\n-- | ```\ninstance bindMaybe :: Bind Maybe where\n  bind (Just x) k = k x\n  bind Nothing  _ = Nothing\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\ninstance monadMaybe :: Monad Maybe\n\ninstance monadZeroMaybe :: MonadZero Maybe\n\n-- | The `Extend` instance allows sequencing of `Maybe` values and functions\n-- | that accept a `Maybe a` and return a non-`Maybe` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Nothing = Nothing\n-- | f <<= x = Just (f x)\n-- | ```\ninstance extendMaybe :: Extend Maybe where\n  extend _ Nothing  = Nothing\n  extend f x        = Just (f x)\n\ninstance invariantMaybe :: Invariant Maybe where\n  imap = imapF\n\n-- | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values\n-- | whenever there is a `Semigroup` instance for the type the `Maybe` contains.\n-- | The exact behaviour of `<>` depends on the \"inner\" `Semigroup` instance,\n-- | but generally captures the notion of appending or combining things.\n-- |\n-- | ``` purescript\n-- | Just x <> Just y = Just (x <> y)\n-- | Just x <> Nothing = Just x\n-- | Nothing <> Just y = Just y\n-- | Nothing <> Nothing = Nothing\n-- | ```\ninstance semigroupMaybe :: Semigroup a => Semigroup (Maybe a) where\n  append Nothing y = y\n  append x Nothing = x\n  append (Just x) (Just y) = Just (x <> y)\n\ninstance monoidMaybe :: Semigroup a => Monoid (Maybe a) where\n  mempty = Nothing\n\n-- | The `Eq` instance allows `Maybe` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for the\n-- | type the `Maybe` contains.\nderive instance eqMaybe :: Eq a => Eq (Maybe a)\n\ninstance eq1Maybe :: Eq1 Maybe where eq1 = eq\n\n-- | The `Ord` instance allows `Maybe` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | the type the `Maybe` contains.\n-- |\n-- | `Nothing` is considered to be less than any `Just` value.\nderive instance ordMaybe :: Ord a => Ord (Maybe a)\n\ninstance ord1Maybe :: Ord1 Maybe where compare1 = compare\n\ninstance boundedMaybe :: Bounded a => Bounded (Maybe a) where\n  top = Just top\n  bottom = Nothing\n\n-- | The `Show` instance allows `Maybe` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for the type the `Maybe`\n-- | contains.\ninstance showMaybe :: Show a => Show (Maybe a) where\n  show (Just x) = \"(Just \" <> show x <> \")\"\n  show Nothing  = \"Nothing\"\n\n-- | Takes a default value, a function, and a `Maybe` value. If the `Maybe`\n-- | value is `Nothing` the default value is returned, otherwise the function\n-- | is applied to the value inside the `Just` and the result is returned.\n-- |\n-- | ``` purescript\n-- | maybe x f Nothing == x\n-- | maybe x f (Just y) == f y\n-- | ```\nmaybe :: forall a b. b -> (a -> b) -> Maybe a -> b\nmaybe b _ Nothing = b\nmaybe _ f (Just a) = f a\n\n-- | Similar to `maybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `maybe` has\n-- | to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | maybe' (\\_ -> x) f Nothing == x\n-- | maybe' (\\_ -> x) f (Just y) == f y\n-- | ```\nmaybe' :: forall a b. (Unit -> b) -> (a -> b) -> Maybe a -> b\nmaybe' g _ Nothing = g unit\nmaybe' _ f (Just a) = f a\n\n-- | Takes a default value, and a `Maybe` value. If the `Maybe` value is\n-- | `Nothing` the default value is returned, otherwise the value inside the\n-- | `Just` is returned.\n-- |\n-- | ``` purescript\n-- | fromMaybe x Nothing == x\n-- | fromMaybe x (Just y) == y\n-- | ```\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe a = maybe a identity\n\n-- | Similar to `fromMaybe` but for use in cases where the default value may be\n-- | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`\n-- | has to evaluate the default value before returning the result, whereas here\n-- | the value is only computed when the `Maybe` is known to be `Nothing`.\n-- |\n-- | ``` purescript\n-- | fromMaybe' (\\_ -> x) Nothing == x\n-- | fromMaybe' (\\_ -> x) (Just y) == y\n-- | ```\nfromMaybe' :: forall a. (Unit -> a) -> Maybe a -> a\nfromMaybe' a = maybe' a identity\n\n-- | Returns `true` when the `Maybe` value was constructed with `Just`.\nisJust :: forall a. Maybe a -> Boolean\nisJust = maybe false (const true)\n\n-- | Returns `true` when the `Maybe` value is `Nothing`.\nisNothing :: forall a. Maybe a -> Boolean\nisNothing = maybe true (const false)\n\n-- | A partial function that extracts the value from the `Just` data\n-- | constructor. Passing `Nothing` to `fromJust` will throw an error at\n-- | runtime.\nfromJust :: forall a. Partial => Maybe a -> a\nfromJust (Just x) = x\n\n-- | One or none.\n-- |\n-- | ``` purescript\n-- | optional empty = pure Nothing\n-- | optional (pure x) = pure (Just x)\n-- | ```\noptional :: forall f a. Alternative f => f a -> f (Maybe a)\noptional a = map Just a <|> pure Nothing\n","module Data.Maybe.Last where\n\nimport Prelude\n\nimport Control.Extend (class Extend)\nimport Control.MonadZero (class MonadZero, class Alternative, class Plus, class Alt)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\n-- | Monoid returning the last (right-most) non-`Nothing` value.\n-- |\n-- | ``` purescript\n-- | Last (Just x) <> Last (Just y) == Last (Just y)\n-- | Last (Just x) <> Nothing == Last (Just x)\n-- | Last Nothing <> Nothing == Last Nothing\n-- | mempty :: Last _ == Last Nothing\n-- | ```\nnewtype Last a = Last (Maybe a)\n\nderive instance newtypeLast :: Newtype (Last a) _\n\nderive newtype instance eqLast :: (Eq a) => Eq (Last a)\n\nderive newtype instance eq1Last :: Eq1 Last\n\nderive newtype instance ordLast :: (Ord a) => Ord (Last a)\n\nderive newtype instance ord1Last :: Ord1 Last\n\nderive newtype instance boundedLast :: (Bounded a) => Bounded (Last a)\n\nderive newtype instance functorLast :: Functor Last\n\nderive newtype instance invariantLast :: Invariant Last\n\nderive newtype instance applyLast :: Apply Last\n\nderive newtype instance applicativeLast :: Applicative Last\n\nderive newtype instance bindLast :: Bind Last\n\nderive newtype instance monadLast :: Monad Last\n\nderive newtype instance extendLast :: Extend Last\n\ninstance showLast :: Show a => Show (Last a) where\n  show (Last a) = \"(Last \" <> show a <> \")\"\n\ninstance semigroupLast :: Semigroup (Last a) where\n  append _ last@(Last (Just _)) = last\n  append last (Last Nothing) = last\n\ninstance monoidLast :: Monoid (Last a) where\n  mempty = Last Nothing\n\ninstance altLast :: Alt Last where\n  alt = append\n\ninstance plusLast :: Plus Last where\n  empty = mempty\n\ninstance alternativeLast :: Alternative Last\n\ninstance monadZeroLast :: MonadZero Last\n","module Data.Maybe.First where\n\nimport Prelude\n\nimport Control.Extend (class Extend)\nimport Control.MonadZero (class MonadZero, class Alternative, class Plus, class Alt)\nimport Data.Eq (class Eq1)\nimport Data.Functor.Invariant (class Invariant)\nimport Data.Maybe (Maybe(..))\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\n\n-- | Monoid returning the first (left-most) non-`Nothing` value.\n-- |\n-- | ``` purescript\n-- | First (Just x) <> First (Just y) == First (Just x)\n-- | First Nothing <> First (Just y) == First (Just y)\n-- | First Nothing <> Nothing == First Nothing\n-- | mempty :: First _ == First Nothing\n-- | ```\nnewtype First a = First (Maybe a)\n\nderive instance newtypeFirst :: Newtype (First a) _\n\nderive newtype instance eqFirst :: (Eq a) => Eq (First a)\n\nderive newtype instance eq1First :: Eq1 First\n\nderive newtype instance ordFirst :: (Ord a) => Ord (First a)\n\nderive newtype instance ord1First :: Ord1 First\n\nderive newtype instance boundedFirst :: (Bounded a) => Bounded (First a)\n\nderive newtype instance functorFirst :: Functor First\n\nderive newtype instance invariantFirst :: Invariant First\n\nderive newtype instance applyFirst :: Apply First\n\nderive newtype instance applicativeFirst :: Applicative First\n\nderive newtype instance bindFirst :: Bind First\n\nderive newtype instance monadFirst :: Monad First\n\nderive newtype instance extendFirst :: Extend First\n\ninstance showFirst :: (Show a) => Show (First a) where\n  show (First a) = \"First (\" <> show a <> \")\"\n\ninstance semigroupFirst :: Semigroup (First a) where\n  append first@(First (Just _)) _ = first\n  append _ second = second\n\ninstance monoidFirst :: Monoid (First a) where\n  mempty = First Nothing\n\ninstance altFirst :: Alt First where\n  alt = append\n\ninstance plusFirst :: Plus First where\n  empty = mempty\n\ninstance alternativeFirst :: Alternative First\n\ninstance monadZeroFirst :: MonadZero First\n","module Data.Int\n  ( fromNumber\n  , ceil\n  , floor\n  , round\n  , toNumber\n  , fromString\n  , Radix\n  , radix\n  , binary\n  , octal\n  , decimal\n  , hexadecimal\n  , base36\n  , fromStringAs\n  , toStringAs\n  , Parity(..)\n  , parity\n  , even\n  , odd\n  , quot\n  , rem\n  , pow\n  ) where\n\nimport Prelude\n\nimport Data.Int.Bits ((.&.))\nimport Data.Maybe (Maybe(..), fromMaybe)\nimport Global (infinity)\n\nimport Math as Math\n\n-- | Creates an `Int` from a `Number` value. The number must already be an\n-- | integer and fall within the valid range of values for the `Int` type\n-- | otherwise `Nothing` is returned.\nfromNumber :: Number -> Maybe Int\nfromNumber = fromNumberImpl Just Nothing\n\nforeign import fromNumberImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Number\n  -> Maybe Int\n\n-- | Convert a `Number` to an `Int`, by taking the closest integer equal to or\n-- | less than the argument. Values outside the `Int` range are clamped, `NaN`\n-- | and `Infinity` values return 0.\nfloor :: Number -> Int\nfloor = unsafeClamp <<< Math.floor\n\n-- | Convert a `Number` to an `Int`, by taking the closest integer equal to or\n-- | greater than the argument. Values outside the `Int` range are clamped,\n-- | `NaN` and `Infinity` values return 0.\nceil :: Number -> Int\nceil = unsafeClamp <<< Math.ceil\n\n-- | Convert a `Number` to an `Int`, by taking the nearest integer to the\n-- | argument. Values outside the `Int` range are clamped, `NaN` and `Infinity`\n-- | values return 0.\nround :: Number -> Int\nround = unsafeClamp <<< Math.round\n\n-- | Convert an integral `Number` to an `Int`, by clamping to the `Int` range.\n-- | This function will return 0 if the input is `NaN` or an `Infinity`.\nunsafeClamp :: Number -> Int\nunsafeClamp x\n  | x == infinity = 0\n  | x == -infinity = 0\n  | x >= toNumber top = top\n  | x <= toNumber bottom = bottom\n  | otherwise = fromMaybe 0 (fromNumber x)\n\n-- | Converts an `Int` value back into a `Number`. Any `Int` is a valid `Number`\n-- | so there is no loss of precision with this function.\nforeign import toNumber :: Int -> Number\n\n-- | Reads an `Int` from a `String` value. The number must parse as an integer\n-- | and fall within the valid range of values for the `Int` type, otherwise\n-- | `Nothing` is returned.\nfromString :: String -> Maybe Int\nfromString = fromStringAs (Radix 10)\n\n-- | A type for describing whether an integer is even or odd.\n-- |\n-- | The `Ord` instance considers `Even` to be less than `Odd`.\n-- |\n-- | The `Semiring` instance allows you to ask about the parity of the results\n-- | of arithmetical operations, given only the parities of the inputs. For\n-- | example, the sum of an odd number and an even number is odd, so\n-- | `Odd + Even == Odd`. This also works for multiplication, eg. the product\n-- | of two odd numbers is odd, and therefore `Odd * Odd == Odd`.\n-- |\n-- | More generally, we have that\n-- |\n-- | ```purescript\n-- | parity x + parity y == parity (x + y)\n-- | parity x * parity y == parity (x * y)\n-- | ```\n-- |\n-- | for any integers `x`, `y`. (A mathematician would say that `parity` is a\n-- | *ring homomorphism*.)\n-- |\n-- | After defining addition and multiplication on `Parity` in this way, the\n-- | `Semiring` laws now force us to choose `zero = Even` and `one = Odd`.\n-- | This `Semiring` instance actually turns out to be a `Field`.\ndata Parity = Even | Odd\n\nderive instance eqParity :: Eq Parity\nderive instance ordParity :: Ord Parity\n\ninstance showParity :: Show Parity where\n  show Even = \"Even\"\n  show Odd = \"Odd\"\n\ninstance boundedParity :: Bounded Parity where\n  bottom = Even\n  top = Odd\n\ninstance semiringParity :: Semiring Parity where\n  zero = Even\n  add x y = if x == y then Even else Odd\n  one = Odd\n  mul Odd Odd = Odd\n  mul _ _ = Even\n\ninstance ringParity :: Ring Parity where\n  sub = add\n\ninstance commutativeRingParity :: CommutativeRing Parity\n\ninstance euclideanRingParity :: EuclideanRing Parity where\n  degree Even = 0\n  degree Odd = 1\n  div x _ = x\n  mod _ _ = Even\n\ninstance divisionRingParity :: DivisionRing Parity where\n  recip = identity\n\n-- | Returns whether an `Int` is `Even` or `Odd`.\n-- |\n-- | ``` purescript\n-- | parity 0 == Even\n-- | parity 1 == Odd\n-- | ```\nparity :: Int -> Parity\nparity n = if even n then Even else Odd\n\n-- | Returns whether an `Int` is an even number.\n-- |\n-- | ``` purescript\n-- | even 0 == true\n-- | even 1 == false\n-- | ```\neven :: Int -> Boolean\neven x = x .&. 1 == 0\n\n-- | The negation of `even`.\n-- |\n-- | ``` purescript\n-- | odd 0 == false\n-- | odd 1 == true\n-- | ```\nodd :: Int -> Boolean\nodd x = x .&. 1 /= 0\n\n-- | The number of unique digits (including zero) used to represent integers in\n-- | a specific base.\nnewtype Radix = Radix Int\n\n-- | The base-2 system.\nbinary :: Radix\nbinary = Radix 2\n\n-- | The base-8 system.\noctal :: Radix\noctal = Radix 8\n\n-- | The base-10 system.\ndecimal :: Radix\ndecimal = Radix 10\n\n-- | The base-16 system.\nhexadecimal :: Radix\nhexadecimal = Radix 16\n\n-- | The base-36 system.\nbase36 :: Radix\nbase36 = Radix 36\n\n-- | Create a `Radix` from a number between 2 and 36.\nradix :: Int -> Maybe Radix\nradix n | n >= 2 && n <= 36 = Just (Radix n)\n        | otherwise         = Nothing\n\n-- | Like `fromString`, but the integer can be specified in a different base.\n-- |\n-- | Example:\n-- | ``` purs\n-- | fromStringAs binary      \"100\" == Just 4\n-- | fromStringAs hexadecimal \"ff\"  == Just 255\n-- | ```\nfromStringAs :: Radix -> String -> Maybe Int\nfromStringAs = fromStringAsImpl Just Nothing\n\n-- | The `quot` function provides _truncating_ integer division (see the\n-- | documentation for the `EuclideanRing` class). It is identical to `div` in\n-- | the `EuclideanRing Int` instance if the dividend is positive, but will be\n-- | slightly different if the dividend is negative. For example:\n-- |\n-- | ```purescript\n-- | div 2 3 == 0\n-- | quot 2 3 == 0\n-- |\n-- | div (-2) 3 == (-1)\n-- | quot (-2) 3 == 0\n-- |\n-- | div 2 (-3) == 0\n-- | quot 2 (-3) == 0\n-- | ```\nforeign import quot :: Int -> Int -> Int\n\n-- | The `rem` function provides the remainder after _truncating_ integer\n-- | division (see the documentation for the `EuclideanRing` class). It is\n-- | identical to `mod` in the `EuclideanRing Int` instance if the dividend is\n-- | positive, but will be slightly different if the dividend is negative. For\n-- | example:\n-- |\n-- | ```purescript\n-- | mod 2 3 == 2\n-- | rem 2 3 == 2\n-- |\n-- | mod (-2) 3 == 1\n-- | rem (-2) 3 == (-2)\n-- |\n-- | mod 2 (-3) == 2\n-- | rem 2 (-3) == 2\n-- | ```\nforeign import rem :: Int -> Int -> Int\n\n-- | Raise an Int to the power of another Int.\nforeign import pow :: Int -> Int -> Int\n\nforeign import fromStringAsImpl\n  :: (forall a. a -> Maybe a)\n  -> (forall a. Maybe a)\n  -> Radix\n  -> String\n  -> Maybe Int\n\nforeign import toStringAs :: Radix -> Int -> String\n","\"use strict\";\n\nexports.fromNumberImpl = function (just) {\n  return function (nothing) {\n    return function (n) {\n      /* jshint bitwise: false */\n      return (n | 0) === n ? just(n) : nothing;\n    };\n  };\n};\n\nexports.toNumber = function (n) {\n  return n;\n};\n\nexports.fromStringAsImpl = function (just) {\n  return function (nothing) {\n    return function (radix) {\n      var digits;\n      if (radix < 11) {\n        digits = \"[0-\" + (radix - 1).toString() + \"]\";\n      } else if (radix === 11) {\n        digits = \"[0-9a]\";\n      } else {\n        digits = \"[0-9a-\" + String.fromCharCode(86 + radix) + \"]\";\n      }\n      var pattern = new RegExp(\"^[\\\\+\\\\-]?\" + digits + \"+$\", \"i\");\n\n      return function (s) {\n        /* jshint bitwise: false */\n        if (pattern.test(s)) {\n          var i = parseInt(s, radix);\n          return (i | 0) === i ? just(i) : nothing;\n        } else {\n          return nothing;\n        }\n      };\n    };\n  };\n};\n\nexports.toStringAs = function (radix) {\n  return function (i) {\n    return i.toString(radix);\n  };\n};\n\n\nexports.quot = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x / y | 0;\n  };\n};\n\nexports.rem = function (x) {\n  return function (y) {\n    return x % y;\n  };\n};\n\nexports.pow = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return Math.pow(x,y) | 0;\n  };\n};\n","module Data.Identity where\n\nimport Prelude\n\nimport Control.Alt (class Alt)\nimport Control.Comonad (class Comonad)\nimport Control.Extend (class Extend)\nimport Control.Lazy (class Lazy)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable)\nimport Data.FoldableWithIndex (class FoldableWithIndex)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord1)\nimport Data.Semigroup.Foldable (class Foldable1)\nimport Data.Semigroup.Traversable (class Traversable1)\nimport Data.Traversable (class Traversable)\nimport Data.TraversableWithIndex (class TraversableWithIndex)\n\nnewtype Identity a = Identity a\n\nderive instance newtypeIdentity :: Newtype (Identity a) _\n\nderive newtype instance eqIdentity :: Eq a => Eq (Identity a)\n\nderive newtype instance ordIdentity :: Ord a => Ord (Identity a)\n\nderive newtype instance boundedIdentity :: Bounded a => Bounded (Identity a)\n\nderive newtype instance heytingAlgebraIdentity :: HeytingAlgebra a => HeytingAlgebra (Identity a)\n\nderive newtype instance booleanAlgebraIdentity :: BooleanAlgebra a => BooleanAlgebra (Identity a)\n\nderive newtype instance semigroupIdenity :: Semigroup a => Semigroup (Identity a)\n\nderive newtype instance monoidIdentity :: Monoid a => Monoid (Identity a)\n\nderive newtype instance semiringIdentity :: Semiring a => Semiring (Identity a)\n\nderive newtype instance euclideanRingIdentity :: EuclideanRing a => EuclideanRing (Identity a)\n\nderive newtype instance ringIdentity :: Ring a => Ring (Identity a)\n\nderive newtype instance commutativeRingIdentity :: CommutativeRing a => CommutativeRing (Identity a)\n\nderive newtype instance lazyIdentity :: Lazy a => Lazy (Identity a)\n\ninstance showIdentity :: Show a => Show (Identity a) where\n  show (Identity x) = \"(Identity \" <> show x <> \")\"\n\nderive instance eq1Identity :: Eq1 Identity\n\nderive instance ord1Identity :: Ord1 Identity\n\nderive instance functorIdentity :: Functor Identity\n\ninstance functorWithIndexIdentity :: FunctorWithIndex Unit Identity where\n  mapWithIndex f (Identity a) = Identity (f unit a)\n\ninstance invariantIdentity :: Invariant Identity where\n  imap = imapF\n\ninstance altIdentity :: Alt Identity where\n  alt x _ = x\n\ninstance applyIdentity :: Apply Identity where\n  apply (Identity f) (Identity x) = Identity (f x)\n\ninstance applicativeIdentity :: Applicative Identity where\n  pure = Identity\n\ninstance bindIdentity :: Bind Identity where\n  bind (Identity m) f = f m\n\ninstance monadIdentity :: Monad Identity\n\ninstance extendIdentity :: Extend Identity where\n  extend f m = Identity (f m)\n\ninstance comonadIdentity :: Comonad Identity where\n  extract (Identity x) = x\n\ninstance foldableIdentity :: Foldable Identity where\n  foldr f z (Identity x) = f x z\n  foldl f z (Identity x) = f z x\n  foldMap f (Identity x) = f x\n\ninstance foldable1Identity :: Foldable1 Identity where\n  fold1 (Identity x) = x\n  foldMap1 f (Identity x) = f x\n\ninstance foldableWithIndexIdentity :: FoldableWithIndex Unit Identity where\n  foldrWithIndex f z (Identity x) = f unit x z\n  foldlWithIndex f z (Identity x) = f unit z x\n  foldMapWithIndex f (Identity x) = f unit x\n\ninstance traversableIdentity :: Traversable Identity where\n  traverse f (Identity x) = Identity <$> f x\n  sequence (Identity x) = Identity <$> x\n\ninstance traversable1Identity :: Traversable1 Identity where\n  traverse1 f (Identity x) = Identity <$> f x\n  sequence1 (Identity x) = Identity <$> x\n\ninstance traversableWithIndexIdentity :: TraversableWithIndex Unit Identity where\n  traverseWithIndex f (Identity x) = Identity <$> f unit x\n","module Data.HeytingAlgebra\n  ( class HeytingAlgebra, tt, ff, implies, conj, disj, not, (&&), (||)\n  , class HeytingAlgebraRecord, ffRecord, ttRecord, impliesRecord, conjRecord, disjRecord, notRecord\n  ) where\n\nimport Data.Symbol (class IsSymbol, SProxy(..), reflectSymbol)\nimport Data.Unit (Unit, unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet, unsafeSet)\nimport Type.Data.Row (RProxy(..))\nimport Type.Data.RowList (RLProxy(..))\n\n-- | The `HeytingAlgebra` type class represents types that are bounded lattices with\n-- | an implication operator such that the following laws hold:\n-- |\n-- | - Associativity:\n-- |   - `a || (b || c) = (a || b) || c`\n-- |   - `a && (b && c) = (a && b) && c`\n-- | - Commutativity:\n-- |   - `a || b = b || a`\n-- |   - `a && b = b && a`\n-- | - Absorption:\n-- |   - `a || (a && b) = a`\n-- |   - `a && (a || b) = a`\n-- | - Idempotent:\n-- |   - `a || a = a`\n-- |   - `a && a = a`\n-- | - Identity:\n-- |   - `a || ff = a`\n-- |   - `a && tt = a`\n-- | - Implication:\n-- |   - ``a `implies` a = tt``\n-- |   - ``a && (a `implies` b) = a && b``\n-- |   - ``b && (a `implies` b) = b``\n-- |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``\n-- | - Complemented:\n-- |   - ``not a = a `implies` ff``\nclass HeytingAlgebra a where\n  ff :: a\n  tt :: a\n  implies :: a -> a -> a\n  conj :: a -> a -> a\n  disj :: a -> a -> a\n  not :: a -> a\n\ninfixr 3 conj as &&\ninfixr 2 disj as ||\n\ninstance heytingAlgebraBoolean :: HeytingAlgebra Boolean where\n  ff = false\n  tt = true\n  implies a b = not a || b\n  conj = boolConj\n  disj = boolDisj\n  not = boolNot\n\ninstance heytingAlgebraUnit :: HeytingAlgebra Unit where\n  ff = unit\n  tt = unit\n  implies _ _ = unit\n  conj _ _ = unit\n  disj _ _ = unit\n  not _ = unit\n\ninstance heytingAlgebraFunction :: HeytingAlgebra b => HeytingAlgebra (a -> b) where\n  ff _ = ff\n  tt _ = tt\n  implies f g a = f a `implies` g a\n  conj f g a = f a && g a\n  disj f g a = f a || g a\n  not f a = not (f a)\n\ninstance heytingAlgebraRecord :: (RL.RowToList row list, HeytingAlgebraRecord list row row) => HeytingAlgebra (Record row) where\n  ff = ffRecord  (RLProxy :: RLProxy list) (RProxy :: RProxy row)\n  tt = ttRecord  (RLProxy :: RLProxy list) (RProxy :: RProxy row)\n  conj = conjRecord  (RLProxy :: RLProxy list)\n  disj = disjRecord  (RLProxy :: RLProxy list)\n  implies = impliesRecord  (RLProxy :: RLProxy list)\n  not = notRecord  (RLProxy :: RLProxy list)\n\nforeign import boolConj :: Boolean -> Boolean -> Boolean\nforeign import boolDisj :: Boolean -> Boolean -> Boolean\nforeign import boolNot :: Boolean -> Boolean\n\n-- | A class for records where all fields have `HeytingAlgebra` instances, used\n-- | to implement the `HeytingAlgebra` instance for records.\nclass HeytingAlgebraRecord rowlist row subrow | rowlist -> subrow where\n  ffRecord :: RLProxy rowlist -> RProxy row -> Record subrow\n  ttRecord :: RLProxy rowlist -> RProxy row -> Record subrow\n  impliesRecord :: RLProxy rowlist -> Record row -> Record row -> Record subrow\n  disjRecord :: RLProxy rowlist -> Record row -> Record row -> Record subrow\n  conjRecord :: RLProxy rowlist -> Record row -> Record row -> Record subrow\n  notRecord :: RLProxy rowlist -> Record row -> Record subrow\n\ninstance heytingAlgebraRecordNil :: HeytingAlgebraRecord RL.Nil row () where\n  conjRecord _ _ _ = {}\n  disjRecord _ _ _ = {}\n  ffRecord _ _ = {}\n  impliesRecord _ _ _ = {}\n  notRecord _ _ = {}\n  ttRecord _ _ = {}\n\ninstance heytingAlgebraRecordCons\n    :: ( IsSymbol key\n       , Row.Cons key focus subrowTail subrow\n       , HeytingAlgebraRecord rowlistTail row subrowTail\n       , HeytingAlgebra focus\n       )\n    => HeytingAlgebraRecord (RL.Cons key focus rowlistTail) row subrow where\n  conjRecord _ ra rb = insert (conj (get ra) (get rb)) tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      tail = conjRecord (RLProxy :: RLProxy rowlistTail) ra rb\n\n  disjRecord _ ra rb = insert (disj (get ra) (get rb)) tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      tail = disjRecord (RLProxy :: RLProxy rowlistTail) ra rb\n\n  impliesRecord _ ra rb = insert (implies (get ra) (get rb)) tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      tail = impliesRecord (RLProxy :: RLProxy rowlistTail) ra rb\n\n  ffRecord _ row = insert ff tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      tail = ffRecord (RLProxy :: RLProxy rowlistTail) row\n\n  notRecord _ row\n    = insert (not (get row)) tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      tail = notRecord (RLProxy :: RLProxy rowlistTail) row\n\n  ttRecord _ row = insert tt tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      insert = unsafeSet key :: focus -> Record subrowTail -> Record subrow\n      tail = ttRecord (RLProxy :: RLProxy rowlistTail) row\n","\"use strict\";\n\nexports.boolConj = function (b1) {\n  return function (b2) {\n    return b1 && b2;\n  };\n};\n\nexports.boolDisj = function (b1) {\n  return function (b2) {\n    return b1 || b2;\n  };\n};\n\nexports.boolNot = function (b) {\n  return !b;\n};\n","module Data.FunctorWithIndex\n  ( class FunctorWithIndex, mapWithIndex, mapDefault\n  ) where\n\nimport Prelude\n\nimport Data.Maybe (Maybe)\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj)\nimport Data.Monoid.Disj (Disj)\nimport Data.Monoid.Dual (Dual)\nimport Data.Monoid.Multiplicative (Multiplicative)\n\n-- | A `Functor` with an additional index.\n-- | Instances must satisfy a modified form of the `Functor` laws\n-- | ```purescript\n-- | mapWithIndex (\\_ a -> a) = identity\n-- | mapWithIndex f . mapWithIndex g = mapWithIndex (\\i -> f i <<< g i)\n-- | ```\n-- | and be compatible with the `Functor` instance\n-- | ```purescript\n-- | map f = mapWithIndex (const f)\n-- | ```\nclass Functor f <= FunctorWithIndex i f | f -> i where\n  mapWithIndex :: forall a b. (i -> a -> b) -> f a -> f b\n\nforeign import mapWithIndexArray :: forall i a b. (i -> a -> b) -> Array a -> Array b\n\ninstance functorWithIndexArray :: FunctorWithIndex Int Array where\n  mapWithIndex = mapWithIndexArray\n\ninstance functorWithIndexMaybe :: FunctorWithIndex Unit Maybe where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexFirst :: FunctorWithIndex Unit First where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexLast :: FunctorWithIndex Unit Last where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexAdditive :: FunctorWithIndex Unit Additive where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexDual :: FunctorWithIndex Unit Dual where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexConj :: FunctorWithIndex Unit Conj where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexDisj :: FunctorWithIndex Unit Disj where\n  mapWithIndex f = map $ f unit\n\ninstance functorWithIndexMultiplicative :: FunctorWithIndex Unit Multiplicative where\n  mapWithIndex f = map $ f unit\n\n-- | A default implementation of Functor's `map` in terms of `mapWithIndex`\nmapDefault :: forall i f a b. FunctorWithIndex i f => (a -> b) -> f a -> f b\nmapDefault f = mapWithIndex (const f)\n","\"use strict\";\n\nexports.mapWithIndexArray = function (f) {\n  return function (xs) {\n    var l = xs.length;\n    var result = Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(i)(xs[i]);\n    }\n    return result;\n  };\n};\n","module Data.Functor\n  ( class Functor, map, (<$>)\n  , mapFlipped, (<#>)\n  , void\n  , voidRight, (<$)\n  , voidLeft, ($>)\n  , flap, (<@>)\n  ) where\n\nimport Data.Function (const, compose)\nimport Data.Unit (Unit, unit)\n\n-- | A `Functor` is a type constructor which supports a mapping operation\n-- | `map`.\n-- |\n-- | `map` can be used to turn functions `a -> b` into functions\n-- | `f a -> f b` whose argument and return types use the type constructor `f`\n-- | to represent some computational context.\n-- |\n-- | Instances must satisfy the following laws:\n-- |\n-- | - Identity: `map identity = identity`\n-- | - Composition: `map (f <<< g) = map f <<< map g`\nclass Functor f where\n  map :: forall a b. (a -> b) -> f a -> f b\n\ninfixl 4 map as <$>\n\n-- | `mapFlipped` is `map` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | [1, 2, 3] <#> \\n -> n * n\n-- | ```\nmapFlipped :: forall f a b. Functor f => f a -> (a -> b) -> f b\nmapFlipped fa f = f <$> fa\n\ninfixl 1 mapFlipped as <#>\n\ninstance functorFn :: Functor ((->) r) where\n  map = compose\n\ninstance functorArray :: Functor Array where\n  map = arrayMap\n\nforeign import arrayMap :: forall a b. (a -> b) -> Array a -> Array b\n\n-- | The `void` function is used to ignore the type wrapped by a\n-- | [`Functor`](#functor), replacing it with `Unit` and keeping only the type\n-- | information provided by the type constructor itself.\n-- |\n-- | `void` is often useful when using `do` notation to change the return type\n-- | of a monadic computation:\n-- |\n-- | ```purescript\n-- | main = forE 1 10 \\n -> void do\n-- |   print n\n-- |   print (n * n)\n-- | ```\nvoid :: forall f a. Functor f => f a -> f Unit\nvoid = map (const unit)\n\n-- | Ignore the return value of a computation, using the specified return value\n-- | instead.\nvoidRight :: forall f a b. Functor f => a -> f b -> f a\nvoidRight x = map (const x)\n\ninfixl 4 voidRight as <$\n\n-- | A version of `voidRight` with its arguments flipped.\nvoidLeft :: forall f a b. Functor f => f a -> b -> f b\nvoidLeft f x = const x <$> f\n\ninfixl 4 voidLeft as $>\n\n-- | Apply a value in a computational context to a value in no context.\n-- |\n-- | Generalizes `flip`.\n-- |\n-- | ```purescript\n-- | longEnough :: String -> Bool\n-- | hasSymbol :: String -> Bool\n-- | hasDigit :: String -> Bool\n-- | password :: String\n-- |\n-- | validate :: String -> Array Bool\n-- | validate = flap [longEnough, hasSymbol, hasDigit]\n-- | ```\n-- |\n-- | ```purescript\n-- | flap (-) 3 4 == 1\n-- | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)\n-- | ```\nflap :: forall f a b. Functor f => f (a -> b) -> a -> f b\nflap ff x = map (\\f -> f x) ff\n\ninfixl 4 flap as <@>\n","\"use strict\";\n\nexports.arrayMap = function (f) {\n  return function (arr) {\n    var l = arr.length;\n    var result = new Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(arr[i]);\n    }\n    return result;\n  };\n};\n","module Data.Functor.Invariant where\n\nimport Control.Semigroupoid ((<<<))\nimport Data.Functor (class Functor, map)\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\n\n-- | A type of functor that can be used to adapt the type of a wrapped function\n-- | where the parameterised type occurs in both the positive and negative\n-- | position, for example, `F (a -> a)`.\n-- |\n-- | An `Invariant` instance should satisfy the following laws:\n-- |\n-- | - Identity: `imap id id = id`\n-- | - Composition: `imap g1 g2 <<< imap f1 f2 = imap (g1 <<< f1) (f2 <<< g2)`\n-- |\nclass Invariant f where\n  imap :: forall a b. (a -> b) -> (b -> a) -> f a -> f b\n\ninstance invariantFn :: Invariant ((->) a) where\n  imap = imapF\n\ninstance invariantArray :: Invariant Array where\n  imap = imapF\n\ninstance invariantAdditive :: Invariant Additive where\n  imap f _ (Additive x) = Additive (f x)\n\ninstance invariantConj :: Invariant Conj where\n  imap f _ (Conj x) = Conj (f x)\n\ninstance invariantDisj :: Invariant Disj where\n  imap f _ (Disj x) = Disj (f x)\n\ninstance invariantDual :: Invariant Dual where\n  imap f _ (Dual x) = Dual (f x)\n\ninstance invariantEndo :: Invariant (Endo Function) where\n  imap ab ba (Endo f) = Endo (ab <<< f <<< ba)\n\ninstance invariantMultiplicative :: Invariant Multiplicative where\n  imap f _ (Multiplicative x) = Multiplicative (f x)\n\n-- | As all `Functor`s are also trivially `Invariant`, this function can be\n-- | used as the `imap` implementation for any types that has an existing\n-- | `Functor` instance.\nimapF :: forall f a b. Functor f => (a -> b) -> (b -> a) -> f a -> f b\nimapF f _ = map f\n","module Data.Function\n  ( flip\n  , const\n  , apply, ($)\n  , applyFlipped, (#)\n  , applyN\n  , on\n  , module Control.Category\n  ) where\n\nimport Control.Category (identity, compose, (<<<), (>>>))\nimport Data.Boolean (otherwise)\nimport Data.Ord ((<=))\nimport Data.Ring ((-))\n\n-- | Flips the order of the arguments to a function of two arguments.\n-- |\n-- | ```purescript\n-- | flip const 1 2 = const 2 1 = 2\n-- | ```\nflip :: forall a b c. (a -> b -> c) -> b -> a -> c\nflip f b a = f a b\n\n-- | Returns its first argument and ignores its second.\n-- |\n-- | ```purescript\n-- | const 1 \"hello\" = 1\n-- | ```\nconst :: forall a b. a -> b -> a\nconst a _ = a\n\n-- | Applies a function to an argument. This is primarily used as the operator\n-- | `($)` which allows parentheses to be omitted in some cases, or as a\n-- | natural way to apply a chain of composed functions to a value.\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n\n-- | Applies a function to an argument: the reverse of `(#)`.\n-- |\n-- | ```purescript\n-- | length $ groupBy productCategory $ filter isInStock $ products\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying chain of composed functions to\n-- | a value:\n-- |\n-- | ```purescript\n-- | length <<< groupBy productCategory <<< filter isInStock $ products\n-- | ```\ninfixr 0 apply as $\n\n-- | Applies an argument to a function. This is primarily used as the `(#)`\n-- | operator, which allows parentheses to be ommitted in some cases, or as a\n-- | natural way to apply a value to a chain of composed functions.\napplyFlipped :: forall a b. a -> (a -> b) -> b\napplyFlipped x f = f x\n\n-- | Applies an argument to a function: the reverse of `($)`.\n-- |\n-- | ```purescript\n-- | products # filter isInStock # groupBy productCategory # length\n-- | ```\n-- |\n-- | is equivalent to:\n-- |\n-- | ```purescript\n-- | length (groupBy productCategory (filter isInStock products))\n-- | ```\n-- |\n-- | Or another alternative equivalent, applying a value to a chain of composed\n-- | functions:\n-- |\n-- | ```purescript\n-- | products # filter isInStock >>> groupBy productCategory >>> length\n-- | ```\ninfixl 1 applyFlipped as #\n\n-- | `applyN f n` applies the function `f` to its argument `n` times.\n-- |\n-- | If n is less than or equal to 0, the function is not applied.\n-- |\n-- | ```purescript\n-- | applyN (_ + 1) 10 0 == 10\n-- | ```\napplyN :: forall a. (a -> a) -> Int -> a -> a\napplyN f = go\n  where\n  go n acc\n    | n <= 0   = acc\n    | otherwise = go (n - 1) (f acc)\n\n-- | The `on` function is used to change the domain of a binary operator.\n-- |\n-- | For example, we can create a function which compares two records based on the values of their `x` properties:\n-- |\n-- | ```purescript\n-- | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering\n-- | compareX = compare `on` _.x\n-- | ```\non :: forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c\non f g x y = g x `f` g y\n","module Data.FoldableWithIndex\n  ( class FoldableWithIndex, foldrWithIndex, foldlWithIndex, foldMapWithIndex\n  , foldrWithIndexDefault\n  , foldlWithIndexDefault\n  , foldMapWithIndexDefaultR\n  , foldMapWithIndexDefaultL\n  , foldWithIndexM\n  , traverseWithIndex_\n  , forWithIndex_\n  , surroundMapWithIndex\n  , allWithIndex\n  , anyWithIndex\n  , findWithIndex\n  , foldrDefault\n  , foldlDefault\n  , foldMapDefault\n  ) where\n\nimport Prelude\n\nimport Data.Foldable (class Foldable, foldMap, foldl, foldr)\nimport Data.FunctorWithIndex (mapWithIndex)\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First)\nimport Data.Maybe.Last (Last)\nimport Data.Monoid.Additive (Additive)\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative)\nimport Data.Newtype (unwrap)\n\n-- | A `Foldable` with an additional index.\n-- | A `FoldableWithIndex` instance must be compatible with its `Foldable`\n-- | instance\n-- | ```purescript\n-- | foldr f = foldrWithIndex (const f)\n-- | foldl f = foldlWithIndex (const f)\n-- | foldMap f = foldMapWithIndex (const f)\n-- | ```\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrWithIndexDefault`\n-- | - `foldlWithIndexDefault`\n-- | - `foldMapWithIndexDefaultR`\n-- | - `foldMapWithIndexDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f <= FoldableWithIndex i f | f -> i where\n  foldrWithIndex :: forall a b. (i -> a -> b -> b) -> b -> f a -> b\n  foldlWithIndex :: forall a b. (i -> b -> a -> b) -> b -> f a -> b\n  foldMapWithIndex :: forall a m. Monoid m => (i -> a -> m) -> f a -> m\n\n-- | A default implementation of `foldrWithIndex` using `foldMapWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldMapWithIndexDefaultR`.\nfoldrWithIndexDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (i -> a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrWithIndexDefault c u xs = unwrap (foldMapWithIndex (\\i -> Endo <<< c i) xs) u\n\n-- | A default implementation of `foldlWithIndex` using `foldMapWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldMapWithIndexDefaultL`.\nfoldlWithIndexDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (i -> b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlWithIndexDefault c u xs = unwrap (unwrap (foldMapWithIndex (\\i -> Dual <<< Endo <<< flip (c i)) xs)) u\n\n-- | A default implementation of `foldMapWithIndex` using `foldrWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldrWithIndexDefault`.\nfoldMapWithIndexDefaultR\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (i -> a -> m)\n  -> f a\n  -> m\nfoldMapWithIndexDefaultR f = foldrWithIndex (\\i x acc -> f i x <> acc) mempty\n\n-- | A default implementation of `foldMapWithIndex` using `foldlWithIndex`.\n-- |\n-- | Note: when defining a `FoldableWithIndex` instance, this function is\n-- | unsafe to use in combination with `foldlWithIndexDefault`.\nfoldMapWithIndexDefaultL\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (i -> a -> m)\n  -> f a\n  -> m\nfoldMapWithIndexDefaultL f = foldlWithIndex (\\i acc x -> acc <> f i x) mempty\n\ndata Tuple a b = Tuple a b\n\ninstance foldableWithIndexArray :: FoldableWithIndex Int Array where\n  foldrWithIndex f z = foldr (\\(Tuple i x) y -> f i x y) z <<< mapWithIndex Tuple\n  foldlWithIndex f z = foldl (\\y (Tuple i x) -> f i y x) z <<< mapWithIndex Tuple\n  foldMapWithIndex = foldMapWithIndexDefaultR\n\ninstance foldableWithIndexMaybe :: FoldableWithIndex Unit Maybe where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexFirst :: FoldableWithIndex Unit First where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexLast :: FoldableWithIndex Unit Last where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexAdditive :: FoldableWithIndex Unit Additive where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexDual :: FoldableWithIndex Unit Dual where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexDisj :: FoldableWithIndex Unit Disj where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexConj :: FoldableWithIndex Unit Conj where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\ninstance foldableWithIndexMultiplicative :: FoldableWithIndex Unit Multiplicative where\n  foldrWithIndex f = foldr $ f unit\n  foldlWithIndex f = foldl $ f unit\n  foldMapWithIndex f = foldMap $ f unit\n\n\n-- | Similar to 'foldlWithIndex', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldWithIndexM\n  :: forall i f m a b\n   . FoldableWithIndex i f\n  => Monad m\n  => (i -> a -> b -> m a)\n  -> a\n  -> f b\n  -> m a\nfoldWithIndexM f a0 = foldlWithIndex (\\i ma b -> ma >>= flip (f i) b) (pure a0)\n\n-- | Traverse a data structure with access to the index, performing some\n-- | effects encoded by an `Applicative` functor at each value, ignoring the\n-- | final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > traverseWithIndex_ (curry logShow) [\"a\", \"b\", \"c\"]\n-- | (Tuple 0 \"a\")\n-- | (Tuple 1 \"b\")\n-- | (Tuple 2 \"c\")\n-- | ```\ntraverseWithIndex_\n  :: forall i a b f m\n   . Applicative m\n  => FoldableWithIndex i f\n  => (i -> a -> m b)\n  -> f a\n  -> m Unit\ntraverseWithIndex_ f = foldrWithIndex (\\i -> (*>) <<< f i) (pure unit)\n\n-- | A version of `traverseWithIndex_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | forWithIndex_ [\"a\", \"b\", \"c\"] \\i x -> do\n-- |   logShow i\n-- |   log x\n-- | ```\nforWithIndex_\n  :: forall i a b f m\n   . Applicative m\n  => FoldableWithIndex i f\n  => f a\n  -> (i -> a -> m b)\n  -> m Unit\nforWithIndex_ = flip traverseWithIndex_\n\n-- | `foldMapWithIndex` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) []\n-- | = \"*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\"]\n-- | = \"*0a*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\", \"b\"]\n-- | = \"*0a*1b*\"\n-- |\n-- | > surroundMapWithIndex \"*\" (\\i x -> show i <> x) [\"a\", \"b\", \"c\"]\n-- | = \"*0a*1b*2c*\"\n-- | ```\nsurroundMapWithIndex\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Semigroup m\n  => m\n  -> (i -> a -> m)\n  -> f a\n  -> m\nsurroundMapWithIndex d t f = unwrap (foldMapWithIndex joined f) d\n  where joined i a = Endo \\m -> d <> t i a <> m\n\n-- | `allWithIndex f` is the same as `and <<< mapWithIndex f`; map a function over the\n-- | structure, and then get the conjunction of the results.\nallWithIndex\n  :: forall i a b f\n   . FoldableWithIndex i f\n  => HeytingAlgebra b\n  => (i -> a -> b)\n  -> f a\n  -> b\nallWithIndex t = unwrap <<< foldMapWithIndex (\\i -> Conj <<< t i)\n\n-- | `anyWithIndex f` is the same as `or <<< mapWithIndex f`; map a function over the\n-- | structure, and then get the disjunction of the results.\nanyWithIndex\n  :: forall i a b f\n   . FoldableWithIndex i f\n  => HeytingAlgebra b\n  => (i -> a -> b)\n  -> f a\n  -> b\nanyWithIndex t = unwrap <<< foldMapWithIndex (\\i -> Disj <<< t i)\n\n-- | Try to find an element in a data structure which satisfies a predicate\n-- | with access to the index.\nfindWithIndex\n  :: forall i a f\n   . FoldableWithIndex i f\n  => (i -> a -> Boolean)\n  -> f a\n  -> Maybe { index :: i, value :: a }\nfindWithIndex p = foldlWithIndex go Nothing\n  where\n    go\n      :: i\n      -> Maybe { index :: i, value :: a }\n      -> a\n      -> Maybe { index :: i, value :: a }\n    go i Nothing x | p i x = Just { index: i, value: x }\n    go _ r _ = r\n\n-- | A default implementation of `foldr` using `foldrWithIndex`\nfoldrDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (a -> b -> b) -> b -> f a -> b\nfoldrDefault f = foldrWithIndex (const f)\n\n-- | A default implementation of `foldl` using `foldlWithIndex`\nfoldlDefault\n  :: forall i f a b\n   . FoldableWithIndex i f\n  => (b -> a -> b) -> b -> f a -> b\nfoldlDefault f = foldlWithIndex (const f)\n\n-- | A default implementation of `foldMap` using `foldMapWithIndex`\nfoldMapDefault\n  :: forall i f a m\n   . FoldableWithIndex i f\n  => Monoid m\n  => (a -> m) -> f a -> m\nfoldMapDefault f = foldMapWithIndex (const f)\n","module Data.Foldable\n  ( class Foldable, foldr, foldl, foldMap\n  , foldrDefault, foldlDefault, foldMapDefaultL, foldMapDefaultR\n  , fold\n  , foldM\n  , traverse_\n  , for_\n  , sequence_\n  , oneOf\n  , oneOfMap\n  , intercalate\n  , surroundMap\n  , surround\n  , and\n  , or\n  , all\n  , any\n  , sum\n  , product\n  , elem\n  , notElem\n  , indexl\n  , indexr\n  , find\n  , findMap\n  , maximum\n  , maximumBy\n  , minimum\n  , minimumBy\n  , null\n  , length\n  ) where\n\nimport Prelude\n\nimport Control.Plus (class Plus, alt, empty)\nimport Data.Maybe (Maybe(..))\nimport Data.Maybe.First (First(..))\nimport Data.Maybe.Last (Last(..))\nimport Data.Monoid.Additive (Additive(..))\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Monoid.Multiplicative (Multiplicative(..))\nimport Data.Newtype (alaF, unwrap)\n\n-- | `Foldable` represents data structures which can be _folded_.\n-- |\n-- | - `foldr` folds a structure from the right\n-- | - `foldl` folds a structure from the left\n-- | - `foldMap` folds a structure by accumulating values in a `Monoid`\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `foldrDefault`\n-- | - `foldlDefault`\n-- | - `foldMapDefaultR`\n-- | - `foldMapDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Foldable f where\n  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n\n-- | A default implementation of `foldr` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultR`.\nfoldrDefault\n  :: forall f a b\n   . Foldable f\n  => (a -> b -> b)\n  -> b\n  -> f a\n  -> b\nfoldrDefault c u xs = unwrap (foldMap (Endo <<< c) xs) u\n\n-- | A default implementation of `foldl` using `foldMap`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldMapDefaultL`.\nfoldlDefault\n  :: forall f a b\n   . Foldable f\n  => (b -> a -> b)\n  -> b\n  -> f a\n  -> b\nfoldlDefault c u xs = unwrap (unwrap (foldMap (Dual <<< Endo <<< flip c) xs)) u\n\n-- | A default implementation of `foldMap` using `foldr`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldrDefault`.\nfoldMapDefaultR\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultR f = foldr (\\x acc -> f x <> acc) mempty\n\n-- | A default implementation of `foldMap` using `foldl`.\n-- |\n-- | Note: when defining a `Foldable` instance, this function is unsafe to use\n-- | in combination with `foldlDefault`.\nfoldMapDefaultL\n  :: forall f a m\n   . Foldable f\n  => Monoid m\n  => (a -> m)\n  -> f a\n  -> m\nfoldMapDefaultL f = foldl (\\acc x -> acc <> f x) mempty\n\ninstance foldableArray :: Foldable Array where\n  foldr = foldrArray\n  foldl = foldlArray\n  foldMap = foldMapDefaultR\n\nforeign import foldrArray :: forall a b. (a -> b -> b) -> b -> Array a -> b\nforeign import foldlArray :: forall a b. (b -> a -> b) -> b -> Array a -> b\n\ninstance foldableMaybe :: Foldable Maybe where\n  foldr _ z Nothing  = z\n  foldr f z (Just x) = x `f` z\n  foldl _ z Nothing  = z\n  foldl f z (Just x) = z `f` x\n  foldMap f Nothing  = mempty\n  foldMap f (Just x) = f x\n\ninstance foldableFirst :: Foldable First where\n  foldr f z (First x) = foldr f z x\n  foldl f z (First x) = foldl f z x\n  foldMap f (First x) = foldMap f x\n\ninstance foldableLast :: Foldable Last where\n  foldr f z (Last x) = foldr f z x\n  foldl f z (Last x) = foldl f z x\n  foldMap f (Last x) = foldMap f x\n\ninstance foldableAdditive :: Foldable Additive where\n  foldr f z (Additive x) = x `f` z\n  foldl f z (Additive x) = z `f` x\n  foldMap f (Additive x) = f x\n\ninstance foldableDual :: Foldable Dual where\n  foldr f z (Dual x) = x `f` z\n  foldl f z (Dual x) = z `f` x\n  foldMap f (Dual x) = f x\n\ninstance foldableDisj :: Foldable Disj where\n  foldr f z (Disj x) = f x z\n  foldl f z (Disj x) = f z x\n  foldMap f (Disj x) = f x\n\ninstance foldableConj :: Foldable Conj where\n  foldr f z (Conj x) = f x z\n  foldl f z (Conj x) = f z x\n  foldMap f (Conj x) = f x\n\ninstance foldableMultiplicative :: Foldable Multiplicative where\n  foldr f z (Multiplicative x) = x `f` z\n  foldl f z (Multiplicative x) = z `f` x\n  foldMap f (Multiplicative x) = f x\n\n-- | Fold a data structure, accumulating values in some `Monoid`.\nfold :: forall f m. Foldable f => Monoid m => f m -> m\nfold = foldMap identity\n\n-- | Similar to 'foldl', but the result is encapsulated in a monad.\n-- |\n-- | Note: this function is not generally stack-safe, e.g., for monads which\n-- | build up thunks a la `Eff`.\nfoldM :: forall f m a b. Foldable f => Monad m => (a -> b -> m a) -> a -> f b -> m a\nfoldM f a0 = foldl (\\ma b -> ma >>= flip f b) (pure a0)\n\n-- | Traverse a data structure, performing some effects encoded by an\n-- | `Applicative` functor at each value, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | traverse_ print [1, 2, 3]\n-- | ```\ntraverse_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => (a -> m b)\n  -> f a\n  -> m Unit\ntraverse_ f = foldr ((*>) <<< f) (pure unit)\n\n-- | A version of `traverse_` with its arguments flipped.\n-- |\n-- | This can be useful when running an action written using do notation\n-- | for every element in a data structure:\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | for_ [1, 2, 3] \\n -> do\n-- |   print n\n-- |   trace \"squared is\"\n-- |   print (n * n)\n-- | ```\nfor_\n  :: forall a b f m\n   . Applicative m\n  => Foldable f\n  => f a\n  -> (a -> m b)\n  -> m Unit\nfor_ = flip traverse_\n\n-- | Perform all of the effects in some data structure in the order\n-- | given by the `Foldable` instance, ignoring the final result.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | sequence_ [ trace \"Hello, \", trace \" world!\" ]\n-- | ```\nsequence_ :: forall a f m. Applicative m => Foldable f => f (m a) -> m Unit\nsequence_ = traverse_ identity\n\n-- | Combines a collection of elements using the `Alt` operation.\noneOf :: forall f g a. Foldable f => Plus g => f (g a) -> g a\noneOf = foldr alt empty\n\n-- | Folds a structure into some `Plus`.\noneOfMap :: forall f g a b. Foldable f => Plus g => (a -> g b) -> f a -> g b\noneOfMap f = foldr (alt <<< f) empty\n\n-- | Fold a data structure, accumulating values in some `Monoid`,\n-- | combining adjacent elements using the specified separator.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > intercalate \", \" [\"Lorem\", \"ipsum\", \"dolor\"]\n-- | = \"Lorem, ipsum, dolor\"\n-- |\n-- | > intercalate \"*\" [\"a\", \"b\", \"c\"]\n-- | = \"a*b*c\"\n-- |\n-- | > intercalate [1] [[2, 3], [4, 5], [6, 7]]\n-- | = [2, 3, 1, 4, 5, 1, 6, 7]\n-- | ```\nintercalate :: forall f m. Foldable f => Monoid m => m -> f m -> m\nintercalate sep xs = (foldl go { init: true, acc: mempty } xs).acc\n  where\n  go { init: true } x = { init: false, acc: x }\n  go { acc: acc }   x = { init: false, acc: acc <> sep <> x }\n\n-- | `foldMap` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surroundMap \"*\" show []\n-- | = \"*\"\n-- |\n-- | > surroundMap \"*\" show [1]\n-- | = \"*1*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2]\n-- | = \"*1*2*\"\n-- |\n-- | > surroundMap \"*\" show [1, 2, 3]\n-- | = \"*1*2*3*\"\n-- | ```\nsurroundMap :: forall f a m. Foldable f => Semigroup m => m -> (a -> m) -> f a -> m\nsurroundMap d t f = unwrap (foldMap joined f) d\n  where joined a = Endo \\m -> d <> t a <> m\n\n-- | `fold` but with each element surrounded by some fixed value.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | > surround \"*\" []\n-- | = \"*\"\n-- |\n-- | > surround \"*\" [\"1\"]\n-- | = \"*1*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\"]\n-- | = \"*1*2*\"\n-- |\n-- | > surround \"*\" [\"1\", \"2\", \"3\"]\n-- | = \"*1*2*3*\"\n-- | ```\nsurround :: forall f m. Foldable f => Semigroup m => m -> f m -> m\nsurround d = surroundMap d identity\n\n-- | The conjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether all of the values in a data\n-- | structure are `true`.\nand :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nand = all identity\n\n-- | The disjunction of all the values in a data structure. When specialized\n-- | to `Boolean`, this function will test whether any of the values in a data\n-- | structure is `true`.\nor :: forall a f. Foldable f => HeytingAlgebra a => f a -> a\nor = any identity\n\n-- | `all f` is the same as `and <<< map f`; map a function over the structure,\n-- | and then get the conjunction of the results.\nall :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nall  = alaF Conj foldMap\n\n-- | `any f` is the same as `or <<< map f`; map a function over the structure,\n-- | and then get the disjunction of the results.\nany :: forall a b f. Foldable f => HeytingAlgebra b => (a -> b) -> f a -> b\nany = alaF Disj foldMap\n\n-- | Find the sum of the numeric values in a data structure.\nsum :: forall a f. Foldable f => Semiring a => f a -> a\nsum = foldl (+) zero\n\n-- | Find the product of the numeric values in a data structure.\nproduct :: forall a f. Foldable f => Semiring a => f a -> a\nproduct = foldl (*) one\n\n-- | Test whether a value is an element of a data structure.\nelem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nelem = any <<< (==)\n\n-- | Test whether a value is not an element of a data structure.\nnotElem :: forall a f. Foldable f => Eq a => a -> f a -> Boolean\nnotElem x = not <<< elem x\n\n-- | Try to get nth element from the left in a data structure\nindexl :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexl idx = _.elem <<< foldl go { elem: Nothing, pos: 0 }\n  where\n  go cursor a =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to get nth element from the right in a data structure\nindexr :: forall a f. Foldable f => Int -> f a -> Maybe a\nindexr idx = _.elem <<< foldr go { elem: Nothing, pos: 0 }\n  where\n  go a cursor =\n    case cursor.elem of\n      Just _ -> cursor\n      _ ->\n        if cursor.pos == idx\n          then { elem: Just a, pos: cursor.pos }\n          else { pos: cursor.pos + 1, elem: cursor.elem }\n\n-- | Try to find an element in a data structure which satisfies a predicate.\nfind :: forall a f. Foldable f => (a -> Boolean) -> f a -> Maybe a\nfind p = foldl go Nothing\n  where\n  go Nothing x | p x = Just x\n  go r _ = r\n\n-- | Try to find an element in a data structure which satisfies a predicate mapping.\nfindMap :: forall a b f. Foldable f => (a -> Maybe b) -> f a -> Maybe b\nfindMap p = foldl go Nothing\n  where\n  go Nothing x = p x\n  go r _ = r\n\n-- | Find the largest element of a structure, according to its `Ord` instance.\nmaximum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nmaximum = maximumBy compare\n\n-- | Find the largest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nmaximumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nmaximumBy cmp = foldl max' Nothing\n  where\n  max' Nothing x  = Just x\n  max' (Just x) y = Just (if cmp x y == GT then x else y)\n\n-- | Find the smallest element of a structure, according to its `Ord` instance.\nminimum :: forall a f. Ord a => Foldable f => f a -> Maybe a\nminimum = minimumBy compare\n\n-- | Find the smallest element of a structure, according to a given comparison\n-- | function. The comparison function should represent a total ordering (see\n-- | the `Ord` type class laws); if it does not, the behaviour is undefined.\nminimumBy :: forall a f. Foldable f => (a -> a -> Ordering) -> f a -> Maybe a\nminimumBy cmp = foldl min' Nothing\n  where\n  min' Nothing x  = Just x\n  min' (Just x) y = Just (if cmp x y == LT then x else y)\n\n-- | Test whether the structure is empty.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nnull :: forall a f. Foldable f => f a -> Boolean\nnull = foldr (\\_ _ -> false) true\n\n-- | Returns the size/length of a finite structure.\n-- | Optimized for structures that are similar to cons-lists, because there\n-- | is no general way to do better.\nlength :: forall a b f. Foldable f => Semiring b => f a -> b\nlength = foldl (\\c _ -> add one c) zero\n","\"use strict\";\n\nexports.foldrArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n      }\n      return acc;\n    };\n  };\n};\n\nexports.foldlArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n      }\n      return acc;\n    };\n  };\n};\n","module Data.EuclideanRing\n  ( class EuclideanRing, degree, div, mod, (/)\n  , gcd\n  , lcm\n  , module Data.CommutativeRing\n  , module Data.Ring\n  , module Data.Semiring\n  ) where\n\nimport Data.BooleanAlgebra ((||))\nimport Data.CommutativeRing (class CommutativeRing)\nimport Data.Eq (class Eq, (==))\nimport Data.Ring (class Ring, sub, (-))\nimport Data.Semiring (class Semiring, add, mul, one, zero, (*), (+))\n\n-- | The `EuclideanRing` class is for commutative rings that support division.\n-- | The mathematical structure this class is based on is sometimes also called\n-- | a *Euclidean domain*.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Ring`\n-- | laws:\n-- |\n-- | - Integral domain: `one /= zero`, and if `a` and `b` are both nonzero then\n-- |   so is their product `a * b`\n-- | - Euclidean function `degree`:\n-- |   - Nonnegativity: For all nonzero `a`, `degree a >= 0`\n-- |   - Quotient/remainder: For all `a` and `b`, where `b` is nonzero,\n-- |     let `q = a / b` and ``r = a `mod` b``; then `a = q*b + r`, and also\n-- |     either `r = zero` or `degree r < degree b`\n-- | - Submultiplicative euclidean function:\n-- |   - For all nonzero `a` and `b`, `degree a <= degree (a * b)`\n-- |\n-- | The behaviour of division by `zero` is unconstrained by these laws,\n-- | meaning that individual instances are free to choose how to behave in this\n-- | case. Similarly, there are no restrictions on what the result of\n-- | `degree zero` is; it doesn't make sense to ask for `degree zero` in the\n-- | same way that it doesn't make sense to divide by `zero`, so again,\n-- | individual instances may choose how to handle this case.\n-- |\n-- | For any `EuclideanRing` which is also a `Field`, one valid choice\n-- | for `degree` is simply `const 1`. In fact, unless there's a specific\n-- | reason not to, `Field` types should normally use this definition of\n-- | `degree`.\n-- |\n-- | The `EuclideanRing Int` instance is one of the most commonly used\n-- | `EuclideanRing` instances and deserves a little more discussion. In\n-- | particular, there are a few different sensible law-abiding implementations\n-- | to choose from, with slightly different behaviour in the presence of\n-- | negative dividends or divisors. The most common definitions are \"truncating\"\n-- | division, where the result of `a / b` is rounded towards 0, and \"Knuthian\"\n-- | or \"flooring\" division, where the result of `a / b` is rounded towards\n-- | negative infinity. A slightly less common, but arguably more useful, option\n-- | is \"Euclidean\" division, which is defined so as to ensure that ``a `mod` b``\n-- | is always nonnegative. With Euclidean division, `a / b` rounds towards\n-- | negative infinity if the divisor is positive, and towards positive infinity\n-- | if the divisor is negative. Note that all three definitions are identical if\n-- | we restrict our attention to nonnegative dividends and divisors.\n-- |\n-- | In versions 1.x, 2.x, and 3.x of the Prelude, the `EuclideanRing Int`\n-- | instance used truncating division. As of 4.x, the `EuclideanRing Int`\n-- | instance uses Euclidean division. Additional functions `quot` and `rem` are\n-- | supplied if truncating division is desired.\nclass CommutativeRing a <= EuclideanRing a where\n  degree :: a -> Int\n  div :: a -> a -> a\n  mod :: a -> a -> a\n\ninfixl 7 div as /\n\ninstance euclideanRingInt :: EuclideanRing Int where\n  degree = intDegree\n  div = intDiv\n  mod = intMod\n\ninstance euclideanRingNumber :: EuclideanRing Number where\n  degree _ = 1\n  div = numDiv\n  mod _ _ = 0.0\n\nforeign import intDegree :: Int -> Int\nforeign import intDiv :: Int -> Int -> Int\nforeign import intMod :: Int -> Int -> Int\n\nforeign import numDiv :: Number -> Number -> Number\n\n-- | The *greatest common divisor* of two values.\ngcd :: forall a. Eq a => EuclideanRing a => a -> a -> a\ngcd a b =\n  if b == zero\n    then a\n    else gcd b (a `mod` b)\n\n-- | The *least common multiple* of two values.\nlcm :: forall a. Eq a => EuclideanRing a => a -> a -> a\nlcm a b =\n  if a == zero || b == zero\n    then zero\n    else a * b / gcd a b\n","\"use strict\";\n\nexports.intDegree = function (x) {\n  return Math.min(Math.abs(x), 2147483647);\n};\n\n// See the Euclidean definition in\n// https://en.m.wikipedia.org/wiki/Modulo_operation.\nexports.intDiv = function (x) {\n  return function (y) {\n    if (y === 0) return 0;\n    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);\n  };\n};\n\nexports.intMod = function (x) {\n  return function (y) {\n    if (y === 0) return 0;\n    var yy = Math.abs(y);\n    return ((x % yy) + yy) % yy;\n  };\n};\n\nexports.numDiv = function (n1) {\n  return function (n2) {\n    return n1 / n2;\n  };\n};\n","module Data.Eq\n  ( class Eq, eq, (==), notEq, (/=)\n  , class Eq1, eq1, notEq1\n  , class EqRecord, eqRecord\n  ) where\n\nimport Data.HeytingAlgebra ((&&))\nimport Data.Symbol (class IsSymbol, SProxy(..), reflectSymbol)\nimport Data.Unit (Unit)\nimport Data.Void (Void)\nimport Prim.Row as Row\nimport Prim.RowList as RL\nimport Record.Unsafe (unsafeGet)\nimport Type.Data.RowList (RLProxy(..))\n\n-- | The `Eq` type class represents types which support decidable equality.\n-- |\n-- | `Eq` instances should satisfy the following laws:\n-- |\n-- | - Reflexivity: `x == x = true`\n-- | - Symmetry: `x == y = y == x`\n-- | - Transitivity: if `x == y` and `y == z` then `x == z`\n-- |\n-- | **Note:** The `Number` type is not an entirely law abiding member of this\n-- | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,\n-- | computing with `Number` can result in a loss of precision, so sometimes\n-- | values that should be equivalent are not.\nclass Eq a where\n  eq :: a -> a -> Boolean\n\ninfix 4 eq as ==\n\n-- | `notEq` tests whether one value is _not equal_ to another. Shorthand for\n-- | `not (eq x y)`.\nnotEq :: forall a. Eq a => a -> a -> Boolean\nnotEq x y = (x == y) == false\n\ninfix 4 notEq as /=\n\ninstance eqBoolean :: Eq Boolean where\n  eq = eqBooleanImpl\n\ninstance eqInt :: Eq Int where\n  eq = eqIntImpl\n\ninstance eqNumber :: Eq Number where\n  eq = eqNumberImpl\n\ninstance eqChar :: Eq Char where\n  eq = eqCharImpl\n\ninstance eqString :: Eq String where\n  eq = eqStringImpl\n\ninstance eqUnit :: Eq Unit where\n  eq _ _ = true\n\ninstance eqVoid :: Eq Void where\n  eq _ _ = true\n\ninstance eqArray :: Eq a => Eq (Array a) where\n  eq = eqArrayImpl eq\n\ninstance eqRec :: (RL.RowToList row list, EqRecord list row) => Eq (Record row) where\n  eq = eqRecord (RLProxy :: RLProxy list)\n\nforeign import eqBooleanImpl :: Boolean -> Boolean -> Boolean\nforeign import eqIntImpl :: Int -> Int -> Boolean\nforeign import eqNumberImpl :: Number -> Number -> Boolean\nforeign import eqCharImpl :: Char -> Char -> Boolean\nforeign import eqStringImpl :: String -> String -> Boolean\n\nforeign import eqArrayImpl :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Boolean\n\n-- | The `Eq1` type class represents type constructors with decidable equality.\nclass Eq1 f where\n  eq1 :: forall a. Eq a => f a -> f a -> Boolean\n\ninstance eq1Array :: Eq1 Array where\n  eq1 = eq\n\nnotEq1 :: forall f a. Eq1 f => Eq a => f a -> f a -> Boolean\nnotEq1 x y = (x `eq1` y) == false\n\n-- | A class for records where all fields have `Eq` instances, used to implement\n-- | the `Eq` instance for records.\nclass EqRecord rowlist row where\n  eqRecord :: RLProxy rowlist -> Record row -> Record row -> Boolean\n\ninstance eqRowNil :: EqRecord RL.Nil row where\n  eqRecord _ _ _ = true\n\ninstance eqRowCons\n    :: ( EqRecord rowlistTail row\n       , Row.Cons key focus rowTail row\n       , IsSymbol key\n       , Eq focus\n       )\n    => EqRecord (RL.Cons key focus rowlistTail) row where\n  eqRecord _ ra rb = (get ra == get rb) && tail\n    where\n      key = reflectSymbol (SProxy :: SProxy key)\n      get = unsafeGet key :: Record row -> focus\n      tail = eqRecord (RLProxy :: RLProxy rowlistTail) ra rb\n","\"use strict\";\n\nvar refEq = function (r1) {\n  return function (r2) {\n    return r1 === r2;\n  };\n};\n\nexports.eqBooleanImpl = refEq;\nexports.eqIntImpl = refEq;\nexports.eqNumberImpl = refEq;\nexports.eqCharImpl = refEq;\nexports.eqStringImpl = refEq;\n\nexports.eqArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      if (xs === ys) return true;\n      if (xs.length !== ys.length) return false;\n      for (var i = 0; i < xs.length; i++) {\n        if (!f(xs[i])(ys[i])) return false;\n      }\n      return true;\n    };\n  };\n};\n","module Data.Either where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Extend (class Extend)\nimport Data.Bifoldable (class Bifoldable)\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Bitraversable (class Bitraversable)\nimport Data.Eq (class Eq1)\nimport Data.Foldable (class Foldable)\nimport Data.FoldableWithIndex (class FoldableWithIndex)\nimport Data.Functor.Invariant (class Invariant, imapF)\nimport Data.FunctorWithIndex (class FunctorWithIndex)\nimport Data.Maybe (Maybe(..), maybe, maybe')\nimport Data.Ord (class Ord1)\nimport Data.Traversable (class Traversable)\nimport Data.TraversableWithIndex (class TraversableWithIndex)\n\n-- | The `Either` type is used to represent a choice between two types of value.\n-- |\n-- | A common use case for `Either` is error handling, where `Left` is used to\n-- | carry an error value and `Right` is used to carry a success value.\ndata Either a b = Left a | Right b\n\n-- | The `Functor` instance allows functions to transform the contents of a\n-- | `Right` with the `<$>` operator:\n-- |\n-- | ``` purescript\n-- | f <$> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are untouched:\n-- |\n-- | ``` purescript\n-- | f <$> Left y == Left y\n-- | ```\nderive instance functorEither :: Functor (Either a)\n\ninstance functorWithIndexEither :: FunctorWithIndex Unit (Either a) where\n  mapWithIndex f = map $ f unit\n\ninstance invariantEither :: Invariant (Either a) where\n  imap = imapF\n\ninstance bifunctorEither :: Bifunctor Either where\n  bimap f _ (Left l) = Left (f l)\n  bimap _ g (Right r) = Right (g r)\n\n-- | The `Apply` instance allows functions contained within a `Right` to\n-- | transform a value contained within a `Right` using the `(<*>)` operator:\n-- |\n-- | ``` purescript\n-- | Right f <*> Right x == Right (f x)\n-- | ```\n-- |\n-- | `Left` values are left untouched:\n-- |\n-- | ``` purescript\n-- | Left f <*> Right x == Left x\n-- | Right f <*> Left y == Left y\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a\n-- | pure function to take `Either`-typed arguments so `f :: a -> b -> c`\n-- | becomes `f :: Either l a -> Either l b -> Either l c`:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> Right y == Right (f x y)\n-- | ```\n-- |\n-- | The `Left`-preserving behaviour of both operators means the result of\n-- | an expression like the above but where any one of the values is `Left`\n-- | means the whole result becomes `Left` also, taking the first `Left` value\n-- | found:\n-- |\n-- | ``` purescript\n-- | f <$> Left x <*> Right y == Left x\n-- | f <$> Right x <*> Left y == Left y\n-- | f <$> Left x <*> Left y == Left x\n-- | ```\ninstance applyEither :: Apply (Either e) where\n  apply (Left e) _ = Left e\n  apply (Right f) r = f <$> r\n\n-- | The `Applicative` instance enables lifting of values into `Either` with the\n-- | `pure` function:\n-- |\n-- | ``` purescript\n-- | pure x :: Either _ _ == Right x\n-- | ```\n-- |\n-- | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s\n-- | `pure` can be used to pass a mixture of `Either` and non-`Either` typed\n-- | values to a function that does not usually expect them, by using `pure`\n-- | for any value that is not already `Either` typed:\n-- |\n-- | ``` purescript\n-- | f <$> Right x <*> pure y == Right (f x y)\n-- | ```\n-- |\n-- | Even though `pure = Right` it is recommended to use `pure` in situations\n-- | like this as it allows the choice of `Applicative` to be changed later\n-- | without having to go through and replace `Right` with a new constructor.\ninstance applicativeEither :: Applicative (Either e) where\n  pure = Right\n\n-- | The `Alt` instance allows for a choice to be made between two `Either`\n-- | values with the `<|>` operator, where the first `Right` encountered\n-- | is taken.\n-- |\n-- | ``` purescript\n-- | Right x <|> Right y == Right x\n-- | Left x <|> Right y == Right y\n-- | Left x <|> Left y == Left y\n-- | ```\ninstance altEither :: Alt (Either e) where\n  alt (Left _) r = r\n  alt l        _ = l\n\n-- | The `Bind` instance allows sequencing of `Either` values and functions that\n-- | return an `Either` by using the `>>=` operator:\n-- |\n-- | ``` purescript\n-- | Left x >>= f = Left x\n-- | Right x >>= f = f x\n-- | ```\ninstance bindEither :: Bind (Either e) where\n  bind = either (\\e _ -> Left e) (\\a f -> f a)\n\n-- | The `Monad` instance guarantees that there are both `Applicative` and\n-- | `Bind` instances for `Either`. This also enables the `do` syntactic sugar:\n-- |\n-- | ``` purescript\n-- | do\n-- |   x' <- x\n-- |   y' <- y\n-- |   pure (f x' y')\n-- | ```\n-- |\n-- | Which is equivalent to:\n-- |\n-- | ``` purescript\n-- | x >>= (\\x' -> y >>= (\\y' -> pure (f x' y')))\n-- | ```\ninstance monadEither :: Monad (Either e)\n\n-- | The `Extend` instance allows sequencing of `Either` values and functions\n-- | that accept an `Either` and return a non-`Either` result using the\n-- | `<<=` operator.\n-- |\n-- | ``` purescript\n-- | f <<= Left x = Left x\n-- | f <<= Right x = Right (f (Right x))\n-- | ```\ninstance extendEither :: Extend (Either e) where\n  extend _ (Left y)  = Left y\n  extend f x         = Right (f x)\n\n-- | The `Show` instance allows `Either` values to be rendered as a string with\n-- | `show` whenever there is an `Show` instance for both type the `Either` can\n-- | contain.\ninstance showEither :: (Show a, Show b) => Show (Either a b) where\n  show (Left x) = \"(Left \" <> show x <> \")\"\n  show (Right y) = \"(Right \" <> show y <> \")\"\n\n-- | The `Eq` instance allows `Either` values to be checked for equality with\n-- | `==` and inequality with `/=` whenever there is an `Eq` instance for both\n-- | types the `Either` can contain.\nderive instance eqEither :: (Eq a, Eq b) => Eq (Either a b)\n\nderive instance eq1Either :: Eq a => Eq1 (Either a)\n\n-- | The `Ord` instance allows `Either` values to be compared with\n-- | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for\n-- | both types the `Either` can contain.\n-- |\n-- | Any `Left` value is considered to be less than a `Right` value.\nderive instance ordEither :: (Ord a, Ord b) => Ord (Either a b)\n\nderive instance ord1Either :: Ord a => Ord1 (Either a)\n\ninstance boundedEither :: (Bounded a, Bounded b) => Bounded (Either a b) where\n  top = Right top\n  bottom = Left bottom\n\ninstance foldableEither :: Foldable (Either a) where\n  foldr _ z (Left _)  = z\n  foldr f z (Right x) = f x z\n  foldl _ z (Left _)  = z\n  foldl f z (Right x) = f z x\n  foldMap f (Left _)  = mempty\n  foldMap f (Right x) = f x\n\ninstance foldableWithIndexEither :: FoldableWithIndex Unit (Either a) where\n  foldrWithIndex _ z (Left _)  = z\n  foldrWithIndex f z (Right x) = f unit x z\n  foldlWithIndex _ z (Left _)  = z\n  foldlWithIndex f z (Right x) = f unit z x\n  foldMapWithIndex f (Left _)  = mempty\n  foldMapWithIndex f (Right x) = f unit x\n\ninstance bifoldableEither :: Bifoldable Either where\n  bifoldr f _ z (Left a) = f a z\n  bifoldr _ g z (Right b) = g b z\n  bifoldl f _ z (Left a) = f z a\n  bifoldl _ g z (Right b) = g z b\n  bifoldMap f _ (Left a) = f a\n  bifoldMap _ g (Right b) = g b\n\ninstance traversableEither :: Traversable (Either a) where\n  traverse _ (Left x)  = pure (Left x)\n  traverse f (Right x) = Right <$> f x\n  sequence (Left x) = pure (Left x)\n  sequence (Right x)  = Right <$> x\n\ninstance traversableWithIndexEither :: TraversableWithIndex Unit (Either a) where\n  traverseWithIndex _ (Left x)  = pure (Left x)\n  traverseWithIndex f (Right x) = Right <$> f unit x\n\ninstance bitraversableEither :: Bitraversable Either where\n  bitraverse f _ (Left a) = Left <$> f a\n  bitraverse _ g (Right b) = Right <$> g b\n  bisequence (Left a) = Left <$> a\n  bisequence (Right b) = Right <$> b\n\ninstance semigroupEither :: (Semigroup b) => Semigroup (Either a b) where\n  append x y = append <$> x <*> y\n\n-- | Takes two functions and an `Either` value, if the value is a `Left` the\n-- | inner value is applied to the first function, if the value is a `Right`\n-- | the inner value is applied to the second function.\n-- |\n-- | ``` purescript\n-- | either f g (Left x) == f x\n-- | either f g (Right y) == g y\n-- | ```\neither :: forall a b c. (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n-- | Combine two alternatives.\nchoose :: forall m a b. Alt m => m a -> m b -> m (Either a b)\nchoose a b = Left <$> a <|> Right <$> b\n\n-- | Returns `true` when the `Either` value was constructed with `Left`.\nisLeft :: forall a b. Either a b -> Boolean\nisLeft = either (const true) (const false)\n\n-- | Returns `true` when the `Either` value was constructed with `Right`.\nisRight :: forall a b. Either a b -> Boolean\nisRight = either (const false) (const true)\n\n-- | A partial function that extracts the value from the `Left` data constructor.\n-- | Passing a `Right` to `fromLeft` will throw an error at runtime.\nfromLeft :: forall a b. Partial => Either a b -> a\nfromLeft (Left a) = a\n\n-- | A partial function that extracts the value from the `Right` data constructor.\n-- | Passing a `Left` to `fromRight` will throw an error at runtime.\nfromRight :: forall a b. Partial => Either a b -> b\nfromRight (Right a) = a\n\n-- | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into\n-- | a `Right`, if the value is a `Nothing` use the provided default as a `Left`\n-- |\n-- | ```purescript\n-- | note \"default\" Nothing = Left \"default\"\n-- | note \"default\" (Just 1) = Right 1\n-- | ```\nnote :: forall a b. a -> Maybe b -> Either a b\nnote a = maybe (Left a) Right\n\n-- | Similar to `note`, but for use in cases where the default value may be\n-- | expensive to compute.\n-- |\n-- | ```purescript\n-- | note' (\\_ -> \"default\") Nothing = Left \"default\"\n-- | note' (\\_ -> \"default\") (Just 1) = Right 1\n-- | ```\nnote' :: forall a b. (Unit -> a) -> Maybe b -> Either a b\nnote' f = maybe' (Left <<< f) Right\n\n-- | Turns an `Either` into a `Maybe`, by throwing eventual `Left` values away and converting\n-- | them into `Nothing`. `Right` values get turned into `Just`s.\n-- |\n-- | ```purescript\n-- | hush (Left \"ParseError\") = Nothing\n-- | hush (Right 42) = Just 42\n-- | ```\nhush :: forall a b. Either a b -> Maybe b\nhush = either (const Nothing) Just\n","module Data.DivisionRing\n  ( class DivisionRing\n  , recip\n  , leftDiv\n  , rightDiv\n  , module Data.Ring\n  , module Data.Semiring\n  ) where\n\nimport Data.EuclideanRing ((/))\nimport Data.Ring (class Ring, negate, sub)\nimport Data.Semiring (class Semiring, add, mul, one, zero, (*), (+))\n\n-- | The `DivisionRing` class is for non-zero rings in which every non-zero\n-- | element has a multiplicative inverse. Division rings are sometimes also\n-- | called *skew fields*.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Ring` laws:\n-- |\n-- | - Non-zero ring: `one /= zero`\n-- | - Non-zero multiplicative inverse: `recip a * a = a * recip a = one` for\n-- |   all non-zero `a`\n-- |\n-- | The result of `recip zero` is left undefined; individual instances may\n-- | choose how to handle this case.\n-- |\n-- | If a type has both `DivisionRing` and `CommutativeRing` instances, then\n-- | it is a field and should have a `Field` instance.\nclass Ring a <= DivisionRing a where\n  recip :: a -> a\n\n-- | Left division, defined as `leftDiv a b = recip b * a`. Left and right\n-- | division are distinct in this module because a `DivisionRing` is not\n-- | necessarily commutative.\n-- |\n-- | If the type `a` is also a `EuclideanRing`, then this function is\n-- | equivalent to `div` from the `EuclideanRing` class. When working\n-- | abstractly, `div` should generally be preferred, unless you know that you\n-- | need your code to work with noncommutative rings.\nleftDiv :: forall a. DivisionRing a => a -> a -> a\nleftDiv a b = recip b * a\n\n-- | Right division, defined as `rightDiv a b = a * recip b`. Left and right\n-- | division are distinct in this module because a `DivisionRing` is not\n-- | necessarily commutative.\n-- |\n-- | If the type `a` is also a `EuclideanRing`, then this function is\n-- | equivalent to `div` from the `EuclideanRing` class. When working\n-- | abstractly, `div` should generally be preferred, unless you know that you\n-- | need your code to work with noncommutative rings.\nrightDiv :: forall a. DivisionRing a => a -> a -> a\nrightDiv a b = a * recip b\n\ninstance divisionringNumber :: DivisionRing Number where\n  recip x = 1.0 / x\n","module Data.Distributive where\n\nimport Prelude\n\nimport Data.Identity (Identity(..))\nimport Data.Newtype (unwrap)\n\n-- | Categorical dual of `Traversable`:\n-- |\n-- | - `distribute` is the dual of `sequence` - it zips an arbitrary collection\n-- |   of containers.\n-- | - `collect` is the dual of `traverse` - it traverses an arbitrary\n-- |   collection of values.\n-- |\n-- | Laws:\n-- |\n-- | - `distribute = collect identity`\n-- | - `distribute <<< distribute = identity`\n-- | - `collect f = distribute <<< map f`\n-- | - `map f = unwrap <<< collect (Identity <<< f)`\n-- | - `map distribute <<< collect f = unwrap <<< collect (Compose <<< f)`\nclass Functor f <= Distributive f where\n  distribute :: forall a g. Functor g => g (f a) -> f (g a)\n  collect :: forall a b g. Functor g => (a -> f b) -> g a -> f (g b)\n\ninstance distributiveIdentity :: Distributive Identity where\n  distribute = Identity <<< map unwrap\n  collect f = Identity <<< map (unwrap <<< f)\n\ninstance distributiveFunction :: Distributive ((->) e) where\n  distribute a e = map (_ $ e) a\n  collect f = distribute <<< map f\n\n-- | A default implementation of `distribute`, based on `collect`.\ndistributeDefault\n  :: forall a f g\n   . Distributive f\n  => Functor g\n  => g (f a)\n  -> f (g a)\ndistributeDefault = collect identity\n\n-- | A default implementation of `collect`, based on `distribute`.\ncollectDefault\n  :: forall a b f g\n   . Distributive f\n  => Functor g\n  => (a -> f b)\n  -> g a\n  -> f (g b)\ncollectDefault f = distribute <<< map f\n\n-- | Zip an arbitrary collection of containers and summarize the results\ncotraverse\n  :: forall a b f g\n   . Distributive f\n  => Functor g\n  => (g a -> b)\n  -> g (f a)\n  -> f b\ncotraverse f = map f <<< distribute\n","module Data.CommutativeRing\n  ( class CommutativeRing\n  , module Data.Ring\n  , module Data.Semiring\n  , class CommutativeRingRecord\n  ) where\n\nimport Data.Ring (class Ring, class RingRecord)\nimport Data.Semiring (class Semiring, add, mul, one, zero, (*), (+))\nimport Data.Symbol (class IsSymbol)\nimport Data.Unit (Unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\n\n-- | The `CommutativeRing` class is for rings where multiplication is\n-- | commutative.\n-- |\n-- | Instances must satisfy the following law in addition to the `Ring`\n-- | laws:\n-- |\n-- | - Commutative multiplication: `a * b = b * a`\nclass Ring a <= CommutativeRing a\n\ninstance commutativeRingInt :: CommutativeRing Int\ninstance commutativeRingNumber :: CommutativeRing Number\ninstance commutativeRingUnit :: CommutativeRing Unit\ninstance commutativeRingFn :: CommutativeRing b => CommutativeRing (a -> b)\ninstance commutativeRingRecord :: (RL.RowToList row list, CommutativeRingRecord list row row) => CommutativeRing (Record row)\n\n-- | A class for records where all fields have `CommutativeRing` instances, used\n-- | to implement the `CommutativeRing` instance for records.\nclass RingRecord rowlist row subrow <= CommutativeRingRecord rowlist row subrow | rowlist -> subrow\n\ninstance commutativeRingRecordNil :: CommutativeRingRecord RL.Nil row ()\n\ninstance commutativeRingRecordCons\n    :: ( IsSymbol key\n       , Row.Cons key focus subrowTail subrow\n       , CommutativeRingRecord rowlistTail row subrowTail\n       , CommutativeRing focus\n       )\n    => CommutativeRingRecord (RL.Cons key focus rowlistTail) row subrow\n","module Data.Bounded\n  ( class Bounded\n  , bottom\n  , top\n  , module Data.Ord\n  ) where\n\nimport Data.Ord (class Ord, Ordering(..), compare, (<), (<=), (>), (>=))\nimport Data.Unit (Unit, unit)\n\n-- | The `Bounded` type class represents totally ordered types that have an\n-- | upper and lower boundary.\n-- |\n-- | Instances should satisfy the following law in addition to the `Ord` laws:\n-- |\n-- | - Bounded: `bottom <= a <= top`\nclass Ord a <= Bounded a where\n  top :: a\n  bottom :: a\n\ninstance boundedBoolean :: Bounded Boolean where\n  top = true\n  bottom = false\n\n-- | The `Bounded` `Int` instance has `top :: Int` equal to 2^31 - 1,\n-- | and `bottom :: Int` equal to -2^31, since these are the largest and smallest\n-- | integers representable by twos-complement 32-bit integers, respectively.\ninstance boundedInt :: Bounded Int where\n  top = topInt\n  bottom = bottomInt\n\nforeign import topInt :: Int\nforeign import bottomInt :: Int\n\n-- | Characters fall within the Unicode range.\ninstance boundedChar :: Bounded Char where\n  top = topChar\n  bottom = bottomChar\n\nforeign import topChar :: Char\nforeign import bottomChar :: Char\n\ninstance boundedOrdering :: Bounded Ordering where\n  top = GT\n  bottom = LT\n\ninstance boundedUnit :: Bounded Unit where\n  top = unit\n  bottom = unit\n\nforeign import topNumber :: Number\nforeign import bottomNumber :: Number\n\ninstance boundedNumber :: Bounded Number where\n  top = topNumber\n  bottom = bottomNumber\n","\"use strict\";\n\nexports.topInt = 2147483647;\nexports.bottomInt = -2147483648;\n\nexports.topChar = String.fromCharCode(65535);\nexports.bottomChar = String.fromCharCode(0);\n\nexports.topNumber = Number.POSITIVE_INFINITY;\nexports.bottomNumber = Number.NEGATIVE_INFINITY;\n","module Data.BooleanAlgebra\n  ( class BooleanAlgebra\n  , module Data.HeytingAlgebra\n  , class BooleanAlgebraRecord\n  ) where\n\nimport Data.HeytingAlgebra (class HeytingAlgebra, class HeytingAlgebraRecord, ff, tt, implies, conj, disj, not, (&&), (||))\nimport Data.Symbol (class IsSymbol)\nimport Data.Unit (Unit)\nimport Prim.Row as Row\nimport Prim.RowList as RL\n\n-- | The `BooleanAlgebra` type class represents types that behave like boolean\n-- | values.\n-- |\n-- | Instances should satisfy the following laws in addition to the\n-- | `HeytingAlgebra` law:\n-- |\n-- | - Excluded middle:\n-- |   - `a || not a = tt`\nclass HeytingAlgebra a <= BooleanAlgebra a\n\ninstance booleanAlgebraBoolean :: BooleanAlgebra Boolean\ninstance booleanAlgebraUnit :: BooleanAlgebra Unit\ninstance booleanAlgebraFn :: BooleanAlgebra b => BooleanAlgebra (a -> b)\ninstance booleanAlgebraRecord :: (RL.RowToList row list, BooleanAlgebraRecord list row row) => BooleanAlgebra (Record row)\n\n-- | A class for records where all fields have `BooleanAlgebra` instances, used\n-- | to implement the `BooleanAlgebra` instance for records.\nclass HeytingAlgebraRecord rowlist row subrow <= BooleanAlgebraRecord rowlist row subrow | rowlist -> subrow\n\ninstance booleanAlgebraRecordNil :: BooleanAlgebraRecord RL.Nil row ()\n\ninstance booleanAlgebraRecordCons\n    :: ( IsSymbol key\n       , Row.Cons key focus subrowTail subrow\n       , BooleanAlgebraRecord rowlistTail row subrowTail\n       , BooleanAlgebra focus\n       )\n    => BooleanAlgebraRecord (RL.Cons key focus rowlistTail) row subrow\n","module Data.Boolean where\n\n-- | An alias for `true`, which can be useful in guard clauses:\n-- |\n-- | ```purescript\n-- | max x y | x >= y    = x\n-- |         | otherwise = y\n-- | ```\notherwise :: Boolean\notherwise = true\n","module Data.Bitraversable\n  ( class Bitraversable, bitraverse, bisequence\n  , bitraverseDefault\n  , bisequenceDefault\n  , ltraverse\n  , rtraverse\n  , bifor\n  , lfor\n  , rfor\n  , module Data.Bifoldable\n  ) where\n\nimport Prelude\n\nimport Data.Bifoldable (class Bifoldable, biall, biany, bifold, bifoldMap, bifoldMapDefaultL, bifoldMapDefaultR, bifoldl, bifoldlDefault, bifoldr, bifoldrDefault, bifor_, bisequence_, bitraverse_)\nimport Data.Traversable (class Traversable, traverse, sequence)\nimport Data.Bifunctor (class Bifunctor, bimap)\nimport Data.Bifunctor.Clown (Clown(..))\nimport Data.Bifunctor.Joker (Joker(..))\nimport Data.Bifunctor.Flip (Flip(..))\nimport Data.Bifunctor.Product (Product(..))\nimport Data.Bifunctor.Wrap (Wrap(..))\n\n-- | `Bitraversable` represents data structures with two type arguments which can be\n-- | traversed.\n-- |\n-- | A traversal for such a structure requires two functions, one for each type\n-- | argument. Type class instances should choose the appropriate function based\n-- | on the type of the element encountered at each point of the traversal.\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `bitraverseDefault`\n-- | - `bisequenceDefault`\nclass (Bifunctor t, Bifoldable t) <= Bitraversable t where\n  bitraverse :: forall f a b c d. Applicative f => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)\n  bisequence :: forall f a b. Applicative f => t (f a) (f b) -> f (t a b)\n\ninstance bitraversableClown :: Traversable f => Bitraversable (Clown f) where\n  bitraverse l _ (Clown f) = Clown <$> traverse l f\n  bisequence (Clown f) = Clown <$> sequence f\n\ninstance bitraversableJoker :: Traversable f => Bitraversable (Joker f) where\n  bitraverse _ r (Joker f) = Joker <$> traverse r f\n  bisequence (Joker f) = Joker <$> sequence f\n\ninstance bitraversableFlip :: Bitraversable p => Bitraversable (Flip p) where\n  bitraverse r l (Flip p) = Flip <$> bitraverse l r p\n  bisequence (Flip p) = Flip <$> bisequence p\n\ninstance bitraversableProduct :: (Bitraversable f, Bitraversable g) => Bitraversable (Product f g) where\n  bitraverse l r (Product f g) = Product <$> bitraverse l r f <*> bitraverse l r g\n  bisequence (Product f g) = Product <$> bisequence f <*> bisequence g\n\ninstance bitraversableWrap :: Bitraversable p => Bitraversable (Wrap p) where\n  bitraverse l r (Wrap p) = Wrap <$> bitraverse l r p\n  bisequence (Wrap p) = Wrap <$> bisequence p\n\nltraverse\n  :: forall t b c a f\n   . Bitraversable t\n  => Applicative f\n  => (a -> f c)\n  -> t a b\n  -> f (t c b)\nltraverse f = bitraverse f pure\n\nrtraverse\n  :: forall t b c a f\n   . Bitraversable t\n  => Applicative f\n  => (b -> f c)\n  -> t a b\n  -> f (t a c)\nrtraverse = bitraverse pure\n\n-- | A default implementation of `bitraverse` using `bisequence` and `bimap`.\nbitraverseDefault\n  :: forall t f a b c d\n   . Bitraversable t\n  => Applicative f\n  => (a -> f c)\n  -> (b -> f d)\n  -> t a b\n  -> f (t c d)\nbitraverseDefault f g t = bisequence (bimap f g t)\n\n-- | A default implementation of `bisequence` using `bitraverse`.\nbisequenceDefault\n  :: forall t f a b\n   . Bitraversable t\n  => Applicative f\n  => t (f a) (f b)\n  -> f (t a b)\nbisequenceDefault = bitraverse identity identity\n\n-- | Traverse a data structure, accumulating effects and results using an `Applicative` functor.\nbifor\n  :: forall t f a b c d\n   . Bitraversable t\n  => Applicative f\n  => t a b\n  -> (a -> f c)\n  -> (b -> f d)\n  -> f (t c d)\nbifor t f g = bitraverse f g t\n\nlfor\n  :: forall t b c a f\n   . Bitraversable t\n  => Applicative f\n  => t a b\n  -> (a -> f c)\n  -> f (t c b)\nlfor t f = bitraverse f pure t\n\nrfor\n  :: forall t b c a f\n   . Bitraversable t\n  => Applicative f\n  => t a b\n  -> (b -> f c)\n  -> f (t a c)\nrfor t f = bitraverse pure f t\n","module Data.Bifunctor where\n\nimport Control.Category (identity)\n\n-- | A `Bifunctor` is a `Functor` from the pair category `(Type, Type)` to `Type`.\n-- |\n-- | A type constructor with two type arguments can be made into a `Bifunctor` if\n-- | both of its type arguments are covariant.\n-- |\n-- | The `bimap` function maps a pair of functions over the two type arguments\n-- | of the bifunctor.\n-- |\n-- | Laws:\n-- |\n-- | - Identity: `bimap identity identity == identity`\n-- | - Composition: `bimap f1 g1 <<< bimap f2 g2 == bimap (f1 <<< f2) (g1 <<< g2)`\n-- |\nclass Bifunctor f where\n  bimap :: forall a b c d. (a -> b) -> (c -> d) -> f a c -> f b d\n\n-- | Map a function over the first type argument of a `Bifunctor`.\nlmap :: forall f a b c. Bifunctor f => (a -> b) -> f a c -> f b c\nlmap f = bimap f identity\n\n-- | Map a function over the second type arguments of a `Bifunctor`.\nrmap :: forall f a b c. Bifunctor f => (b -> c) -> f a b -> f a c\nrmap = bimap identity\n","module Data.Bifunctor.Wrap where\n\nimport Prelude\n\nimport Control.Biapplicative (class Biapplicative, bipure)\nimport Control.Biapply (class Biapply, (<<*>>))\n\nimport Data.Bifunctor (class Bifunctor, bimap, rmap)\nimport Data.Newtype (class Newtype)\n\n-- | Provides a `Functor` over the second argument of a `Bifunctor`.\nnewtype Wrap p a b = Wrap (p a b)\n\nderive instance newtypeWrap :: Newtype (Wrap p a b) _\n\nderive newtype instance eqWrap :: Eq (p a b) => Eq (Wrap p a b)\n\nderive newtype instance ordWrap :: Ord (p a b) => Ord (Wrap p a b)\n\ninstance showWrap :: Show (p a b) => Show (Wrap p a b) where\n  show (Wrap x) = \"(Wrap \" <> show x <> \")\"\n\ninstance functorWrap :: Bifunctor p => Functor (Wrap p a) where\n  map f (Wrap a) = Wrap (rmap f a)\n\ninstance bifunctorWrap :: Bifunctor p => Bifunctor (Wrap p) where\n  bimap f g (Wrap a) = Wrap (bimap f g a)\n\ninstance biapplyWrap :: Biapply p => Biapply (Wrap p) where\n  biapply (Wrap fg) (Wrap xy) = Wrap (fg <<*>> xy)\n\ninstance biapplicativeWrap :: Biapplicative p => Biapplicative (Wrap p) where\n  bipure a b = Wrap (bipure a b)\n","module Data.Bifunctor.Product where\n\nimport Prelude\n\nimport Control.Biapplicative (class Biapplicative, bipure)\nimport Control.Biapply (class Biapply, biapply)\n\nimport Data.Bifunctor (class Bifunctor, bimap)\n\n-- | The product of two `Bifunctor`s.\ndata Product f g a b = Product (f a b) (g a b)\n\nderive instance eqProduct :: (Eq (f a b), Eq (g a b)) => Eq (Product f g a b)\n\nderive instance ordProduct :: (Ord (f a b), Ord (g a b)) => Ord (Product f g a b)\n\ninstance showProduct :: (Show (f a b), Show (g a b)) => Show (Product f g a b) where\n  show (Product x y) = \"(Product \" <> show x <> \" \" <> show y <> \")\"\n\ninstance bifunctorProduct :: (Bifunctor f, Bifunctor g) => Bifunctor (Product f g) where\n  bimap f g (Product x y) = Product (bimap f g x) (bimap f g y)\n\ninstance biapplyProduct :: (Biapply f, Biapply g) => Biapply (Product f g) where\n  biapply (Product w x) (Product y z) = Product (biapply w y) (biapply x z)\n\ninstance biapplicativeProduct :: (Biapplicative f, Biapplicative g) => Biapplicative (Product f g) where\n  bipure a b = Product (bipure a b) (bipure a b)\n","module Data.Bifunctor.Joker where\n\nimport Prelude\n\nimport Control.Biapplicative (class Biapplicative)\nimport Control.Biapply (class Biapply)\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Newtype (class Newtype)\n\n-- | Make a `Functor` over the second argument of a `Bifunctor`\nnewtype Joker g a b = Joker (g b)\n\nderive instance newtypeJoker :: Newtype (Joker g a b) _\n\nderive newtype instance eqJoker :: Eq (g b) => Eq (Joker g a b)\n\nderive newtype instance ordJoker :: Ord (g b) => Ord (Joker g a b)\n\ninstance showJoker :: Show (g b) => Show (Joker g a b) where\n  show (Joker x) = \"(Joker \" <> show x <> \")\"\n\ninstance functorJoker :: Functor g => Functor (Joker g a) where\n  map g (Joker a) = Joker (map g a)\n\ninstance bifunctorJoker :: Functor g => Bifunctor (Joker g) where\n  bimap _ g (Joker a) = Joker (map g a)\n\ninstance biapplyJoker :: Apply g => Biapply (Joker g) where\n  biapply (Joker fg) (Joker xy) = Joker (fg <*> xy)\n\ninstance biapplicativeJoker :: Applicative g => Biapplicative (Joker g) where\n  bipure _ b = Joker (pure b)\n","module Data.Bifunctor.Flip where\n\nimport Prelude\n\nimport Control.Biapplicative (class Biapplicative, bipure)\nimport Control.Biapply (class Biapply, (<<*>>))\n\nimport Data.Bifunctor (class Bifunctor, bimap, lmap)\nimport Data.Newtype (class Newtype)\n\n-- | Flips the order of the type arguments of a `Bifunctor`.\nnewtype Flip p a b = Flip (p b a)\n\nderive instance newtypeFlip :: Newtype (Flip p a b) _\n\nderive newtype instance eqFlip :: Eq (p b a) => Eq (Flip p a b)\n\nderive newtype instance ordFlip :: Ord (p b a) => Ord (Flip p a b)\n\ninstance showFlip :: Show (p a b) => Show (Flip p b a) where\n  show (Flip x) = \"(Flip \" <> show x <> \")\"\n\ninstance functorFlip :: Bifunctor p => Functor (Flip p a) where\n  map f (Flip a) = Flip (lmap f a)\n\ninstance bifunctorFlip :: Bifunctor p => Bifunctor (Flip p) where\n  bimap f g (Flip a) = Flip (bimap g f a)\n\ninstance biapplyFlip :: Biapply p => Biapply (Flip p) where\n  biapply (Flip fg) (Flip xy) = Flip (fg <<*>> xy)\n\ninstance biapplicativeFlip :: Biapplicative p => Biapplicative (Flip p) where\n  bipure a b = Flip (bipure b a)\n","module Data.Bifunctor.Clown where\n\nimport Prelude\n\nimport Control.Biapplicative (class Biapplicative)\nimport Control.Biapply (class Biapply)\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Newtype (class Newtype)\n\n-- | Make a `Functor` over the first argument of a `Bifunctor`\nnewtype Clown f a b = Clown (f a)\n\nderive instance newtypeClown :: Newtype (Clown f a b) _\n\nderive newtype instance eqClown :: Eq (f a) => Eq (Clown f a b)\n\nderive newtype instance ordClown :: Ord (f a) => Ord (Clown f a b)\n\ninstance showClown :: Show (f a) => Show (Clown f a b) where\n  show (Clown x) = \"(Clown \" <> show x <> \")\"\n\ninstance functorClown :: Functor (Clown f a) where\n  map _ (Clown a) = Clown a\n\ninstance bifunctorClown :: Functor f => Bifunctor (Clown f) where\n  bimap f _ (Clown a) = Clown (map f a)\n\ninstance biapplyClown :: Apply f => Biapply (Clown f) where\n  biapply (Clown fg) (Clown xy) = Clown (fg <*> xy)\n\ninstance biapplicativeClown :: Applicative f => Biapplicative (Clown f) where\n  bipure a _ = Clown (pure a)\n","module Data.Bifoldable where\n\nimport Prelude\n\nimport Control.Apply (applySecond)\nimport Data.Monoid.Conj (Conj(..))\nimport Data.Monoid.Disj (Disj(..))\nimport Data.Monoid.Dual (Dual(..))\nimport Data.Monoid.Endo (Endo(..))\nimport Data.Newtype (unwrap)\nimport Data.Foldable (class Foldable, foldr, foldl, foldMap)\nimport Data.Bifunctor.Clown (Clown(..))\nimport Data.Bifunctor.Joker (Joker(..))\nimport Data.Bifunctor.Flip (Flip(..))\nimport Data.Bifunctor.Product (Product(..))\nimport Data.Bifunctor.Wrap (Wrap(..))\n\n-- | `Bifoldable` represents data structures with two type arguments which can be\n-- | folded.\n-- |\n-- | A fold for such a structure requires two step functions, one for each type\n-- | argument. Type class instances should choose the appropriate step function based\n-- | on the type of the element encountered at each point of the fold.\n-- |\n-- | Default implementations are provided by the following functions:\n-- |\n-- | - `bifoldrDefault`\n-- | - `bifoldlDefault`\n-- | - `bifoldMapDefaultR`\n-- | - `bifoldMapDefaultL`\n-- |\n-- | Note: some combinations of the default implementations are unsafe to\n-- | use together - causing a non-terminating mutually recursive cycle.\n-- | These combinations are documented per function.\nclass Bifoldable p where\n  bifoldr :: forall a b c. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c\n  bifoldl :: forall a b c. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c\n  bifoldMap :: forall m a b. Monoid m => (a -> m) -> (b -> m) -> p a b -> m\n\ninstance bifoldableClown :: Foldable f => Bifoldable (Clown f) where\n  bifoldr l _ u (Clown f) = foldr l u f\n  bifoldl l _ u (Clown f) = foldl l u f\n  bifoldMap l _ (Clown f) = foldMap l f\n\ninstance bifoldableJoker :: Foldable f => Bifoldable (Joker f) where\n  bifoldr _ r u (Joker f) = foldr r u f\n  bifoldl _ r u (Joker f) = foldl r u f\n  bifoldMap _ r (Joker f) = foldMap r f\n\ninstance bifoldableFlip :: Bifoldable p => Bifoldable (Flip p) where\n  bifoldr r l u (Flip p) = bifoldr l r u p\n  bifoldl r l u (Flip p) = bifoldl l r u p\n  bifoldMap r l (Flip p) = bifoldMap l r p\n\ninstance bifoldableProduct :: (Bifoldable f, Bifoldable g) => Bifoldable (Product f g) where\n  bifoldr l r u m = bifoldrDefault l r u m\n  bifoldl l r u m = bifoldlDefault l r u m\n  bifoldMap l r (Product f g) = bifoldMap l r f <> bifoldMap l r g\n\ninstance bifoldableWrap :: Bifoldable p => Bifoldable (Wrap p) where\n  bifoldr l r u (Wrap p) = bifoldr l r u p\n  bifoldl l r u (Wrap p) = bifoldl l r u p\n  bifoldMap l r (Wrap p) = bifoldMap l r p\n\n-- | A default implementation of `bifoldr` using `bifoldMap`.\n-- |\n-- | Note: when defining a `Bifoldable` instance, this function is unsafe to\n-- | use in combination with `bifoldMapDefaultR`.\nbifoldrDefault\n  :: forall p a b c\n   . Bifoldable p\n  => (a -> c -> c)\n  -> (b -> c -> c)\n  -> c\n  -> p a b\n  -> c\nbifoldrDefault f g z p = unwrap (bifoldMap (Endo <<< f) (Endo <<< g) p) z\n\n-- | A default implementation of `bifoldl` using `bifoldMap`.\n-- |\n-- | Note: when defining a `Bifoldable` instance, this function is unsafe to\n-- | use in combination with `bifoldMapDefaultL`.\nbifoldlDefault\n  :: forall p a b c\n   . Bifoldable p\n  => (c -> a -> c)\n  -> (c -> b -> c)\n  -> c\n  -> p a b\n  -> c\nbifoldlDefault f g z p =\n  unwrap\n    (unwrap\n      (bifoldMap (Dual <<< Endo <<< flip f) (Dual <<< Endo <<< flip g) p))\n    z\n\n-- | A default implementation of `bifoldMap` using `bifoldr`.\n-- |\n-- | Note: when defining a `Bifoldable` instance, this function is unsafe to\n-- | use in combination with `bifoldrDefault`.\nbifoldMapDefaultR\n  :: forall p m a b\n   . Bifoldable p\n  => Monoid m\n  => (a -> m)\n  -> (b -> m)\n  -> p a b\n  -> m\nbifoldMapDefaultR f g = bifoldr (append <<< f) (append <<< g) mempty\n\n-- | A default implementation of `bifoldMap` using `bifoldl`.\n-- |\n-- | Note: when defining a `Bifoldable` instance, this function is unsafe to\n-- | use in combination with `bifoldlDefault`.\nbifoldMapDefaultL\n  :: forall p m a b\n   . Bifoldable p\n  => Monoid m\n  => (a -> m)\n  -> (b -> m)\n  -> p a b\n  -> m\nbifoldMapDefaultL f g = bifoldl (\\m a -> m <> f a) (\\m b -> m <> g b) mempty\n\n\n-- | Fold a data structure, accumulating values in a monoidal type.\nbifold :: forall t m. Bifoldable t => Monoid m => t m m -> m\nbifold = bifoldMap identity identity\n\n-- | Traverse a data structure, accumulating effects using an `Applicative` functor,\n-- | ignoring the final result.\nbitraverse_\n  :: forall t f a b c d\n   . Bifoldable t\n  => Applicative f\n  => (a -> f c)\n  -> (b -> f d)\n  -> t a b\n  -> f Unit\nbitraverse_ f g = bifoldr (applySecond <<< f) (applySecond <<< g) (pure unit)\n\n-- | A version of `bitraverse_` with the data structure as the first argument.\nbifor_\n  :: forall t f a b c d\n   . Bifoldable t\n  => Applicative f\n  => t a b\n  -> (a -> f c)\n  -> (b -> f d)\n  -> f Unit\nbifor_ t f g = bitraverse_ f g t\n\n-- | Collapse a data structure, collecting effects using an `Applicative` functor,\n-- | ignoring the final result.\nbisequence_\n  :: forall t f a b\n   . Bifoldable t\n  => Applicative f\n  => t (f a) (f b)\n  -> f Unit\nbisequence_ = bitraverse_ identity identity\n\n-- | Test whether a predicate holds at any position in a data structure.\nbiany\n  :: forall t a b c\n   . Bifoldable t\n  => BooleanAlgebra c\n  => (a -> c)\n  -> (b -> c)\n  -> t a b\n  -> c\nbiany p q = unwrap <<< bifoldMap (Disj <<< p) (Disj <<< q)\n\n-- | Test whether a predicate holds at all positions in a data structure.\nbiall\n  :: forall t a b c\n   . Bifoldable t\n  => BooleanAlgebra c\n  => (a -> c)\n  -> (b -> c)\n  -> t a b\n  -> c\nbiall p q = unwrap <<< bifoldMap (Conj <<< p) (Conj <<< q)\n","-- | Helper functions for working with immutable Javascript arrays.\n-- |\n-- | _Note_: Depending on your use-case, you may prefer to use `Data.List` or\n-- | `Data.Sequence` instead, which might give better performance for certain\n-- | use cases. This module is useful when integrating with JavaScript libraries\n-- | which use arrays, but immutable arrays are not a practical data structure\n-- | for many use cases due to their poor asymptotics.\n-- |\n-- | In addition to the functions in this module, Arrays have a number of\n-- | useful instances:\n-- |\n-- | * `Functor`, which provides `map :: forall a b. (a -> b) -> Array a ->\n-- |   Array b`\n-- | * `Apply`, which provides `(<*>) :: forall a b. Array (a -> b) -> Array a\n-- |   -> Array b`. This function works a bit like a Cartesian product; the\n-- |   result array is constructed by applying each function in the first\n-- |   array to each value in the second, so that the result array ends up with\n-- |   a length equal to the product of the two arguments' lengths.\n-- | * `Bind`, which provides `(>>=) :: forall a b. (a -> Array b) -> Array a\n-- |   -> Array b` (this is the same as `concatMap`).\n-- | * `Semigroup`, which provides `(<>) :: forall a. Array a -> Array a ->\n-- |   Array a`, for concatenating arrays.\n-- | * `Foldable`, which provides a slew of functions for *folding* (also known\n-- |   as *reducing*) arrays down to one value. For example,\n-- |   `Data.Foldable.or` tests whether an array of `Boolean` values contains\n-- |   at least one `true` value.\n-- | * `Traversable`, which provides the PureScript version of a for-loop,\n-- |   allowing you to STAI.iterate over an array and accumulate effects.\n-- |\nmodule Data.Array\n  ( fromFoldable\n  , toUnfoldable\n  , singleton\n  , (..), range\n  , replicate\n  , some\n  , many\n\n  , null\n  , length\n\n  , (:), cons\n  , snoc\n  , insert\n  , insertBy\n\n  , head\n  , last\n  , tail\n  , init\n  , uncons\n  , unsnoc\n\n  , (!!), index\n  , elemIndex\n  , elemLastIndex\n  , findIndex\n  , findLastIndex\n  , insertAt\n  , deleteAt\n  , updateAt\n  , updateAtIndices\n  , modifyAt\n  , modifyAtIndices\n  , alterAt\n\n  , reverse\n  , concat\n  , concatMap\n  , filter\n  , partition\n  , filterA\n  , mapMaybe\n  , catMaybes\n  , mapWithIndex\n\n  , sort\n  , sortBy\n  , sortWith\n  , slice\n  , take\n  , takeEnd\n  , takeWhile\n  , drop\n  , dropEnd\n  , dropWhile\n  , span\n  , group\n  , group'\n  , groupBy\n\n  , nub\n  , nubEq\n  , nubBy\n  , nubByEq\n  , union\n  , unionBy\n  , delete\n  , deleteBy\n\n  , (\\\\), difference\n  , intersect\n  , intersectBy\n\n  , zipWith\n  , zipWithA\n  , zip\n  , unzip\n\n  , foldM\n  , foldRecM\n\n  , unsafeIndex\n\n  , module Exports\n  ) where\n\nimport Prelude\n\nimport Control.Alt ((<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy, defer)\nimport Control.Monad.Rec.Class (class MonadRec, Step(..), tailRecM2)\nimport Control.Monad.ST as ST\nimport Data.Array.ST as STA\nimport Data.Array.ST.Iterator as STAI\nimport Data.Array.NonEmpty.Internal (NonEmptyArray)\nimport Data.Foldable (class Foldable, foldl, foldr, traverse_)\nimport Data.Foldable (foldl, foldr, foldMap, fold, intercalate, elem, notElem, find, findMap, any, all) as Exports\nimport Data.Maybe (Maybe(..), maybe, isJust, fromJust)\nimport Data.Traversable (scanl, scanr) as Exports\nimport Data.Traversable (sequence, traverse)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Data.Unfoldable (class Unfoldable, unfoldr)\nimport Partial.Unsafe (unsafePartial)\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | Convert an `Array` into an `Unfoldable` structure.\ntoUnfoldable :: forall f. Unfoldable f => Array ~> f\ntoUnfoldable xs = unfoldr f 0\n  where\n  len = length xs\n  f i\n    | i < len   = Just (Tuple (unsafePartial (unsafeIndex xs i)) (i+1))\n    | otherwise = Nothing\n\n-- | Convert a `Foldable` structure into an `Array`.\n-- |\n-- | ```purescript\n-- | fromFoldable (Just 1) = [1]\n-- | fromFoldable (Nothing) = []\n-- | ```\n-- |\nfromFoldable :: forall f. Foldable f => f ~> Array\nfromFoldable = fromFoldableImpl foldr\n\nforeign import fromFoldableImpl\n  :: forall f a\n   . (forall b. (a -> b -> b) -> b -> f a -> b)\n  -> f a\n  -> Array a\n\n-- | Create an array of one element\n-- | ```purescript\n-- | singleton 2 = [2]\n-- | ```\nsingleton :: forall a. a -> Array a\nsingleton a = [a]\n\n-- | Create an array containing a range of integers, including both endpoints.\n-- | ```purescript\n-- | range 2 5 = [2, 3, 4, 5]\n-- | ```\nforeign import range :: Int -> Int -> Array Int\n\n-- | Create an array containing a value repeated the specified number of times.\n-- | ```purescript\n-- | replicate 2 \"Hi\" = [\"Hi\", \"Hi\"]\n-- | ```\nforeign import replicate :: forall a. Int -> a -> Array a\n\n-- | An infix synonym for `range`.\n-- | ```purescript\n-- | 2 .. 5 = [2, 3, 4, 5]\n-- | ```\ninfix 8 range as ..\n\n-- | Attempt a computation multiple times, requiring at least one success.\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nsome :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nsome v = (:) <$> v <*> defer (\\_ -> many v)\n\n-- | Attempt a computation multiple times, returning as many successful results\n-- | as possible (possibly zero).\n-- |\n-- | The `Lazy` constraint is used to generate the result lazily, to ensure\n-- | termination.\nmany :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\nmany v = some v <|> pure []\n\n--------------------------------------------------------------------------------\n-- Array size ------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Test whether an array is empty.\n-- | ```purescript\n-- | null [] = true\n-- | null [1, 2] = false\n-- | ```\nnull :: forall a. Array a -> Boolean\nnull xs = length xs == 0\n\n-- | Get the number of elements in an array.\n-- | ```purescript\n-- | length [\"Hello\", \"World\"] = 2\n-- | ```\nforeign import length :: forall a. Array a -> Int\n\n--------------------------------------------------------------------------------\n-- Extending arrays ------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Attaches an element to the front of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | cons 1 [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\nforeign import cons :: forall a. a -> Array a -> Array a\n\n-- | An infix alias for `cons`.\n-- |\n-- | ```purescript\n-- | 1 : [2, 3, 4] = [1, 2, 3, 4]\n-- | ```\n-- |\n-- | Note, the running time of this function is `O(n)`.\ninfixr 6 cons as :\n\n-- | Append an element to the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | snoc [1, 2, 3] 4 = [1, 2, 3, 4]\n-- | ```\n-- |\nforeign import snoc :: forall a. Array a -> a -> Array a\n\n-- | Insert an element into a sorted array.\n-- |\n-- | ```purescript\n-- | insert 10 [1, 2, 20, 21] = [1, 2, 10, 20, 21]\n-- | ```\n-- |\ninsert :: forall a. Ord a => a -> Array a -> Array a\ninsert = insertBy compare\n\n-- | Insert an element into a sorted array, using the specified function to\n-- | determine the ordering of elements.\n-- |\n-- | ```purescript\n-- | invertCompare a b = invert $ compare a b\n-- |\n-- | insertBy invertCompare 10 [21, 20, 2, 1] = [21, 20, 10, 2, 1]\n-- | ```\n-- |\ninsertBy :: forall a. (a -> a -> Ordering) -> a -> Array a -> Array a\ninsertBy cmp x ys =\n  let i = maybe 0 (_ + 1) (findLastIndex (\\y -> cmp x y == GT) ys)\n  in unsafePartial (fromJust (insertAt i x ys))\n\n--------------------------------------------------------------------------------\n-- Non-indexed reads -----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Get the first element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | head [1, 2] = Just 1\n-- | head [] = Nothing\n-- | ```\n-- |\nhead :: forall a. Array a -> Maybe a\nhead xs = xs !! 0\n\n-- | Get the last element in an array, or `Nothing` if the array is empty\n-- |\n-- | Running time: `O(1)`.\n-- |\n-- | ```purescript\n-- | last [1, 2] = Just 2\n-- | last [] = Nothing\n-- | ```\n-- |\nlast :: forall a. Array a -> Maybe a\nlast xs = xs !! (length xs - 1)\n\n-- | Get all but the first element of an array, creating a new array, or\n-- | `Nothing` if the array is empty\n-- |\n-- | ```purescript\n-- | tail [1, 2, 3, 4] = Just [2, 3, 4]\n-- | tail [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ntail :: forall a. Array a -> Maybe (Array a)\ntail = uncons' (const Nothing) (\\_ xs -> Just xs)\n\n-- | Get all but the last element of an array, creating a new array, or\n-- | `Nothing` if the array is empty.\n-- |\n-- | ```purescript\n-- | init [1, 2, 3, 4] = Just [1, 2, 3]\n-- | init [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\ninit :: forall a. Array a -> Maybe (Array a)\ninit xs\n  | null xs = Nothing\n  | otherwise = Just (slice zero (length xs - one) xs)\n\n-- | Break an array into its first element and remaining elements.\n-- |\n-- | Using `uncons` provides a way of writing code that would use cons patterns\n-- | in Haskell or pre-PureScript 0.7:\n-- | ``` purescript\n-- | f (x : xs) = something\n-- | f [] = somethingElse\n-- | ```\n-- | Becomes:\n-- | ``` purescript\n-- | f arr = case uncons arr of\n-- |   Just { head: x, tail: xs } -> something\n-- |   Nothing -> somethingElse\n-- | ```\nuncons :: forall a. Array a -> Maybe { head :: a, tail :: Array a }\nuncons = uncons' (const Nothing) \\x xs -> Just { head: x, tail: xs }\n\nforeign import uncons'\n  :: forall a b\n   . (Unit -> b)\n  -> (a -> Array a -> b)\n  -> Array a\n  -> b\n\n-- | Break an array into its last element and all preceding elements.\n-- |\n-- | ```purescript\n-- | unsnoc [1, 2, 3] = Just {init: [1, 2], last: 3}\n-- | unsnoc [] = Nothing\n-- | ```\n-- |\n-- | Running time: `O(n)` where `n` is the length of the array\nunsnoc :: forall a. Array a -> Maybe { init :: Array a, last :: a }\nunsnoc xs = { init: _, last: _ } <$> init xs <*> last xs\n\n--------------------------------------------------------------------------------\n-- Indexed operations ----------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | This function provides a safe way to read a value at a particular index\n-- | from an array.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | index sentence 0 = Just \"Hello\"\n-- | index sentence 7 = Nothing\n-- | ```\n-- |\nindex :: forall a. Array a -> Int -> Maybe a\nindex = indexImpl Just Nothing\n\nforeign import indexImpl\n  :: forall a\n   . (forall r. r -> Maybe r)\n  -> (forall r. Maybe r)\n  -> Array a\n  -> Int\n  -> Maybe a\n\n-- | An infix version of `index`.\n-- |\n-- | ```purescript\n-- | sentence = [\"Hello\", \"World\", \"!\"]\n-- |\n-- | sentence !! 0 = Just \"Hello\"\n-- | sentence !! 7 = Nothing\n-- | ```\n-- |\ninfixl 8 index as !!\n\n-- | Find the index of the first element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 0\n-- | elemIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemIndex x = findIndex (_ == x)\n\n-- | Find the index of the last element equal to the specified element.\n-- |\n-- | ```purescript\n-- | elemLastIndex \"a\" [\"a\", \"b\", \"a\", \"c\"] = Just 2\n-- | elemLastIndex \"Earth\" [\"Hello\", \"World\", \"!\"] = Nothing\n-- | ```\n-- |\nelemLastIndex :: forall a. Eq a => a -> Array a -> Maybe Int\nelemLastIndex x = findLastIndex (_ == x)\n\n-- | Find the first index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 1\n-- | findIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindIndex = findIndexImpl Just Nothing\n\nforeign import findIndexImpl\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> (a -> Boolean)\n  -> Array a\n  -> Maybe Int\n\n-- | Find the last index for which a predicate holds.\n-- |\n-- | ```purescript\n-- | findLastIndex (contains $ Pattern \"b\") [\"a\", \"bb\", \"b\", \"d\"] = Just 2\n-- | findLastIndex (contains $ Pattern \"x\") [\"a\", \"bb\", \"b\", \"d\"] = Nothing\n-- | ```\n-- |\nfindLastIndex :: forall a. (a -> Boolean) -> Array a -> Maybe Int\nfindLastIndex = findLastIndexImpl Just Nothing\n\nforeign import findLastIndexImpl\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> (a -> Boolean)\n  -> Array a\n  -> Maybe Int\n\n-- | Insert an element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | insertAt 2 \"!\" [\"Hello\", \"World\"] = Just [\"Hello\", \"World\", \"!\"]\n-- | insertAt 10 \"!\" [\"Hello\"] = Nothing\n-- | ```\n-- |\ninsertAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\ninsertAt = _insertAt Just Nothing\n\nforeign import _insertAt\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> Int\n  -> a\n  -> Array a\n  -> Maybe (Array a)\n\n-- | Delete the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | deleteAt 0 [\"Hello\", \"World\"] = Just [\"World\"]\n-- | deleteAt 10 [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\ndeleteAt :: forall a. Int -> Array a -> Maybe (Array a)\ndeleteAt = _deleteAt Just Nothing\n\nforeign import _deleteAt\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> Int\n  -> Array a\n  -> Maybe (Array a)\n\n-- | Change the element at the specified index, creating a new array, or\n-- | returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | updateAt 1 \"World\" [\"Hello\", \"Earth\"] = Just [\"Hello\", \"World\"]\n-- | updateAt 10 \"World\" [\"Hello\", \"Earth\"] = Nothing\n-- | ```\n-- |\nupdateAt :: forall a. Int -> a -> Array a -> Maybe (Array a)\nupdateAt = _updateAt Just Nothing\n\nforeign import _updateAt\n  :: forall a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> Int\n  -> a\n  -> Array a\n  -> Maybe (Array a)\n\n-- | Apply a function to the element at the specified index, creating a new\n-- | array, or returning `Nothing` if the index is out of bounds.\n-- |\n-- | ```purescript\n-- | modifyAt 1 toUpper [\"Hello\", \"World\"] = Just [\"Hello\", \"WORLD\"]\n-- | modifyAt 10 toUpper [\"Hello\", \"World\"] = Nothing\n-- | ```\n-- |\nmodifyAt :: forall a. Int -> (a -> a) -> Array a -> Maybe (Array a)\nmodifyAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = updateAt i (f x) xs\n\n-- | Update or delete the element at the specified index by applying a\n-- | function to the current value, returning a new array or `Nothing` if the\n-- | index is out-of-bounds.\n-- |\n-- | ```purescript\n-- | alterAt 1 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\", \"World\"]\n-- |\n-- | alterAt 1 (stripSuffix $ Pattern \"!!!!!\") [\"Hello\", \"World!\"]\n-- |    = Just [\"Hello\"]\n-- |\n-- | alterAt 10 (stripSuffix $ Pattern \"!\") [\"Hello\", \"World!\"] = Nothing\n-- | ```\n-- |\nalterAt :: forall a. Int -> (a -> Maybe a) -> Array a -> Maybe (Array a)\nalterAt i f xs = maybe Nothing go (xs !! i)\n  where\n  go x = case f x of\n    Nothing -> deleteAt i xs\n    Just x' -> updateAt i x' xs\n\n--------------------------------------------------------------------------------\n-- Transformations -------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Reverse an array, creating a new array.\n-- |\n-- | ```purescript\n-- | reverse [] = []\n-- | reverse [1, 2, 3] = [3, 2, 1]\n-- | ```\n-- |\nforeign import reverse :: forall a. Array a -> Array a\n\n-- | Flatten an array of arrays, creating a new array.\n-- |\n-- | ```purescript\n-- | concat [[1, 2, 3], [], [4, 5, 6]] = [1, 2, 3, 4, 5, 6]\n-- | ```\n-- |\nforeign import concat :: forall a. Array (Array a) -> Array a\n\n-- | Apply a function to each element in an array, and flatten the results\n-- | into a single, new array.\n-- |\n-- | ```purescript\n-- | concatMap (split $ Pattern \" \") [\"Hello World\", \"other thing\"]\n-- |    = [\"Hello\", \"World\", \"other\", \"thing\"]\n-- | ```\n-- |\nconcatMap :: forall a b. (a -> Array b) -> Array a -> Array b\nconcatMap = flip bind\n\n-- | Filter an array, keeping the elements which satisfy a predicate function,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | filter (_ > 0) [-1, 4, -5, 7] = [4, 7]\n-- | ```\n-- |\nforeign import filter :: forall a. (a -> Boolean) -> Array a -> Array a\n\n-- | Partition an array using a predicate function, creating a set of\n-- | new arrays. One for the values satisfying the predicate function\n-- | and one for values that don't.\n-- |\n-- | ```purescript\n-- | partition (_ > 0) [-1, 4, -5, 7] = { yes: [4, 7], no: [-1, -5] }\n-- | ```\n-- |\nforeign import partition\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { yes :: Array a, no :: Array a }\n\n-- | Filter where the predicate returns a `Boolean` in some `Applicative`.\n-- |\n-- | ```purescript\n-- | powerSet :: forall a. Array a -> Array (Array a)\n-- | powerSet = filterA (const [true, false])\n-- | ```\nfilterA :: forall a f. Applicative f => (a -> f Boolean) -> Array a -> f (Array a)\nfilterA p =\n  traverse (\\x -> Tuple x <$> p x)\n  >>> map (mapMaybe (\\(Tuple x b) -> if b then Just x else Nothing))\n\n-- | Apply a function to each element in an array, keeping only the results\n-- | which contain a value, creating a new array.\n-- |\n-- | ```purescript\n-- | parseEmail :: String -> Maybe Email\n-- | parseEmail = ...\n-- |\n-- | mapMaybe parseEmail [\"a.com\", \"hello@example.com\", \"--\"]\n-- |    = [Email {user: \"hello\", domain: \"example.com\"}]\n-- | ```\n-- |\nmapMaybe :: forall a b. (a -> Maybe b) -> Array a -> Array b\nmapMaybe f = concatMap (maybe [] singleton <<< f)\n\n-- | Filter an array of optional values, keeping only the elements which contain\n-- | a value, creating a new array.\n-- |\n-- | ```purescript\n-- | catMaybes [Nothing, Just 2, Nothing, Just 4] = [2, 4]\n-- | ```\n-- |\ncatMaybes :: forall a. Array (Maybe a) -> Array a\ncatMaybes = mapMaybe identity\n\n-- | Apply a function to each element in an array, supplying a generated\n-- | zero-based index integer along with the element, creating an array\n-- | with the new elements.\n-- |\n-- | ```purescript\n-- | prefixIndex index element = show index <> element\n-- |\n-- | mapWithIndex prefixIndex [\"Hello\", \"World\"] = [\"0Hello\", \"1World\"]\n-- | ```\n-- |\nmapWithIndex :: forall a b. (Int -> a -> b) -> Array a -> Array b\nmapWithIndex f xs =\n  zipWith f (range 0 (length xs - 1)) xs\n\n-- | Change the elements at the specified indices in index/value pairs.\n-- | Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | updates = [Tuple 0 \"Hi\", Tuple 2 \".\" , Tuple 10 \"foobar\"]\n-- |\n-- | updateAtIndices updates [\"Hello\", \"World\", \"!\"] = [\"Hi\", \"World\", \".\"]\n-- | ```\n-- |\nupdateAtIndices :: forall t a. Foldable t => t (Tuple Int a) -> Array a -> Array a\nupdateAtIndices us xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\(Tuple i a) -> STA.poke i a res) us) xs)\n\n-- | Apply a function to the element at the specified indices,\n-- | creating a new array. Out-of-bounds indices will have no effect.\n-- |\n-- | ```purescript\n-- | indices = [1, 3]\n-- | modifyAtIndices indices toUpper [\"Hello\", \"World\", \"and\", \"others\"]\n-- |    = [\"Hello\", \"WORLD\", \"and\", \"OTHERS\"]\n-- | ```\n-- |\nmodifyAtIndices :: forall t a. Foldable t => t Int -> (a -> a) -> Array a -> Array a\nmodifyAtIndices is f xs =\n  ST.run (STA.withArray (\\res -> traverse_ (\\i -> STA.modify i f res) is) xs)\n\n--------------------------------------------------------------------------------\n-- Sorting ---------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Sort the elements of an array in increasing order, creating a new array.\n-- |\n-- | ```purescript\n-- | sort [2, -3, 1] = [-3, 1, 2]\n-- | ```\n-- |\nsort :: forall a. Ord a => Array a -> Array a\nsort xs = sortBy compare xs\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | compared using the specified partial ordering, creating a new array.\n-- |\n-- | ```purescript\n-- | compareLength a b = compare (length a) (length b)\n-- | sortBy compareLength [[1, 2, 3], [7, 9], [-2]] = [[-2],[7,9],[1,2,3]]\n-- | ```\n-- |\nsortBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nsortBy comp xs = sortImpl comp' xs\n  where\n  comp' x y = case comp x y of\n    GT -> 1\n    EQ -> 0\n    LT -> -1\n\n-- | Sort the elements of an array in increasing order, where elements are\n-- | sorted based on a projection\n-- |\n-- | ```purescript\n-- | sortWith (_.age) [{name: \"Alice\", age: 42}, {name: \"Bob\", age: 21}]\n-- |    = [{name: \"Bob\", age: 21}, {name: \"Alice\", age: 42}]\n-- | ```\n-- |\nsortWith :: forall a b. Ord b => (a -> b) -> Array a -> Array a\nsortWith f = sortBy (comparing f)\n\nforeign import sortImpl :: forall a. (a -> a -> Int) -> Array a -> Array a\n\n--------------------------------------------------------------------------------\n-- Subarrays -------------------------------------------------------------------\n--------------------------------------------------------------------------------\n\n-- | Extract a subarray by a start and end index.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- | slice 1 3 letters = [\"b\", \"c\"]\n-- | slice 5 7 letters = []\n-- | slice 4 1 letters = []\n-- | ```\n-- |\nforeign import slice :: forall a. Int -> Int -> Array a -> Array a\n\n-- | Keep only a number of elements from the start of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | take 2 letters = [\"a\", \"b\"]\n-- | take 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\nforeign import take :: forall a. Int -> Array a -> Array a\n\n-- | Keep only a number of elements from the end of an array, creating a new\n-- | array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\"]\n-- |\n-- | takeEnd 2 letters = [\"b\", \"c\"]\n-- | takeEnd 100 letters = [\"a\", \"b\", \"c\"]\n-- | ```\n-- |\ntakeEnd :: forall a. Int -> Array a -> Array a\ntakeEnd n xs = drop (length xs - n) xs\n\n-- | Calculate the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | takeWhile (_ > 0) [4, 1, 0, -4, 5] = [4, 1]\n-- | takeWhile (_ > 0) [-1, 4] = []\n-- | ```\n-- |\ntakeWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ntakeWhile p xs = (span p xs).init\n\n-- | Drop a number of elements from the start of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | drop 2 letters = [\"c\", \"d\"]\n-- | drop 10 letters = []\n-- | ```\n-- |\nforeign import drop :: forall a. Int -> Array a -> Array a\n\n-- | Drop a number of elements from the end of an array, creating a new array.\n-- |\n-- | ```purescript\n-- | letters = [\"a\", \"b\", \"c\", \"d\"]\n-- |\n-- | dropEnd 2 letters = [\"a\", \"b\"]\n-- | dropEnd 10 letters = []\n-- | ```\n-- |\ndropEnd :: forall a. Int -> Array a -> Array a\ndropEnd n xs = take (length xs - n) xs\n\n-- | Remove the longest initial subarray for which all element satisfy the\n-- | specified predicate, creating a new array.\n-- |\n-- | ```purescript\n-- | dropWhile (_ < 0) [-3, -1, 0, 4, -6] = [0, 4, -6]\n-- | ```\n-- |\ndropWhile :: forall a. (a -> Boolean) -> Array a -> Array a\ndropWhile p xs = (span p xs).rest\n\n-- | Split an array into two parts:\n-- |\n-- | 1. the longest initial subarray for which all elements satisfy the\n-- |    specified predicate\n-- | 2. the remaining elements\n-- |\n-- | ```purescript\n-- | span (\\n -> n % 2 == 1) [1,3,2,4,5] == { init: [1,3], rest: [2,4,5] }\n-- | ```\n-- |\n-- | Running time: `O(n)`.\nspan\n  :: forall a\n   . (a -> Boolean)\n  -> Array a\n  -> { init :: Array a, rest :: Array a }\nspan p arr =\n  case breakIndex of\n    Just 0 ->\n      { init: [], rest: arr }\n    Just i ->\n      { init: slice 0 i arr, rest: slice i (length arr) arr }\n    Nothing ->\n      { init: arr, rest: [] }\n  where\n  breakIndex = go 0\n  go i =\n    -- This looks like a good opportunity to use the Monad Maybe instance,\n    -- but it's important to write out an explicit case expression here in\n    -- order to ensure that TCO is triggered.\n    case index arr i of\n      Just x -> if p x then go (i + 1) else Just i\n      Nothing -> Nothing\n\n-- | Group equal, consecutive elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group [1,1,2,2,1] == [NonEmpty 1 [1], NonEmpty 2 [2], NonEmpty 1 []]\n-- | ```\ngroup :: forall a. Eq a => Array a -> Array (NonEmptyArray a)\ngroup xs = groupBy eq xs\n\n-- | Sort and then group the elements of an array into arrays.\n-- |\n-- | ```purescript\n-- | group' [1,1,2,2,1] == [NonEmpty 1 [1,1],NonEmpty 2 [2]]\n-- | ```\ngroup' :: forall a. Ord a => Array a -> Array (NonEmptyArray a)\ngroup' = group <<< sort\n\n-- | Group equal, consecutive elements of an array into arrays, using the\n-- | specified equivalence relation to detemine equality.\n-- |\n-- | ```purescript\n-- | groupBy (\\a b -> odd a && odd b) [1, 3, 2, 4, 3, 3]\n-- |    = [NonEmpty 1 [3], NonEmpty 2 [] , NonEmpty 4 [], NonEmpty 3 [3]]\n-- | ```\n-- |\ngroupBy :: forall a. (a -> a -> Boolean) -> Array a -> Array (NonEmptyArray a)\ngroupBy op xs =\n  ST.run do\n    result <- STA.empty\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\x -> void do\n      sub <- STA.empty\n      _ <- STA.push x sub\n      STAI.pushWhile (op x) iter sub\n      grp <- STA.unsafeFreeze sub\n      STA.push ((unsafeCoerce :: Array ~> NonEmptyArray) grp) result\n    STA.unsafeFreeze result\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | ```purescript\n-- | nub [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnub :: forall a. Ord a => Array a -> Array a\nnub = nubBy compare\n\n-- | Remove the duplicates from an array, creating a new array.\n-- |\n-- | This less efficient version of `nub` only requires an `Eq` instance.\n-- |\n-- | ```purescript\n-- | nubEq [1, 2, 1, 3, 3] = [1, 2, 3]\n-- | ```\n-- |\nnubEq :: forall a. Eq a => Array a -> Array a\nnubEq = nubByEq eq\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified ordering, creating a new array.\n-- |\n-- | ```purescript\n-- | nubBy compare [1, 3, 4, 2, 2, 1] == [1, 3, 4, 2]\n-- | ```\n-- |\nnubBy :: forall a. (a -> a -> Ordering) -> Array a -> Array a\nnubBy comp xs = case head indexedAndSorted of\n  Nothing -> []\n  Just x -> map snd $ sortWith fst $ ST.run do\n     -- TODO: use NonEmptyArrays here to avoid partial functions\n     result <- STA.unsafeThaw $ singleton x\n     ST.foreach indexedAndSorted \\pair@(Tuple i x') -> do\n       lst <- snd <<< unsafePartial (fromJust <<< last) <$> STA.unsafeFreeze result\n       when (comp lst x' /= EQ) $ void $ STA.push pair result\n     STA.unsafeFreeze result\n  where\n  indexedAndSorted :: Array (Tuple Int a)\n  indexedAndSorted = sortBy (\\x y -> comp (snd x) (snd y))\n                            (mapWithIndex Tuple xs)\n\n-- | Remove the duplicates from an array, where element equality is determined\n-- | by the specified equivalence relation, creating a new array.\n-- |\n-- | This less efficient version of `nubBy` only requires an equivalence\n-- | relation.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | nubByEq mod3eq [1, 3, 4, 5, 6] = [1, 3, 5]\n-- | ```\n-- |\nnubByEq :: forall a. (a -> a -> Boolean) -> Array a -> Array a\nnubByEq eq xs = ST.run do\n  arr <- STA.empty\n  ST.foreach xs \\x -> do\n    e <- not <<< Exports.any (_ `eq` x) <$> (STA.unsafeFreeze arr)\n    when e $ void $ STA.push x arr\n  STA.unsafeFreeze arr\n\n-- | Calculate the union of two arrays. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | Running time: `O(n^2)`\n-- |\n-- | ```purescript\n-- | union [1, 2, 1, 1] [3, 3, 3, 4] = [1, 2, 1, 1, 3, 4]\n-- | ```\n-- |\nunion :: forall a. Eq a => Array a -> Array a -> Array a\nunion = unionBy (==)\n\n-- | Calculate the union of two arrays, using the specified function to\n-- | determine equality of elements. Note that duplicates in the first array\n-- | are preserved while duplicates in the second array are removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | unionBy mod3eq [1, 5, 1, 2] [3, 4, 3, 3] = [1, 5, 1, 2, 3]\n-- | ```\n-- |\nunionBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nunionBy eq xs ys = xs <> foldl (flip (deleteBy eq)) (nubByEq eq ys) xs\n\n-- | Delete the first element of an array which is equal to the specified value,\n-- | creating a new array.\n-- |\n-- | ```purescript\n-- | delete 7 [1, 7, 3, 7] = [1, 3, 7]\n-- | delete 7 [1, 2, 3] = [1, 2, 3]\n-- | ```\n-- |\n-- | Running time: `O(n)`\ndelete :: forall a. Eq a => a -> Array a -> Array a\ndelete = deleteBy eq\n\n-- | Delete the first element of an array which matches the specified value,\n-- | under the equivalence relation provided in the first argument, creating a\n-- | new array.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | deleteBy mod3eq 6 [1, 3, 4, 3] = [1, 4, 3]\n-- | ```\n-- |\ndeleteBy :: forall a. (a -> a -> Boolean) -> a -> Array a -> Array a\ndeleteBy _  _ [] = []\ndeleteBy eq x ys = maybe ys (\\i -> unsafePartial $ fromJust (deleteAt i ys)) (findIndex (eq x) ys)\n\n-- | Delete the first occurrence of each element in the second array from the\n-- | first array, creating a new array.\n-- |\n-- | ```purescript\n-- | difference [2, 1] [2, 3] = [1]\n-- | ```\n-- |\n-- | Running time: `O(n*m)`, where n is the length of the first array, and m is\n-- | the length of the second.\ndifference :: forall a. Eq a => Array a -> Array a -> Array a\ndifference = foldr delete\n\ninfix 5 difference as \\\\\n\n-- | Calculate the intersection of two arrays, creating a new array. Note that\n-- | duplicates in the first array are preserved while duplicates in the second\n-- | array are removed.\n-- |\n-- | ```purescript\n-- | intersect [1, 1, 2] [2, 2, 1] = [1, 1, 2]\n-- | ```\n-- |\nintersect :: forall a. Eq a => Array a -> Array a -> Array a\nintersect = intersectBy eq\n\n-- | Calculate the intersection of two arrays, using the specified equivalence\n-- | relation to compare elements, creating a new array. Note that duplicates\n-- | in the first array are preserved while duplicates in the second array are\n-- | removed.\n-- |\n-- | ```purescript\n-- | mod3eq a b = a `mod` 3 == b `mod` 3\n-- | intersectBy mod3eq [1, 2, 3] [4, 6, 7] = [1, 3]\n-- | ```\n-- |\nintersectBy :: forall a. (a -> a -> Boolean) -> Array a -> Array a -> Array a\nintersectBy eq xs ys = filter (\\x -> isJust (findIndex (eq x) ys)) xs\n\n-- | Apply a function to pairs of elements at the same index in two arrays,\n-- | collecting the results in a new array.\n-- |\n-- | If one array is longer, elements will be discarded from the longer array.\n-- |\n-- | For example\n-- |\n-- | ```purescript\n-- | zipWith (*) [1, 2, 3] [4, 5, 6, 7] == [4, 10, 18]\n-- | ```\nforeign import zipWith\n  :: forall a b c\n   . (a -> b -> c)\n  -> Array a\n  -> Array b\n  -> Array c\n\n-- | A generalization of `zipWith` which accumulates results in some\n-- | `Applicative` functor.\n-- |\n-- | ```purescript\n-- | sndChars = zipWithA (\\a b -> charAt 2 (a <> b))\n-- | sndChars [\"a\", \"b\"] [\"A\", \"B\"] = Nothing -- since \"aA\" has no 3rd char\n-- | sndChars [\"aa\", \"b\"] [\"AA\", \"BBB\"] = Just ['A', 'B']\n-- | ```\n-- |\nzipWithA\n  :: forall m a b c\n   . Applicative m\n  => (a -> b -> m c)\n  -> Array a\n  -> Array b\n  -> m (Array c)\nzipWithA f xs ys = sequence (zipWith f xs ys)\n\n-- | Takes two arrays and returns an array of corresponding pairs.\n-- | If one input array is short, excess elements of the longer array are\n-- | discarded.\n-- |\n-- | ```purescript\n-- | zip [1, 2, 3] [\"a\", \"b\"] = [Tuple 1 \"a\", Tuple 2 \"b\"]\n-- | ```\n-- |\nzip :: forall a b. Array a -> Array b -> Array (Tuple a b)\nzip = zipWith Tuple\n\n-- | Transforms an array of pairs into an array of first components and an\n-- | array of second components.\n-- |\n-- | ```purescript\n-- | unzip [Tuple 1 \"a\", Tuple 2 \"b\"] = Tuple [1, 2] [\"a\", \"b\"]\n-- | ```\n-- |\nunzip :: forall a b. Array (Tuple a b) -> Tuple (Array a) (Array b)\nunzip xs =\n  ST.run do\n    fsts <- STA.empty\n    snds <- STA.empty\n    iter <- STAI.iterator (xs !! _)\n    STAI.iterate iter \\(Tuple fst snd) -> do\n      void $ STA.push fst fsts\n      void $ STA.push snd snds\n    fsts' <- STA.unsafeFreeze fsts\n    snds' <- STA.unsafeFreeze snds\n    pure $ Tuple fsts' snds'\n\n-- | Perform a fold using a monadic step function.\n-- |\n-- | ```purescript\n-- | foldM (\\x y -> Just (x + y)) 0 [1, 4] = Just 5\n-- | ```\n-- |\nfoldM :: forall m a b. Monad m => (a -> b -> m a) -> a -> Array b -> m a\nfoldM f a = uncons' (\\_ -> pure a) (\\b bs -> f a b >>= \\a' -> foldM f a' bs)\n\nfoldRecM :: forall m a b. MonadRec m => (a -> b -> m a) -> a -> Array b -> m a\nfoldRecM f a array = tailRecM2 go a 0\n  where\n  go res i\n    | i >= length array = pure (Done res)\n    | otherwise = do\n        res' <- f res (unsafePartial (unsafeIndex array i))\n        pure (Loop { a: res', b: i + 1 })\n\n-- | Find the element of an array at the specified index.\n-- |\n-- | ```purescript\n-- | unsafePartial $ unsafeIndex [\"a\", \"b\", \"c\"] 1 = \"b\"\n-- | ```\n-- |\n-- | Using `unsafeIndex` with an out-of-range index will not immediately raise a runtime error.\n-- | Instead, the result will be undefined. Most attempts to subsequently use the result will\n-- | cause a runtime error, of course, but this is not guaranteed, and is dependent on the backend;\n-- | some programs will continue to run as if nothing is wrong. For example, in the JavaScript backend,\n-- | the expression `unsafePartial (unsafeIndex [true] 1)` has type `Boolean`;\n-- | since this expression evaluates to `undefined`, attempting to use it in an `if` statement will cause\n-- | the else branch to be taken.\nunsafeIndex :: forall a. Partial => Array a -> Int -> a\nunsafeIndex = unsafeIndexImpl\n\nforeign import unsafeIndexImpl :: forall a. Array a -> Int -> a\n","\"use strict\";\n\n//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.range = function (start) {\n  return function (end) {\n    var step = start > end ? -1 : 1;\n    var result = new Array(step * (end - start) + 1);\n    var i = start, n = 0;\n    while (i !== end) {\n      result[n++] = i;\n      i += step;\n    }\n    result[n] = i;\n    return result;\n  };\n};\n\nvar replicateFill = function (count) {\n  return function (value) {\n    if (count < 1) {\n      return [];\n    }\n    var result = new Array(count);\n    return result.fill(value);\n  };\n};\n\nvar replicatePolyfill = function (count) {\n  return function (value) {\n    var result = [];\n    var n = 0;\n    for (var i = 0; i < count; i++) {\n      result[n++] = value;\n    }\n    return result;\n  };\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexports.replicate = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexports.fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr) {\n    return function (xs) {\n      return listToArray(foldr(curryCons)(emptyList)(xs));\n    };\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Extending arrays ------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.cons = function (e) {\n  return function (l) {\n    return [e].concat(l);\n  };\n};\n\nexports.snoc = function (l) {\n  return function (e) {\n    var l1 = l.slice();\n    l1.push(e);\n    return l1;\n  };\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports[\"uncons'\"] = function (empty) {\n  return function (next) {\n    return function (xs) {\n      return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.indexImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function (i) {\n        return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n      };\n    };\n  };\n};\n\nexports.findIndexImpl = function (just) {\n  return function (nothing) {\n    return function (f) {\n      return function (xs) {\n        for (var i = 0, l = xs.length; i < l; i++) {\n          if (f(xs[i])) return just(i);\n        }\n        return nothing;\n      };\n    };\n  };\n};\n\nexports.findLastIndexImpl = function (just) {\n  return function (nothing) {\n    return function (f) {\n      return function (xs) {\n        for (var i = xs.length - 1; i >= 0; i--) {\n          if (f(xs[i])) return just(i);\n        }\n        return nothing;\n      };\n    };\n  };\n};\n\nexports._insertAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (a) {\n        return function (l) {\n          if (i < 0 || i > l.length) return nothing;\n          var l1 = l.slice();\n          l1.splice(i, 0, a);\n          return just(l1);\n        };\n      };\n    };\n  };\n};\n\nexports._deleteAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (l) {\n        if (i < 0 || i >= l.length) return nothing;\n        var l1 = l.slice();\n        l1.splice(i, 1);\n        return just(l1);\n      };\n    };\n  };\n};\n\nexports._updateAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (a) {\n        return function (l) {\n          if (i < 0 || i >= l.length) return nothing;\n          var l1 = l.slice();\n          l1[i] = a;\n          return just(l1);\n        };\n      };\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexports.concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexports.filter = function (f) {\n  return function (xs) {\n    return xs.filter(f);\n  };\n};\n\nexports.partition = function (f) {\n  return function (xs) {\n    var yes = [];\n    var no  = [];\n    for (var i = 0; i < xs.length; i++) {\n      var x = xs[i];\n      if (f(x))\n        yes.push(x);\n      else\n        no.push(x);\n    }\n    return { yes: yes, no: no };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.sortImpl = function (f) {\n  return function (l) {\n    return l.slice().sort(function (x, y) {\n      return f(x)(y);\n    });\n  };\n};\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.slice = function (s) {\n  return function (e) {\n    return function (l) {\n      return l.slice(s, e);\n    };\n  };\n};\n\nexports.take = function (n) {\n  return function (l) {\n    return n < 1 ? [] : l.slice(0, n);\n  };\n};\n\nexports.drop = function (n) {\n  return function (l) {\n    return n < 1 ? l : l.slice(n);\n  };\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.zipWith = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var l = xs.length < ys.length ? xs.length : ys.length;\n      var result = new Array(l);\n      for (var i = 0; i < l; i++) {\n        result[i] = f(xs[i])(ys[i]);\n      }\n      return result;\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.unsafeIndexImpl = function (xs) {\n  return function (n) {\n    return xs[n];\n  };\n};\n","-- | Helper functions for working with mutable arrays using the `ST` effect.\n-- |\n-- | This module can be used when performance is important and mutation is a local effect.\n\nmodule Data.Array.ST\n  ( STArray(..)\n  , Assoc\n  , run\n  , withArray\n  , empty\n  , peek\n  , poke\n  , modify\n  , pop\n  , push\n  , pushAll\n  , shift\n  , unshift\n  , unshiftAll\n  , splice\n  , sort\n  , sortBy\n  , sortWith\n  , freeze\n  , thaw\n  , unsafeFreeze\n  , unsafeThaw\n  , toAssocArray\n  ) where\n\nimport Prelude\n\nimport Control.Monad.ST as ST\nimport Control.Monad.ST (ST, kind Region)\nimport Data.Maybe (Maybe(..))\nimport Unsafe.Coerce (unsafeCoerce)\n\n-- | A reference to a mutable array.\n-- |\n-- | The first type parameter represents the memory region which the array belongs to.\n-- | The second type parameter defines the type of elements of the mutable array.\n-- |\n-- | The runtime representation of a value of type `STArray h a` is the same as that of `Array a`,\n-- | except that mutation is allowed.\nforeign import data STArray :: Region -> Type -> Type\n\n-- | An element and its index.\ntype Assoc a = { value :: a, index :: Int }\n\n-- | A safe way to create and work with a mutable array before returning an\n-- | immutable array for later perusal. This function avoids copying the array\n-- | before returning it - it uses unsafeFreeze internally, but this wrapper is\n-- | a safe interface to that function.\nrun :: forall a. (forall h. ST h (STArray h a)) -> Array a\nrun st = ST.run (st >>= unsafeFreeze)\n\n-- | Perform an effect requiring a mutable array on a copy of an immutable array,\n-- | safely returning the result as an immutable array.\nwithArray\n  :: forall h a b\n   . (STArray h a -> ST h b)\n   -> Array a\n   -> ST h (Array a)\nwithArray f xs = do\n  result <- thaw xs\n  _ <- f result\n  unsafeFreeze result\n\n-- | O(1). Convert a mutable array to an immutable array, without copying. The mutable\n-- | array must not be mutated afterwards.\nunsafeFreeze :: forall h a. STArray h a -> ST h (Array a)\nunsafeFreeze = pure <<< (unsafeCoerce :: STArray h a -> Array a)\n\n-- | O(1) Convert an immutable array to a mutable array, without copying. The input\n-- | array must not be used afterward.\nunsafeThaw :: forall h a. Array a -> ST h (STArray h a)\nunsafeThaw = pure <<< (unsafeCoerce :: Array a -> STArray h a)\n\n-- | Create an empty mutable array.\nforeign import empty :: forall h a. ST h (STArray h a)\n\n-- | Create a mutable copy of an immutable array.\nthaw :: forall h a. Array a -> ST h (STArray h a)\nthaw = copyImpl\n\n-- | Sort a mutable array in place.\nsort :: forall a h. Ord a => STArray h a -> ST h (STArray h a)\nsort = sortBy compare\n\n-- | Remove the first element from an array and return that element.\nshift :: forall h a. STArray h a -> ST h (Maybe a)\nshift = shiftImpl Just Nothing\n\nforeign import shiftImpl\n  :: forall h a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> STArray h a\n  -> ST h (Maybe a)\n\n-- | Sort a mutable array in place using a comparison function.\nsortBy\n  :: forall a h\n   . (a -> a -> Ordering)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortBy comp = sortByImpl comp'\n  where\n  comp' x y = case comp x y of\n    GT -> 1\n    EQ -> 0\n    LT -> -1\n\nforeign import sortByImpl\n  :: forall a h\n   . (a -> a -> Int)\n  -> STArray h a\n  -> ST h (STArray h a)\n\n-- | Sort a mutable array in place based on a projection.\nsortWith\n  :: forall a b h\n   . Ord b\n  => (a -> b)\n  -> STArray h a\n  -> ST h (STArray h a)\nsortWith f = sortBy (comparing f)\n\n-- | Create an immutable copy of a mutable array.\nfreeze :: forall h a. STArray h a -> ST h (Array a)\nfreeze = copyImpl\n\nforeign import copyImpl :: forall h a b. a -> ST h b\n\n-- | Read the value at the specified index in a mutable array.\npeek\n  :: forall h a\n   . Int\n  -> STArray h a\n  -> ST h (Maybe a)\npeek = peekImpl Just Nothing\n\nforeign import peekImpl\n  :: forall h a r\n   . (a -> r)\n  -> r\n  -> Int\n  -> STArray h a\n  -> (ST h r)\n\n-- | Change the value at the specified index in a mutable array.\nforeign import poke :: forall h a. Int -> a -> STArray h a -> ST h Boolean\n\n-- | Remove the last element from an array and return that element.\npop :: forall h a. STArray h a -> ST h (Maybe a)\npop = popImpl Just Nothing\n\nforeign import popImpl\n  :: forall h a\n   . (forall b. b -> Maybe b)\n  -> (forall b. Maybe b)\n  -> STArray h a\n  -> ST h (Maybe a)\n\n-- | Append an element to the end of a mutable array. Returns the new length of\n-- | the array.\npush :: forall h a. a -> STArray h a -> ST h Int\npush a = pushAll [a]\n\n-- | Append the values in an immutable array to the end of a mutable array.\n-- | Returns the new length of the mutable array.\nforeign import pushAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\n\n-- | Append an element to the front of a mutable array. Returns the new length of\n-- | the array.\nunshift :: forall h a. a -> STArray h a -> ST h Int\nunshift a = unshiftAll [a]\n\n-- | Append the values in an immutable array to the front of a mutable array.\n-- | Returns the new length of the mutable array.\nforeign import unshiftAll\n  :: forall h a\n   . Array a\n  -> STArray h a\n  -> ST h Int\n\n-- | Mutate the element at the specified index using the supplied function.\nmodify :: forall h a. Int -> (a -> a) -> STArray h a -> ST h Boolean\nmodify i f xs = do\n  entry <- peek i xs\n  case entry of\n    Just x  -> poke i (f x) xs\n    Nothing -> pure false\n\n-- | Remove and/or insert elements from/into a mutable array at the specified index.\nforeign import splice\n  :: forall h a\n   . Int\n  -> Int\n  -> Array a\n  -> STArray h a\n  -> ST h (Array a)\n\n-- | Create an immutable copy of a mutable array, where each element\n-- | is labelled with its index in the original array.\nforeign import toAssocArray :: forall h a. STArray h a -> ST h (Array (Assoc a))\n","\"use strict\";\n\nexports.empty = function () {\n  return [];\n};\n\nexports.peekImpl = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (xs) {\n        return function () {\n          return i >= 0 && i < xs.length ? just(xs[i]) : nothing;\n        };\n      };\n    };\n  };\n};\n\nexports.poke = function (i) {\n  return function (a) {\n    return function (xs) {\n      return function () {\n        var ret = i >= 0 && i < xs.length;\n        if (ret) xs[i] = a;\n        return ret;\n      };\n    };\n  };\n};\n\nexports.popImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function () {\n        return xs.length > 0 ? just(xs.pop()) : nothing;\n      };\n    };\n  };\n};\n\nexports.pushAll = function (as) {\n  return function (xs) {\n    return function () {\n      return xs.push.apply(xs, as);\n    };\n  };\n};\n\nexports.shiftImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function () {\n        return xs.length > 0 ? just(xs.shift()) : nothing;\n      };\n    };\n  };\n};\n\nexports.unshiftAll = function (as) {\n  return function (xs) {\n    return function () {\n      return xs.unshift.apply(xs, as);\n    };\n  };\n};\n\nexports.splice = function (i) {\n  return function (howMany) {\n    return function (bs) {\n      return function (xs) {\n        return function () {\n          return xs.splice.apply(xs, [i, howMany].concat(bs));\n        };\n      };\n    };\n  };\n};\n\nexports.copyImpl = function (xs) {\n  return function () {\n    return xs.slice();\n  };\n};\n\nexports.sortByImpl = function (comp) {\n  return function (xs) {\n    return function () {\n      return xs.sort(function (x, y) {\n        return comp(x)(y);\n      });\n    };\n  };\n};\n\nexports.toAssocArray = function (xs) {\n  return function () {\n    var n = xs.length;\n    var as = new Array(n);\n    for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };\n    return as;\n  };\n};\n","module Data.Array.ST.Iterator\n  ( Iterator\n  , iterator\n  , iterate\n  , next\n  , peek\n  , exhausted\n  , pushWhile\n  , pushAll\n  ) where\n\nimport Prelude\nimport Control.Monad.ST (ST)\nimport Control.Monad.ST as ST\nimport Control.Monad.ST.Ref (STRef)\nimport Control.Monad.ST.Ref as STRef\nimport Data.Array.ST (STArray)\nimport Data.Array.ST as STA\n\nimport Data.Maybe (Maybe(..), isNothing)\n\n-- | This type provides a slightly easier way of iterating over an array's\n-- | elements in an STArray computation, without having to keep track of\n-- | indices.\ndata Iterator r a = Iterator (Int -> Maybe a) (STRef r Int)\n\n-- | Make an Iterator given an indexing function into an array (or anything\n-- | else). If `xs :: Array a`, the standard way to create an iterator over\n-- | `xs` is to use `iterator (xs !! _)`, where `(!!)` comes from `Data.Array`.\niterator :: forall r a. (Int -> Maybe a) -> ST r (Iterator r a)\niterator f =\n  Iterator f <$> STRef.new 0\n\n-- | Perform an action once for each item left in an iterator. If the action\n-- | itself also advances the same iterator, `iterate` will miss those items\n-- | out.\niterate :: forall r a. Iterator r a -> (a -> ST r Unit) -> ST r Unit\niterate iter f = do\n  break <- STRef.new false\n  ST.while (not <$> STRef.read break) do\n    mx <- next iter\n    case mx of\n      Just x -> f x\n      Nothing -> void $ STRef.write true break\n\n-- | Get the next item out of an iterator, advancing it. Returns Nothing if the\n-- | Iterator is exhausted.\nnext :: forall r a. Iterator r a -> ST r (Maybe a)\nnext (Iterator f currentIndex) = do\n  i <- STRef.read currentIndex\n  _ <- STRef.modify (_ + 1) currentIndex\n  pure (f i)\n\n-- | Get the next item out of an iterator without advancing it.\npeek :: forall r a. Iterator r a -> ST r (Maybe a)\npeek (Iterator f currentIndex) = do\n  i <- STRef.read currentIndex\n  pure (f i)\n\n-- | Check whether an iterator has been exhausted.\nexhausted :: forall r a. Iterator r a -> ST r Boolean\nexhausted = map isNothing <<< peek\n\n-- | Extract elements from an iterator and push them on to an STArray for as\n-- | long as those elements satisfy a given predicate.\npushWhile :: forall r a. (a -> Boolean) -> Iterator r a -> STArray r a -> ST r Unit\npushWhile p iter array = do\n  break <- STRef.new false\n  ST.while (not <$> STRef.read break) do\n    mx <- peek iter\n    case mx of\n      Just x | p x -> do\n        _ <- STA.push x array\n        void $ next iter\n      _ ->\n        void $ STRef.write true break\n\n-- | Push the entire remaining contents of an iterator onto an STArray.\npushAll :: forall r a. Iterator r a -> STArray r a -> ST r Unit\npushAll = pushWhile (const true)\n","module Control.Semigroupoid where\n\n-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not\n-- | require an identity element `identity`, just composable morphisms.\n-- |\n-- | `Semigroupoid`s must satisfy the following law:\n-- |\n-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n-- |\n-- | One example of a `Semigroupoid` is the function type constructor `(->)`,\n-- | with `(<<<)` defined as function composition.\nclass Semigroupoid a where\n  compose :: forall b c d. a c d -> a b c -> a b d\n\ninstance semigroupoidFn :: Semigroupoid (->) where\n  compose f g x = f (g x)\n\ninfixr 9 compose as <<<\n\n-- | Forwards composition, or `compose` with its arguments reversed.\ncomposeFlipped :: forall a b c d. Semigroupoid a => a b c -> a c d -> a b d\ncomposeFlipped f g = compose g f\n\ninfixr 9 composeFlipped as >>>\n","module Control.Plus\n  ( class Plus, empty\n  , module Control.Alt\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Plus` type class extends the `Alt` type class with a value that\n-- | should be the left and right identity for `(<|>)`.\n-- |\n-- | It is similar to `Monoid`, except that it applies to types of\n-- | kind `* -> *`, like `Array` or `List`, rather than concrete types like\n-- | `String` or `Number`.\n-- |\n-- | `Plus` instances should satisfy the following laws:\n-- |\n-- | - Left identity: `empty <|> x == x`\n-- | - Right identity: `x <|> empty == x`\n-- | - Annihilation: `f <$> empty == empty`\nclass Alt f <= Plus f where\n  empty :: forall a. f a\n\ninstance plusArray :: Plus Array where\n  empty = []\n","module Control.MonadZero\n  ( class MonadZero\n  , guard\n  , module Control.Alt\n  , module Control.Alternative\n  , module Control.Applicative\n  , module Control.Apply\n  , module Control.Bind\n  , module Control.Monad\n  , module Control.Plus\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Applicative (class Applicative, pure, liftA1, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\nimport Control.Monad (class Monad, ap, liftM1)\nimport Control.Plus (class Plus, empty)\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\n\n-- | The `MonadZero` type class has no members of its own; it just specifies\n-- | that the type has both `Monad` and `Alternative` instances.\n-- |\n-- | Types which have `MonadZero` instances should also satisfy the following\n-- | laws:\n-- |\n-- | - Annihilation: `empty >>= f = empty`\nclass (Monad m, Alternative m) <= MonadZero m\n\ninstance monadZeroArray :: MonadZero Array\n\n-- | Fail using `Plus` if a condition does not hold, or\n-- | succeed using `Monad` if it does.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Prelude\n-- | import Control.Monad (bind)\n-- | import Control.MonadZero (guard)\n-- | import Data.Array ((..))\n-- |\n-- | factors :: Int -> Array Int\n-- | factors n = do\n-- |   a <- 1..n\n-- |   b <- 1..n\n-- |   guard $ a * b == n\n-- |   pure a\n-- | ```\nguard :: forall m. MonadZero m => Boolean -> m Unit\nguard true = pure unit\nguard false = empty\n","module Control.MonadPlus\n  ( class MonadPlus\n  , module Control.Alt\n  , module Control.Alternative\n  , module Control.Applicative\n  , module Control.Apply\n  , module Control.Bind\n  , module Control.Monad\n  , module Control.MonadZero\n  , module Control.Plus\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Applicative (class Applicative, pure, liftA1, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\nimport Control.Monad (class Monad, ap, liftM1)\nimport Control.MonadZero (class MonadZero, guard)\nimport Control.Plus (class Plus, empty)\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `MonadPlus` type class has no members of its own but extends\n-- | `MonadZero` with an additional law:\n-- |\n-- | - Distributivity: `(x <|> y) >>= f == (x >>= f) <|> (y >>= f)`\nclass MonadZero m <= MonadPlus m\n\ninstance monadPlusArray :: MonadPlus Array\n","module Control.Monad\n  ( class Monad\n  , liftM1\n  , ap\n  , whenM\n  , unlessM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  , module Control.Bind\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Bind (class Bind, bind, ifM, join, (<=<), (=<<), (>=>), (>>=))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\n\n-- | The `Monad` type class combines the operations of the `Bind` and\n-- | `Applicative` type classes. Therefore, `Monad` instances represent type\n-- | constructors which support sequential composition, and also lifting of\n-- | functions of arbitrary arity.\n-- |\n-- | Instances must satisfy the following laws in addition to the\n-- | `Applicative` and `Bind` laws:\n-- |\n-- | - Left Identity: `pure x >>= f = f x`\n-- | - Right Identity: `x >>= pure = x`\n-- | - Applicative Superclass: `apply = ap`\nclass (Applicative m, Bind m) <= Monad m\n\ninstance monadFn :: Monad ((->) r)\ninstance monadArray :: Monad Array\n\n-- | `liftM1` provides a default implementation of `(<$>)` for any\n-- | [`Monad`](#monad), without using `(<$>)` as provided by the\n-- | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n-- |\n-- | `liftM1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftM1\n-- | ```\nliftM1 :: forall m a b. Monad m => (a -> b) -> m a -> m b\nliftM1 f a = do\n  a' <- a\n  pure (f a')\n\n-- | `ap` provides a default implementation of `(<*>)` for any\n-- | [`Monad`](#monad), without using `(<*>)` as provided by the\n-- | [`Apply`](#apply)-[`Monad`](#monad) superclass relationship.\n-- |\n-- | `ap` can therefore be used to write [`Apply`](#apply) instances as\n-- | follows:\n-- |\n-- | ```purescript\n-- | instance applyF :: Apply F where\n-- |   apply = ap\n-- | ```\nap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\nap f a = do\n  f' <- f\n  a' <- a\n  pure (f' a')\n\n-- | Perform a monadic action when a condition is true, where the conditional\n-- | value is also in a monadic context.\nwhenM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nwhenM mb m = do\n  b <- mb\n  when b m\n\n-- | Perform a monadic action unless a condition is true, where the conditional\n-- | value is also in a monadic context.\nunlessM :: forall m. Monad m => m Boolean -> m Unit -> m Unit\nunlessM mb m =  do\n  b <- mb\n  unless b m\n","-- | This module defines the `MonadWriter` type class and its instances.\n\nmodule Control.Monad.Writer.Class where\n\nimport Prelude\n\nimport Data.Tuple (Tuple(..))\n\n-- | The `MonadTell w` type class represents those monads which support a\n-- | monoidal accumulator of type `w`, where `tell` appends a value to the\n-- | accumulator.\n-- |\n-- | An implementation is provided for `WriterT`, and for other monad\n-- | transformers defined in this library.\n-- |\n-- | Law:\n-- |\n-- | - `do { tell x ; tell y } = tell (x <> y)`\nclass Monad m <= MonadTell w m | m -> w where\n  tell :: w -> m Unit\n\n-- | An extension of the `MonadTell` class that introduces some operations on\n-- | the accumulator:\n-- |\n-- | - `listen` modifies the result to include the changes to the accumulator.\n-- | - `pass` applies the returned function to the accumulator.\n-- |\n-- | An implementation is provided for `WriterT`, and for other monad\n-- | transformers defined in this library.\n-- |\n-- | Laws in addition to the `MonadTell` law:\n-- |\n-- | - `do { tell x ; tell y } = tell (x <> y)`\n-- | - `listen (pure a) = pure (Tuple a mempty)`\n-- | - `listen (writer a x) = tell x $> Tuple a x`\nclass MonadTell w m <= MonadWriter w m | m -> w where\n  listen :: forall a. m a -> m (Tuple a w)\n  pass :: forall a. m (Tuple a (w -> w)) -> m a\n\n-- | Projects a value from modifications made to the accumulator during an\n-- | action.\nlistens :: forall w m a b. MonadWriter w m => (w -> b) -> m a -> m (Tuple a b)\nlistens f m = do\n  Tuple a w <- listen m\n  pure $ Tuple a (f w)\n\n-- | Modify the final accumulator value by applying a function.\ncensor :: forall w m a. MonadWriter w m => (w -> w) -> m a -> m a\ncensor f m = pass do\n  a <- m\n  pure $ Tuple a f\n","-- | This module defines the `MonadTrans` type class of _monad transformers_.\n\nmodule Control.Monad.Trans.Class where\n\nimport Prelude (class Monad)\n\n-- | The `MonadTrans` type class represents _monad transformers_.\n-- |\n-- | A monad transformer is a type constructor of kind `(* -> *) -> * -> *`, which\n-- | takes a `Monad` as its first argument, and returns another `Monad`.\n-- |\n-- | This allows us to add additional effects to an existing monad. By iterating this\n-- | process, we create monad transformer _stacks_, which contain all of the effects\n-- | required for a particular computation.\n-- |\n-- | The laws state that `lift` is a `Monad` morphism.\n-- |\n-- | Laws:\n-- |\n-- | - `lift (pure a) = pure a`\n-- | - `lift (do { x <- m ; y }) = do { x <- lift m ; lift y }`\nclass MonadTrans t where\n  lift :: forall m a. Monad m => m a -> t m a\n","-- | This module defines the state monad transformer, `StateT`.\n\nmodule Control.Monad.State.Trans\n  ( StateT(..), runStateT, evalStateT, execStateT, mapStateT, withStateT\n  , module Control.Monad.Trans.Class\n  , module Control.Monad.State.Class\n  ) where\n\nimport Prelude\n\nimport Control.Alt (class Alt, (<|>))\nimport Control.Alternative (class Alternative)\nimport Control.Lazy (class Lazy)\nimport Control.Monad.Cont.Class (class MonadCont, callCC)\nimport Control.Monad.Error.Class (class MonadThrow, class MonadError, catchError, throwError)\nimport Control.Monad.Reader.Class (class MonadAsk, class MonadReader, ask, local)\nimport Control.Monad.Rec.Class (class MonadRec, tailRecM, Step(..))\nimport Control.Monad.State.Class (class MonadState, get, gets, modify, modify_, put, state)\nimport Control.Monad.Trans.Class (class MonadTrans, lift)\nimport Control.Monad.Writer.Class (class MonadWriter, class MonadTell, pass, listen, tell)\nimport Control.MonadPlus (class MonadPlus)\nimport Control.MonadZero (class MonadZero)\nimport Control.Plus (class Plus, empty)\nimport Data.Newtype (class Newtype)\nimport Data.Tuple (Tuple(..), fst, snd)\nimport Effect.Class (class MonadEffect, liftEffect)\n\n-- | The state monad transformer.\n-- |\n-- | This monad transformer extends the base monad with the operations `get`\n-- | and `put` which can be used to model a single piece of mutable state.\n-- |\n-- | The `MonadState` type class describes the operations supported by this monad.\nnewtype StateT s m a = StateT (s -> m (Tuple a s))\n\n-- | Run a computation in the `StateT` monad.\nrunStateT :: forall s m a. StateT s m a -> s -> m (Tuple a s)\nrunStateT (StateT s) = s\n\n-- | Run a computation in the `StateT` monad, discarding the final state.\nevalStateT :: forall s m a. Functor m => StateT s m a -> s -> m a\nevalStateT (StateT m) s = fst <$> m s\n\n-- | Run a computation in the `StateT` monad discarding the result.\nexecStateT :: forall s m a. Functor m => StateT s m a -> s -> m s\nexecStateT (StateT m) s = snd <$> m s\n\n-- | Change the result type in a `StateT` monad action.\nmapStateT :: forall s m1 m2 a b. (m1 (Tuple a s) -> m2 (Tuple b s)) -> StateT s m1 a -> StateT s m2 b\nmapStateT f (StateT m) = StateT (f <<< m)\n\n-- | Modify the final state in a `StateT` monad action.\nwithStateT :: forall s m a. (s -> s) -> StateT s m a -> StateT s m a\nwithStateT f (StateT s) = StateT (s <<< f)\n\nderive instance newtypeStateT :: Newtype (StateT s m a) _\n\ninstance functorStateT :: Functor m => Functor (StateT s m) where\n  map f (StateT a) = StateT (\\s -> map (\\(Tuple b s') -> Tuple (f b) s') (a s))\n\ninstance applyStateT :: Monad m => Apply (StateT s m) where\n  apply = ap\n\ninstance applicativeStateT :: Monad m => Applicative (StateT s m) where\n  pure a = StateT \\s -> pure $ Tuple a s\n\ninstance altStateT :: (Monad m, Alt m) => Alt (StateT s m) where\n  alt (StateT x) (StateT y) = StateT \\s -> x s <|> y s\n\ninstance plusStateT :: (Monad m, Plus m) => Plus (StateT s m) where\n  empty = StateT \\_ -> empty\n\ninstance alternativeStateT :: (Monad m, Alternative m) => Alternative (StateT s m)\n\ninstance bindStateT :: Monad m => Bind (StateT s m) where\n  bind (StateT x) f = StateT \\s ->\n    x s >>= \\(Tuple v s') -> case f v of StateT st -> st s'\n\ninstance monadStateT :: Monad m => Monad (StateT s m)\n\ninstance monadRecStateT :: MonadRec m => MonadRec (StateT s m) where\n  tailRecM f a = StateT \\s -> tailRecM f' (Tuple a s)\n    where\n    f' (Tuple a' s) =\n      case f a' of StateT st ->\n        st s >>= \\(Tuple m s1) ->\n          pure case m of\n            Loop x -> Loop (Tuple x s1)\n            Done y -> Done (Tuple y s1)\n\ninstance monadZeroStateT :: MonadZero m => MonadZero (StateT s m)\n\ninstance monadPlusStateT :: MonadPlus m => MonadPlus (StateT s m)\n\ninstance monadTransStateT :: MonadTrans (StateT s) where\n  lift m = StateT \\s -> do\n    x <- m\n    pure $ Tuple x s\n\ninstance lazyStateT :: Lazy (StateT s m a) where\n  defer f = StateT \\s -> case f unit of StateT f' -> f' s\n\ninstance monadEffectState :: MonadEffect m => MonadEffect (StateT s m) where\n  liftEffect = lift <<< liftEffect\n\ninstance monadContStateT :: MonadCont m => MonadCont (StateT s m) where\n  callCC f = StateT \\s -> callCC \\c ->\n    case f (\\a -> StateT \\s' -> c (Tuple a s')) of StateT f' -> f' s\n\ninstance monadThrowStateT :: MonadThrow e m => MonadThrow e (StateT s m) where\n  throwError e = lift (throwError e)\n\ninstance monadErrorStateT :: MonadError e m => MonadError e (StateT s m) where\n  catchError (StateT m) h =\n    StateT \\s -> catchError (m s) (\\e -> case h e of StateT f -> f s)\n\ninstance monadAskStateT :: MonadAsk r m => MonadAsk r (StateT s m) where\n  ask = lift ask\n\ninstance monadReaderStateT :: MonadReader r m => MonadReader r (StateT s m) where\n  local = mapStateT <<< local\n\ninstance monadStateStateT :: Monad m => MonadState s (StateT s m) where\n  state f = StateT $ pure <<< f\n\ninstance monadTellStateT :: MonadTell w m => MonadTell w (StateT s m) where\n  tell = lift <<< tell\n\ninstance monadWriterStateT :: MonadWriter w m => MonadWriter w (StateT s m) where\n  listen m = StateT \\s ->\n    case m of\n      StateT m' -> do\n        Tuple (Tuple a s') w <- listen (m' s)\n        pure $ Tuple (Tuple a w) s'\n  pass m = StateT \\s -> pass\n    case m of\n      StateT m' -> do\n        Tuple (Tuple a f) s' <- m' s\n        pure $ Tuple (Tuple a s') f\n","-- | This module defines the `MonadState` type class and its instances.\n\nmodule Control.Monad.State.Class where\n\nimport Prelude (class Monad, Unit, unit)\n\nimport Data.Tuple (Tuple(..))\n\n-- | The `MonadState s` type class represents those monads which support a single piece of mutable\n-- | state of type `s`.\n-- |\n-- | - `state f` updates the state using the function `f`.\n-- |\n-- | An implementation is provided for `StateT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - `do { get ; get } = get`\n-- | - `do { put x ; put y } = put y`\n-- | - `do { put x ; get } = put x $> x`\n-- | - `do { s <- get ; put s } = pure unit`\n-- |\nclass Monad m <= MonadState s m | m -> s where\n  state :: forall a. (s -> (Tuple a s)) -> m a\n\n-- | Get the current state.\nget :: forall m s. MonadState s m => m s\nget = state \\s -> Tuple s s\n\n-- | Get a value which depends on the current state.\ngets :: forall s m a. MonadState s m => (s -> a) -> m a\ngets f = state \\s -> Tuple (f s) s\n\n-- | Set the state.\nput :: forall m s. MonadState s m => s -> m Unit\nput s = state \\_ -> Tuple unit s\n\n-- | Modify the state by applying a function to the current state. The returned\n-- | value is the new state value.\nmodify :: forall s m. MonadState s m => (s -> s) -> m s\nmodify f = state \\s -> let s' = f s in Tuple s' s'\n\nmodify_ :: forall s m. MonadState s m => (s -> s) -> m Unit\nmodify_ f = state \\s -> Tuple unit (f s)\n","module Control.Monad.ST.Internal where\n\nimport Prelude\n\nimport Control.Monad.Rec.Class (class MonadRec, Step(..))\nimport Partial.Unsafe (unsafePartial)\n\n-- | `ST` is concerned with _restricted_ mutation. Mutation is restricted to a\n-- | _region_ of mutable references. This kind is inhabited by phantom types\n-- | which represent regions in the type system.\nforeign import kind Region\n\n-- | The `ST` type constructor allows _local mutation_, i.e. mutation which\n-- | does not \"escape\" into the surrounding computation.\n-- |\n-- | An `ST` computation is parameterized by a phantom type which is used to\n-- | restrict the set of reference cells it is allowed to access.\n-- |\n-- | The `run` function can be used to run a computation in the `ST` monad.\nforeign import data ST :: Region -> Type -> Type\n\nforeign import map_ :: forall r a b. (a -> b) -> ST r a -> ST r b\n\nforeign import pure_ :: forall r a. a -> ST r a\n\nforeign import bind_ :: forall r a b. ST r a -> (a -> ST r b) -> ST r b\n\ninstance functorST :: Functor (ST r) where\n  map = map_\n\ninstance applyST :: Apply (ST r) where\n  apply = ap\n\ninstance applicativeST :: Applicative (ST r) where\n  pure = pure_\n\ninstance bindST :: Bind (ST r) where\n  bind = bind_\n\ninstance monadST :: Monad (ST r)\n\ninstance monadRecST :: MonadRec (ST r) where\n  tailRecM f a = do\n    r <- new =<< f a\n    while (isLooping <$> read r) do\n      read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          void (write e r)\n        Done b -> pure unit\n    fromDone <$> read r\n    where\n      fromDone :: forall a b. Step a b -> b\n      fromDone = unsafePartial \\(Done b) -> b\n\n      isLooping = case _ of\n        Loop _ -> true\n        _ -> false\n\n-- | Run an `ST` computation.\n-- |\n-- | Note: the type of `run` uses a rank-2 type to constrain the phantom\n-- | type `h`, such that the computation must not leak any mutable references\n-- | to the surrounding computation. It may cause problems to apply this\n-- | function using the `$` operator. The recommended approach is to use\n-- | parentheses instead.\nforeign import run :: forall a. (forall r. ST r a) -> a\n\n-- | Loop while a condition is `true`.\n-- |\n-- | `while b m` is ST computation which runs the ST computation `b`. If its\n-- | result is `true`, it runs the ST computation `m` and loops. If not, the\n-- | computation ends.\nforeign import while :: forall r a. ST r Boolean -> ST r a -> ST r Unit\n\n-- | Loop over a consecutive collection of numbers\n-- |\n-- | `ST.for lo hi f` runs the computation returned by the function `f` for each\n-- | of the inputs between `lo` (inclusive) and `hi` (exclusive).\nforeign import for :: forall r a. Int -> Int -> (Int -> ST r a) -> ST r Unit\n\n-- | Loop over an array of values.\n-- |\n-- | `ST.foreach xs f` runs the computation returned by the function `f` for each\n-- | of the inputs `xs`.\nforeign import foreach :: forall r a. Array a -> (a -> ST r Unit) -> ST r Unit\n\n-- | The type `STRef r a` represents a mutable reference holding a value of\n-- | type `a`, which can be used with the `ST r` effect.\nforeign import data STRef :: Region -> Type -> Type\n\n-- | Create a new mutable reference.\nforeign import new :: forall a r. a -> ST r (STRef r a)\n\n-- | Read the current value of a mutable reference.\nforeign import read :: forall a r. STRef r a -> ST r a\n\n-- | Update the value of a mutable reference by applying a function\n-- | to the current value, computing a new state value for the reference and\n-- | a return value.\nforeign import modify' :: forall r a b. (a -> { state :: a, value :: b }) -> STRef r a -> ST r b\n\n-- | Modify the value of a mutable reference by applying a function to the\n-- | current value. The modified value is returned.\nmodify :: forall r a. (a -> a) -> STRef r a -> ST r a\nmodify f = modify' \\s -> let s' = f s in { state: s', value: s' }\n\n-- | Set the value of a mutable reference.\nforeign import write :: forall a r. a -> STRef r a -> ST r a\n","\"use strict\";\n\nexports.map_ = function (f) {\n  return function (a) {\n    return function () {\n      return f(a());\n    };\n  };\n};\n\nexports.pure_ = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexports.bind_ = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexports.run = function (f) {\n  return f();\n};\n\nexports[\"while\"] = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexports[\"for\"] = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexports.foreach = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n\nexports.new = function (val) {\n  return function () {\n    return { value: val };\n  };\n};\n\nexports.read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexports[\"modify'\"] = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexports.write = function (a) {\n  return function (ref) {\n    return function () {\n      return ref.value = a; // eslint-disable-line no-return-assign\n    };\n  };\n};\n","module Control.Monad.Rec.Class\n  ( Step(..)\n  , class MonadRec\n  , tailRec\n  , tailRecM\n  , tailRecM2\n  , tailRecM3\n  , forever\n  , whileJust\n  , untilJust\n  ) where\n\nimport Prelude\n\nimport Data.Bifunctor (class Bifunctor)\nimport Data.Either (Either(..))\nimport Data.Identity (Identity(..))\nimport Data.Maybe (Maybe(..))\nimport Effect (Effect, untilE)\nimport Effect.Ref as Ref\nimport Partial.Unsafe (unsafePartial)\n\n-- | The result of a computation: either `Loop` containing the updated\n-- | accumulator, or `Done` containing the final result of the computation.\ndata Step a b = Loop a | Done b\n\nderive instance functorStep :: Functor (Step a)\n\ninstance bifunctorStep :: Bifunctor Step where\n  bimap f _ (Loop a) = Loop (f a)\n  bimap _ g (Done b) = Done (g b)\n\n-- | This type class captures those monads which support tail recursion in\n-- | constant stack space.\n-- |\n-- | The `tailRecM` function takes a step function, and applies that step\n-- | function recursively until a pure value of type `b` is found.\n-- |\n-- | Instances are provided for standard monad transformers.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | loopWriter :: Int -> WriterT (Additive Int) Effect Unit\n-- | loopWriter n = tailRecM go n\n-- |   where\n-- |   go 0 = do\n-- |     traceM \"Done!\"\n-- |     pure (Done unit)\n-- |   go i = do\n-- |     tell $ Additive i\n-- |     pure (Loop (i - 1))\n-- | ```\nclass Monad m <= MonadRec m where\n  tailRecM :: forall a b. (a -> m (Step a b)) -> a -> m b\n\n-- | Create a tail-recursive function of two arguments which uses constant stack space.\ntailRecM2\n  :: forall m a b c\n   . MonadRec m\n  => (a -> b -> m (Step { a :: a, b :: b } c))\n  -> a\n  -> b\n  -> m c\ntailRecM2 f a b = tailRecM (\\o -> f o.a o.b) { a, b }\n\n-- | Create a tail-recursive function of three arguments which uses constant stack space.\ntailRecM3\n  :: forall m a b c d\n   . MonadRec m\n  => (a -> b -> c -> m (Step { a :: a, b :: b, c :: c } d))\n  -> a\n  -> b\n  -> c\n  -> m d\ntailRecM3 f a b c = tailRecM (\\o -> f o.a o.b o.c) { a, b, c }\n\n-- | Create a pure tail-recursive function of one argument\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | pow :: Number -> Number -> Number\n-- | pow n p = tailRec go { accum: 1, power: p }\n-- |   where\n-- |   go :: _ -> Step _ Number\n-- |   go { accum: acc, power: 0 } = Done acc\n-- |   go { accum: acc, power: p } = Loop { accum: acc * n, power: p - 1 }\n-- | ```\ntailRec :: forall a b. (a -> Step a b) -> a -> b\ntailRec f = go <<< f\n  where\n  go (Loop a) = go (f a)\n  go (Done b) = b\n\ninstance monadRecIdentity :: MonadRec Identity where\n  tailRecM f = Identity <<< tailRec (runIdentity <<< f)\n    where runIdentity (Identity x) = x\n\ninstance monadRecEffect :: MonadRec Effect where\n  tailRecM f a = do\n    r <- Ref.new =<< f a\n    untilE do\n      Ref.read r >>= case _ of\n        Loop a' -> do\n          e <- f a'\n          _ <- Ref.write e r\n          pure false\n        Done b -> pure true\n    fromDone <$> Ref.read r\n    where\n    fromDone :: forall a b. Step a b -> b\n    fromDone = unsafePartial \\(Done b) -> b\n\ninstance monadRecFunction :: MonadRec ((->) e) where\n  tailRecM f a0 e = tailRec (\\a -> f a e) a0\n\ninstance monadRecEither :: MonadRec (Either e) where\n  tailRecM f a0 =\n    let\n      g (Left e) = Done (Left e)\n      g (Right (Loop a)) = Loop (f a)\n      g (Right (Done b)) = Done (Right b)\n    in tailRec g (f a0)\n\ninstance monadRecMaybe :: MonadRec Maybe where\n  tailRecM f a0 =\n    let\n      g Nothing = Done Nothing\n      g (Just (Loop a)) = Loop (f a)\n      g (Just (Done b)) = Done (Just b)\n    in tailRec g (f a0)\n\n-- | `forever` runs an action indefinitely, using the `MonadRec` instance to\n-- | ensure constant stack usage.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = forever $ trace \"Hello, World!\"\n-- | ```\nforever :: forall m a b. MonadRec m => m a -> m b\nforever ma = tailRecM (\\u -> Loop u <$ ma) unit\n\n-- | While supplied computation evaluates to `Just _`, it will be\n-- | executed repeatedly and results will be combined using monoid instance.\nwhileJust :: forall a m. Monoid a => MonadRec m => m (Maybe a) -> m a\nwhileJust m = mempty # tailRecM \\v -> m <#> case _ of\n  Nothing -> Done v\n  Just x -> Loop $ v <> x\n\n-- | Supplied computation will be executed repeatedly until it evaluates\n-- | to `Just value` and then that `value` will be returned.\nuntilJust :: forall a m. MonadRec m => m (Maybe a) -> m a\nuntilJust m = unit # tailRecM \\_ -> m <#> case _ of\n  Nothing -> Loop unit\n  Just x -> Done x\n","-- | This module defines the `MonadReader` type class and its instances.\n\nmodule Control.Monad.Reader.Class where\n\nimport Prelude\n\n-- | The `MonadAsk` type class represents those monads which support a global\n-- | context that can be provided via the `ask` function.\n-- |\n-- | An implementation is provided for `ReaderT`, and for other monad\n-- | transformers defined in this library.\n-- |\n-- | Law:\n-- |\n-- | - `do { ask ; ask } = ask`\nclass Monad m <= MonadAsk r m | m -> r where\n  ask :: m r\n\ninstance monadAskFun :: MonadAsk r ((->) r) where\n  ask = identity\n\n-- | Projects a value from the global context in a `MonadAsk`.\nasks :: forall r m a. MonadAsk r m => (r -> a) -> m a\nasks f = f <$> ask\n\n-- | An extension of the `MonadAsk` class that introduces a function `local f x`\n-- | that allows the value of the local context to be modified for the duration\n-- | of the execution of action `x`.\n-- |\n-- | An implementation is provided for `ReaderT`, and for other monad\n-- | transformers defined in this library.\n-- |\n-- | Laws in addition to the `MonadAsk` law:\n-- |\n-- | - `local f ask = f <$> ask`\n-- | - `local _ (pure a) = pure a`\n-- | - `local f (do { a <- x ; y }) = do { a <- local f x ; local f y }`\nclass MonadAsk r m <= MonadReader r m | m -> r where\n  local :: forall a. (r -> r) -> m a -> m a\n\ninstance monadReaderFun :: MonadReader r ((->) r) where\n  local = (>>>)\n","-- | This module defines the `MonadError` type class and its instances.\n\nmodule Control.Monad.Error.Class where\n\nimport Prelude\n\nimport Data.Maybe (Maybe(..))\nimport Data.Either (Either(..), either)\nimport Effect (Effect)\nimport Effect.Exception as Ex\n\n\n-- | The `MonadThrow` type class represents those monads which support errors via\n-- | `throwError`, where `throwError e` halts, yielding the error `e`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Left zero: `throwError e >>= f = throwError e`\n-- |\nclass Monad m <= MonadThrow e m | m -> e where\n  throwError :: forall a. e -> m a\n\n-- | The `MonadError` type class represents those monads which support catching\n-- | errors.\n-- |\n-- | - `catchError x f` calls the error handler `f` if an error is thrown during the\n-- |   evaluation of `x`.\n-- |\n-- | An implementation is provided for `ExceptT`, and for other monad transformers\n-- | defined in this library.\n-- |\n-- | Laws:\n-- |\n-- | - Catch: `catchError (throwError e) f = f e`\n-- | - Pure: `catchError (pure a) f = pure a`\n-- |\nclass MonadThrow e m <= MonadError e m | m -> e where\n  catchError :: forall a. m a -> (e -> m a) -> m a\n\n-- | This function allows you to provide a predicate for selecting the\n-- | exceptions that you're interested in, and handle only those exceptons.\n-- | If the inner computation throws an exception, and the predicate returns\n-- | Nothing, then the whole computation will still fail with that exception.\ncatchJust\n  :: forall e m a b\n   . MonadError e m\n  => (e -> Maybe b) -- ^ Predicate to select exceptions\n  -> m a            -- ^ Computation to run\n  -> (b -> m a)     -- ^ Handler\n  -> m a\ncatchJust p act handler = catchError act handle\n  where\n  handle e =\n    case p e of\n      Nothing -> throwError e\n      Just b -> handler b\n\n-- | Return `Right` if the given action succeeds, `Left` if it throws.\ntry\n  :: forall e m a\n   . MonadError e m\n  => m a\n  -> m (Either e a)\ntry a = (Right <$> a) `catchError` (pure <<< Left)\n\ninstance monadThrowEither :: MonadThrow e (Either e) where\n  throwError = Left\n\ninstance monadErrorEither :: MonadError e (Either e) where\n  catchError (Left e) h = h e\n  catchError (Right x) _ = Right x\n\ninstance monadThrowMaybe :: MonadThrow Unit Maybe where\n  throwError = const Nothing\n\ninstance monadErrorMaybe :: MonadError Unit Maybe where\n  catchError Nothing f  = f unit\n  catchError (Just a) _ = Just a\n \ninstance monadThrowEffect :: MonadThrow Ex.Error Effect where\n  throwError = Ex.throwException\n\ninstance monadErrorEffect :: MonadError Ex.Error Effect where\n  catchError = flip Ex.catchException\n\n\n-- | Make sure that a resource is cleaned up in the event of an exception. The\n-- | release action is called regardless of whether the body action throws or\n-- | returns.\nwithResource\n  :: forall e m r a\n   . MonadError e m\n  => m r\n  -> (r -> m Unit)\n  -> (r -> m a)\n  -> m a\nwithResource acquire release kleisli = do\n  resource <- acquire\n  result <- try $ kleisli resource\n  release resource\n  either throwError pure result\n","-- | This module defines the `MonadCont` type class and its instances.\n\nmodule Control.Monad.Cont.Class\n  ( class MonadCont\n  , callCC\n  ) where\n\nimport Prelude (class Monad)\n\n-- | The `MonadCont` type class represents those monads which support the\n-- | `callCC`, or _call-with-current-continuation_ operation.\n-- |\n-- | This action makes the current continuation available to the caller.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | delay :: forall eff. Number -> ContT Unit (Eff (timeout :: Timeout | eff)) Unit\n-- | delay n = callCC \\cont ->\n-- |   lift $ setTimeout n (runContT (cont unit) (\\_ -> return unit))\n-- | ```\n-- | An implementation is provided for `ContT`, and for other monad transformers\n-- | defined in this library.\nclass Monad m <= MonadCont m where\n  callCC :: forall a. ((forall b. a -> m b) -> m a) -> m a\n","module Control.Lazy where\n\nimport Data.Unit (Unit, unit)\n\n-- | The `Lazy` class represents types which allow evaluation of values\n-- | to be _deferred_.\n-- |\n-- | Usually, this means that a type contains a function arrow which can\n-- | be used to delay evaluation.\nclass Lazy l where\n  defer :: (Unit -> l) -> l\n\ninstance lazyFn :: Lazy (a -> b) where\n  defer f = \\x -> f unit x\n\ninstance lazyUnit :: Lazy Unit where\n  defer _ = unit\n\n-- | `fix` defines a value as the fixed point of a function.\n-- |\n-- | The `Lazy` instance allows us to generate the result lazily.\nfix :: forall l. Lazy l => (l -> l) -> l\nfix f = go\n  where\n    go = defer \\_ -> f go\n","module Control.Extend\n  ( class Extend, extend, (<<=), extendFlipped, (=>>)\n  , composeCoKleisli, (=>=)\n  , composeCoKleisliFlipped, (=<=)\n  , duplicate\n  , module Data.Functor\n  ) where\n\nimport Control.Category (identity)\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (class Semigroup, (<>))\n\n-- | The `Extend` class defines the extension operator `(<<=)`\n-- | which extends a local context-dependent computation to\n-- | a global computation.\n-- |\n-- | `Extend` is the dual of `Bind`, and `(<<=)` is the dual of\n-- | `(>>=)`.\n-- |\n-- | Laws:\n-- |\n-- | - Associativity: `extend f <<< extend g = extend (f <<< extend g)`\nclass Functor w <= Extend w where\n  extend :: forall b a. (w a -> b) -> w a -> w b\n\ninstance extendFn :: Semigroup w => Extend ((->) w) where\n  extend f g w = f \\w' -> g (w <> w')\n\nforeign import arrayExtend :: forall a b. (Array a -> b) -> Array a -> Array b\n\ninstance extendArray :: Extend Array where\n  extend = arrayExtend\n\ninfixr 1 extend as <<=\n\n-- | A version of `extend` with its arguments flipped.\nextendFlipped :: forall b a w. Extend w => w a -> (w a -> b) -> w b\nextendFlipped w f = f <<= w\n\ninfixl 1 extendFlipped as =>>\n\n-- | Forwards co-Kleisli composition.\ncomposeCoKleisli :: forall b a w c. Extend w => (w a -> b) -> (w b -> c) -> w a -> c\ncomposeCoKleisli f g w = g (f <<= w)\n\ninfixr 1 composeCoKleisli as =>=\n\n-- | Backwards co-Kleisli composition.\ncomposeCoKleisliFlipped :: forall b a w c. Extend w => (w b -> c) -> (w a -> b) -> w a -> c\ncomposeCoKleisliFlipped f g w = f (g <<= w)\n\ninfixr 1 composeCoKleisliFlipped as =<=\n\n-- | Duplicate a comonadic context.\n-- |\n-- | `duplicate` is dual to `Control.Bind.join`.\nduplicate :: forall a w. Extend w => w a -> w (w a)\nduplicate = extend identity\n","\"use strict\";\n\nexports.arrayExtend = function(f) {\n  return function(xs) {\n    return xs.map(function (_, i, xs) {\n      return f(xs.slice(i));\n    });\n  };\n};\n","module Control.Comonad\n  ( class Comonad, extract\n  , module Control.Extend\n  , module Data.Functor\n  ) where\n\nimport Control.Extend (class Extend, duplicate, extend, (<<=), (=<=), (=>=), (=>>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | `Comonad` extends the `Extend` class with the `extract` function\n-- | which extracts a value, discarding the comonadic context.\n-- |\n-- | `Comonad` is the dual of `Monad`, and `extract` is the dual of `pure`.\n-- |\n-- | Laws:\n-- |\n-- | - Left Identity: `extract <<= xs = xs`\n-- | - Right Identity: `extract (f <<= xs) = f xs`\nclass Extend w <= Comonad w where\n  extract :: forall a. w a -> a\n","module Control.Category\n  ( class Category, identity\n  , module Control.Semigroupoid\n  ) where\n\nimport Control.Semigroupoid (class Semigroupoid, compose, (<<<), (>>>))\n\n-- | `Category`s consist of objects and composable morphisms between them, and\n-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\n-- | must have an identity element.\n-- |\n-- | Instances must satisfy the following law in addition to the\n-- | `Semigroupoid` law:\n-- |\n-- | - Identity: `identity <<< p = p <<< identity = p`\nclass Semigroupoid a <= Category a where\n  identity :: forall t. a t t\n\ninstance categoryFn :: Category (->) where\n  identity x = x\n","module Control.Bind\n  ( class Bind, bind, (>>=)\n  , bindFlipped, (=<<)\n  , class Discard, discard\n  , join\n  , composeKleisli, (>=>)\n  , composeKleisliFlipped, (<=<)\n  , ifM\n  , module Data.Functor\n  , module Control.Apply\n  , module Control.Applicative\n  ) where\n\nimport Control.Applicative (class Applicative, liftA1, pure, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Category (identity)\n\nimport Data.Function (flip)\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit)\n\n-- | The `Bind` type class extends the [`Apply`](#apply) type class with a\n-- | \"bind\" operation `(>>=)` which composes computations in sequence, using\n-- | the return value of one computation to determine the next computation.\n-- |\n-- | The `>>=` operator can also be expressed using `do` notation, as follows:\n-- |\n-- | ```purescript\n-- | x >>= f = do y <- x\n-- |              f y\n-- | ```\n-- |\n-- | where the function argument of `f` is given the name `y`.\n-- |\n-- | Instances must satisfy the following law in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Associativity: `(x >>= f) >>= g = x >>= (\\k -> f k >>= g)`\n-- |\n-- | Associativity tells us that we can regroup operations which use `do`\n-- | notation so that we can unambiguously write, for example:\n-- |\n-- | ```purescript\n-- | do x <- m1\n-- |    y <- m2 x\n-- |    m3 x y\n-- | ```\nclass Apply m <= Bind m where\n  bind :: forall a b. m a -> (a -> m b) -> m b\n\ninfixl 1 bind as >>=\n\n-- | `bindFlipped` is `bind` with its arguments reversed. For example:\n-- |\n-- | ```purescript\n-- | print =<< random\n-- | ```\nbindFlipped :: forall m a b. Bind m => (a -> m b) -> m a -> m b\nbindFlipped = flip bind\n\ninfixr 1 bindFlipped as =<<\n\ninstance bindFn :: Bind ((->) r) where\n  bind m f x = f (m x) x\n\ninstance bindArray :: Bind Array where\n  bind = arrayBind\n\nforeign import arrayBind :: forall a b. Array a -> (a -> Array b) -> Array b\n\n-- | A class for types whose values can safely be discarded\n-- | in a `do` notation block.\n-- |\n-- | An example is the `Unit` type, since there is only one\n-- | possible value which can be returned.\nclass Discard a where\n  discard :: forall f b. Bind f => f a -> (a -> f b) -> f b\n\ninstance discardUnit :: Discard Unit where\n  discard = bind\n\n-- | Collapse two applications of a monadic type constructor into one.\njoin :: forall a m. Bind m => m (m a) -> m a\njoin m = m >>= identity\n\n-- | Forwards Kleisli composition.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | import Data.Array (head, tail)\n-- |\n-- | third = tail >=> tail >=> head\n-- | ```\ncomposeKleisli :: forall a b c m. Bind m => (a -> m b) -> (b -> m c) -> a -> m c\ncomposeKleisli f g a = f a >>= g\n\ninfixr 1 composeKleisli as >=>\n\n-- | Backwards Kleisli composition.\ncomposeKleisliFlipped :: forall a b c m. Bind m => (b -> m c) -> (a -> m b) -> a -> m c\ncomposeKleisliFlipped f g a = f =<< g a\n\ninfixr 1 composeKleisliFlipped as <=<\n\n-- | Execute a monadic action if a condition holds.\n-- |\n-- | For example:\n-- |\n-- | ```purescript\n-- | main = ifM ((< 0.5) <$> random)\n-- |          (trace \"Heads\")\n-- |          (trace \"Tails\")\n-- | ```\nifM :: forall a m. Bind m => m Boolean -> m a -> m a -> m a\nifM cond t f = cond >>= \\cond' -> if cond' then t else f\n","\"use strict\";\n\nexports.arrayBind = function (arr) {\n  return function (f) {\n    var result = [];\n    for (var i = 0, l = arr.length; i < l; i++) {\n      Array.prototype.push.apply(result, f(arr[i]));\n    }\n    return result;\n  };\n};\n","module Control.Biapply where\n\nimport Data.Function (const, identity)\n\nimport Data.Bifunctor (class Bifunctor, bimap)\n\n-- | A convenience operator which can be used to apply the result of `bipure` in\n-- | the style of `Applicative`:\n-- |\n-- | ```purescript\n-- | bipure f g <<$>> x <<*>> y\n-- | ```\ninfixl 4 identity as <<$>>\n\n-- | `Biapply` captures type constructors of two arguments which support lifting of\n-- | functions of one or more arguments, in the sense of `Apply`.\nclass Bifunctor w <= Biapply w where\n  biapply :: forall a b c d. w (a -> b) (c -> d) -> w a c -> w b d\n\ninfixl 4 biapply as <<*>>\n\n-- | Keep the results of the second computation.\nbiapplyFirst :: forall w a b c d. Biapply w => w a b -> w c d -> w c d\nbiapplyFirst a b = bimap (const identity) (const identity) <<$>> a <<*>> b\n\ninfixl 4 biapplyFirst as *>>\n\n-- | Keep the results of the first computation.\nbiapplySecond :: forall w a b c d. Biapply w => w a b -> w c d -> w a b\nbiapplySecond a b = bimap const const <<$>> a <<*>> b\n\ninfixl 4 biapplySecond as <<*\n\n-- | Lift a function of two arguments.\nbilift2\n  :: forall w a b c d e f\n   . Biapply w\n  => (a -> b -> c)\n  -> (d -> e -> f)\n  -> w a d\n  -> w b e\n  -> w c f\nbilift2 f g a b = bimap f g <<$>> a <<*>> b\n\n-- | Lift a function of three arguments.\nbilift3\n  :: forall w a b c d e f g h\n   . Biapply w\n  => (a -> b -> c -> d)\n  -> (e -> f -> g -> h)\n  -> w a e\n  -> w b f\n  -> w c g\n  -> w d h\nbilift3 f g a b c = bimap f g <<$>> a <<*>> b <<*>> c\n","module Control.Biapplicative where\n\nimport Control.Biapply (class Biapply)\n\n-- | `Biapplicative` captures type constructors of two arguments which support lifting of\n-- | functions of zero or more arguments, in the sense of `Applicative`.\nclass Biapply w <= Biapplicative w where\n  bipure :: forall a b. a -> b -> w a b\n","module Control.Apply\n  ( class Apply, apply, (<*>)\n  , applyFirst, (<*)\n  , applySecond, (*>)\n  , lift2, lift3, lift4, lift5\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Function (const)\nimport Control.Category (identity)\n\n-- | The `Apply` class provides the `(<*>)` which is used to apply a function\n-- | to an argument under a type constructor.\n-- |\n-- | `Apply` can be used to lift functions of two or more arguments to work on\n-- | values wrapped with the type constructor `f`. It might also be understood\n-- | in terms of the `lift2` function:\n-- |\n-- | ```purescript\n-- | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n-- | lift2 f a b = f <$> a <*> b\n-- | ```\n-- |\n-- | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\n-- | the function application operator `($)` to arguments wrapped with the\n-- | type constructor `f`.\n-- |\n-- | Instances must satisfy the following law in addition to the `Functor`\n-- | laws:\n-- |\n-- | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n-- |\n-- | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\nclass Functor f <= Apply f where\n  apply :: forall a b. f (a -> b) -> f a -> f b\n\ninfixl 4 apply as <*>\n\ninstance applyFn :: Apply ((->) r) where\n  apply f g x = f x (g x)\n\ninstance applyArray :: Apply Array where\n  apply = arrayApply\n\nforeign import arrayApply :: forall a b. Array (a -> b) -> Array a -> Array b\n\n-- | Combine two effectful actions, keeping only the result of the first.\napplyFirst :: forall a b f. Apply f => f a -> f b -> f a\napplyFirst a b = const <$> a <*> b\n\ninfixl 4 applyFirst as <*\n\n-- | Combine two effectful actions, keeping only the result of the second.\napplySecond :: forall a b f. Apply f => f a -> f b -> f b\napplySecond a b = const identity <$> a <*> b\n\ninfixl 4 applySecond as *>\n\n-- | Lift a function of two arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n\n-- | Lift a function of three arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift3 :: forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nlift3 f a b c = f <$> a <*> b <*> c\n\n-- | Lift a function of four arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift4 :: forall a b c d e f. Apply f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e\nlift4 f a b c d = f <$> a <*> b <*> c <*> d\n\n-- | Lift a function of five arguments to a function which accepts and returns\n-- | values wrapped with the type constructor `f`.\nlift5 :: forall a b c d e f g. Apply f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g\nlift5 f a b c d e = f <$> a <*> b <*> c <*> d <*> e\n","\"use strict\";\n\nexports.arrayApply = function (fs) {\n  return function (xs) {\n    var l = fs.length;\n    var k = xs.length;\n    var result = new Array(l*k);\n    var n = 0;\n    for (var i = 0; i < l; i++) {\n      var f = fs[i];\n      for (var j = 0; j < k; j++) {\n        result[n++] = f(xs[j]);\n      }\n    }\n    return result;\n  };\n};\n","module Control.Applicative\n  ( class Applicative, pure\n  , liftA1\n  , unless, when\n  , module Control.Apply\n  , module Data.Functor\n  ) where\n\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Unit (Unit, unit)\n\n-- | The `Applicative` type class extends the [`Apply`](#apply) type class\n-- | with a `pure` function, which can be used to create values of type `f a`\n-- | from values of type `a`.\n-- |\n-- | Where [`Apply`](#apply) provides the ability to lift functions of two or\n-- | more arguments to functions whose arguments are wrapped using `f`, and\n-- | [`Functor`](#functor) provides the ability to lift functions of one\n-- | argument, `pure` can be seen as the function which lifts functions of\n-- | _zero_ arguments. That is, `Applicative` functors support a lifting\n-- | operation for any number of function arguments.\n-- |\n-- | Instances must satisfy the following laws in addition to the `Apply`\n-- | laws:\n-- |\n-- | - Identity: `(pure identity) <*> v = v`\n-- | - Composition: `pure (<<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n-- | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n-- | - Interchange: `u <*> (pure y) = (pure (_ $ y)) <*> u`\nclass Apply f <= Applicative f where\n  pure :: forall a. a -> f a\n\ninstance applicativeFn :: Applicative ((->) r) where\n  pure x _ = x\n\ninstance applicativeArray :: Applicative Array where\n  pure x = [x]\n\n-- | `liftA1` provides a default implementation of `(<$>)` for any\n-- | [`Applicative`](#applicative) functor, without using `(<$>)` as provided\n-- | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\n-- | relationship.\n-- |\n-- | `liftA1` can therefore be used to write [`Functor`](#functor) instances\n-- | as follows:\n-- |\n-- | ```purescript\n-- | instance functorF :: Functor F where\n-- |   map = liftA1\n-- | ```\nliftA1 :: forall f a b. Applicative f => (a -> b) -> f a -> f b\nliftA1 f a = pure f <*> a\n\n-- | Perform an applicative action when a condition is true.\nwhen :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nwhen true m = m\nwhen false _ = pure unit\n\n-- | Perform an applicative action unless a condition is true.\nunless :: forall m. Applicative m => Boolean -> m Unit -> m Unit\nunless false m = m\nunless true _ = pure unit\n","module Control.Alternative\n  ( class Alternative\n  , module Control.Alt\n  , module Control.Applicative\n  , module Control.Apply\n  , module Control.Plus\n  , module Data.Functor\n  ) where\n\nimport Control.Alt (class Alt, alt, (<|>))\nimport Control.Applicative (class Applicative, pure, liftA1, unless, when)\nimport Control.Apply (class Apply, apply, (*>), (<*), (<*>))\nimport Control.Plus (class Plus, empty)\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\n\n-- | The `Alternative` type class has no members of its own; it just specifies\n-- | that the type constructor has both `Applicative` and `Plus` instances.\n-- |\n-- | Types which have `Alternative` instances should also satisfy the following\n-- | laws:\n-- |\n-- | - Distributivity: `(f <|> g) <*> x == (f <*> x) <|> (g <*> x)`\n-- | - Annihilation: `empty <*> f = empty`\nclass (Applicative f, Plus f) <= Alternative f\n\ninstance alternativeArray :: Alternative Array\n","module Control.Alt\n  ( class Alt, alt, (<|>)\n  , module Data.Functor\n  ) where\n\nimport Data.Functor (class Functor, map, void, ($>), (<#>), (<$), (<$>))\nimport Data.Semigroup (append)\n\n-- | The `Alt` type class identifies an associative operation on a type\n-- | constructor.  It is similar to `Semigroup`, except that it applies to\n-- | types of kind `* -> *`, like `Array` or `List`, rather than concrete types\n-- | `String` or `Number`.\n-- |\n-- | `Alt` instances are required to satisfy the following laws:\n-- |\n-- | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`\n-- | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`\n-- |\n-- | For example, the `Array` (`[]`) type is an instance of `Alt`, where\n-- | `(<|>)` is defined to be concatenation.\nclass Functor f <= Alt f where\n  alt :: forall a. f a -> f a -> f a\n\ninfixl 3 alt as <|>\n\ninstance altArray :: Alt Array where\n  alt = append\n","module Character where\n\nimport Board as Board\nimport Control.Monad.State.Class (class MonadState, modify, get, put)\nimport Data.Int (toNumber)\nimport Render as Render\nimport Effect (Effect)\nimport Effect.Class (class MonadEffect)\nimport Effect.Console (log)\nimport Effect.Random (randomRange)\nimport Prelude (Unit, bind, pure, (+), (-))\nimport Utils (Color)\n\ntype Position = { x :: Number, y :: Number }\n\ntype Character = \n    { pos :: Position\n    , color :: Color \n    }\n\ndata Direction = Up | Down | Left | Right | Unknown\n\ncreate :: Effect Character\ncreate = do\n    x <- randomRange 0.0 (toNumber Board.size.width)\n    y <- randomRange 0.0 (toNumber Board.size.height)\n\n    pure { pos: {x, y}, color }\n    where color = { r: 255.0, g: 255.0, b: 255.0, a: 0.0 }\n\n\nset :: forall m. MonadState Character m => MonadEffect m => Character -> m Unit\nset = put\n\nquery ::  forall m. MonadState Character m => MonadEffect m => m Character\nquery = get\n\nmove :: forall m. MonadState Character m => MonadEffect m => Direction -> m Character\nmove d = do\n    case d of\n        Up -> modify (\\s -> s { pos = { x: s.pos.x, y: s.pos.y + 10.0 } })\n        Down -> modify \\s -> s { pos = { x: s.pos.x, y: s.pos.y - 10.0 } }\n        Left -> modify \\s -> s { pos = { x: s.pos.x + 10.0, y: s.pos.y } }\n        Right -> modify \\s -> s { pos = { x: s.pos.x - 10.0, y: s.pos.y } }\n        Unknown -> get\n\n\ndraw :: Character -> Effect Unit\ndraw c = do\n    _ <- log \"drawing Character\"\n    Render.circle c.pos.x c.pos.y 10.0 c.color","module Board where\n\nimport Data.Array ((..))\nimport Data.Int (toNumber)\nimport Data.Traversable (for, for_)\nimport Render as Render\nimport Effect (Effect)\nimport Effect.Random (randomRange)\nimport Prelude (Unit, bind, pure, (-), (*))\nimport Utils (Color)\n\n\n\ntype Coords = { x :: Int, y :: Int}\ntype Cell = { coords :: Coords, color :: Color }\n\ntype Row = Array Cell\ntype Board  = Array Row\n\n\n\nsize :: { width :: Int, height :: Int, side :: Int }\nsize =\n    { width: 600\n    , height: 600\n    , side: 10\n    }\n\n\ncreateCell :: Int -> Int -> Effect Cell\ncreateCell x y = do\n    r <- randomRange 0.0 50.0\n    g <- randomRange 200.0 255.0\n    b <- randomRange 0.0 50.0\n\n    pure { coords: {x: x * size.side, y: y * size.side }, color: { r, g, b, a: 1.0 } }\n\n\ncreateRow :: Int -> Effect Row\ncreateRow y = \n    for cols \\x -> createCell x y\n        where cols = 0..(size.width - size.side)\n\ncreateBoard :: Effect Board\ncreateBoard =\n    for row createRow\n        where row = 0..(size.height - size.side)\n        \n\n\n\ndraw :: Board -> Effect Unit\ndraw board =\n    for_ board \\row ->\n        for_ row  \\cell ->\n            Render.rectangle \n                (toNumber cell.coords.x)\n                (toNumber cell.coords.y)\n                (toNumber size.side)\n                (toNumber size.side)\n                cell.color","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()"],"names":[],"mappings":"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yEA;;;;;AAKA;AAAA;AAAA;AA9EA;AAgFA;;;;;AA/CA;;AAAA;;;AACA;;AAAA;;;AAaA;AAAA;AAAA;AA/CA;AAiDA;;;;;AAcA;AAAA;AAAA;AA/DA;AAiEA;AACA;;;;;;;;;;;;;;;;;;;;ADjEA;AA4BA;;;AAEA;;;;;;;;;;;;AD9BA;AAAA;AAAA;AAAA;AAAA;AA+BA;;;;AAEA;;AAAA;;;AAoBA;AAAA;AACA;AAvDA;;AAwDA;AAxDA;;AAuDA;;;;;;;;;;;;;ADtDA;AAsBA;;;;AAGA;;AACA;AAHE;AAAF;;;;;;;;;;;;ADZA;;;AAGA;AAAA;AAAA;AACA;;;;AAHE;AAAF;;AAQA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;ADrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBA;;;;;;;;;;;;AA8BA;AACA;AAAA;AACA;;;AATA;AACA;AAAA;AAEA;AAnDA;AAiDA;AAAA;;;AAiBA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AAFA;AAIA;;AACA;;;;;;;;AAIA;AAjDA;AAEA;;AAKA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;;AACA;AAAA;;AAHA;;;;;;;AAoBA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;AD7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADlGA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+KA;AACA;;AAzGA;AACA;AAAA;AAAA;;;AANA;AACA;AAAA;AAAA;;;AAWA;AAxBA;AAAA;AAMA;AAAA;AACA;AACA;;;;AAmCA;AAOA;AAAA;AAPA;AAQA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAVA;;;AAKA;;AAcA;AAAA;AAMA;;;AAxCA;AACA;;AAGA;AArCA;AACA;;AAgHA;AACA;;AAbA;AAnBA;AAwDA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;;AACA;AAAA;;AAHA;;;;;AAhEA;;;;;;;;;;;;;;;;;;;;;;;;;;;ADjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADnRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2/BA;AAAA;AAAA;AAAA;AAzhCA;;;;;AA0iCA;AArZA;AAAA;AAAA;AAEA;AAvpBA;AAupBA;AAAA;AAAA;;;;AAjKA;AA0mBA;;;AA1wBA;AACA;AAAA;AAAA;AAAA;;;;AA5MA;AAAA;AAGA;AACA;AAAA;AACA;;AADA;;;AAAA;;AA/IA;;;AAqvBA;AAAA;AACA;;;AA/bA;AACA;AAAA;;;AAmYA;AAAA;AAGA;AAAA;AAHA;AAIA;AAAA;;AACA;AAAA;;AACA;AAAA;;AANA;;;AACA;;;AAeA;AAAA;AACA;;;AA5BA;AAAA;AACA;;;AA1gBA;AACA;;AA4CA;AACA;;AA2sBA;AAAA;AAEA;;AACA;AA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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADzEA;AAAA;AAAA;AA6CA;;;AA7BA;;;AAgBA;AAgBA;AAAA;AACA;;;AAHE;AAAF;;AARA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;;;;AAfA;AAHA;AAMA;AAVA;AACA;AAAA;;AACA;AAAA;;AADA;;AAHE;AAAF;;AAkBA;AACA;;AAeA;AAAA;AAAA;AAAA;AAAA;AAWA;AAFA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;AD1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADAA;;;;;;;AAGA;;;AAMA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AANE;AAAF;;;;;;;;;;;;;ADZA;AAAA;AAAA;AA4BA;AAAA;;AAlBA;AAAA;;AAoBA;AACA;;AAnBA;AACA;;AAoBA;AAAA;AACA;AADA;AAEA;AAFA;AAEA;;;;;AApBA;AAAA;AACA;AADA;AAEA;AAFA;AAEA;;;;;AAoBA;AAtCA;AAsCA;AAAA;AACA;AADA;AAAA;AAGA;AAHA;AAAA;;;;;AAlBA;AApBA;AAoBA;AAAA;AACA;AADA;AAAA;AAGA;AAHA;AAAA;;;;;AAuBA;AA3CA;AA2CA;AACA;AAAA;AAAA;AAAA;;;;AAnBA;AAzBA;AAyBA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ADzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BA;;;;AACE;AAAF;;AAEA;;;AAmBA;AAAA;AAAA;AAGA;AAEA;AAAA;;;AAAA;;AAJA;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AA1EA;;;;;;AA0FA;AACA;;AAQA;AACA;AAAA;;;;;;;;;;;;;;;ADnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADvBA;AAAA;AAAA;AAAA;AAqCA;;;AACE;AAAF;;AAEA;AAoBA;AAAA;AAAA;AAGA;AACA;AACA;;AADA;AAEA;;AAFA;;AAHA;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AA9EA;;;;;;AA6FA;AACA;;AAUA;AAAA;AAAA;AAIA;AAAA;AACA;AACA;AAAA;AAAA;;;AAAA;;;;AAJA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;;;ADzGA;AACA;AACA;AACA;;;;;ADHA;AAcA;AACA;;;;;;;;;;;ADfA;AASA;AAAA;;AAcA;AAGA;;;AAAA;AAAA;;;;;;;AAFA;;AAbA;;;;;;;;;;ADXA;AAAA;AAcA;;;;AAGA;;;AAFE;AAAF;;;;;;;;;;ADfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AD3CA;AAwBA;AAAA;AAzBA;;;AAeA;AAAA;AAfA;;;AA6CA;AAAA;AA7CA;;;AAmCA;AAAA;AAnCA;;;;;;;;;;;;;;;;;;ADCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADLA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;ADNA;AAAA;AAQA;AACA;;AAGA;AACA;;;;;;;;;ADbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AD5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgGA;AACA;AAAA;AAAA;AAAA;;AAAA;;AApBA;AACA;;AAzCA;AAfA;;;;;;;;;;;;;;;ADzBA;AACA;AACA;AACA;;;;;ADHA;AAAA;AAAA;AAoCA;AAAA;AAEA;;AAAA;;;;AAhBA;AAAA;AAEA;;AACA;AACA;;;;AAiBA;AA5CA;;;;;;;;;;;ADCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AD1BA;AAAA;AAsBA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AACA;;;;;;;;;;;;;;ADhCA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ADLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADpDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AAlCA;AAkCA;AAlCA;;AA6BA;AA7BA;;AAqBA;AArBA;AAAA;AAwBA;AAxBA;;AAkBA;AAqBA;AAvCA;;AA4CA;AAAA;AA5CA;AAAA;;;;;;;;;;;;;;;;;;ADCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AD/CA;AAAA;AA6DA;AAAA;AACA;;;AAfA;AAAA;AACA;;;AAMA;AAAA;AACA;;;AAkCA;AACA;;AAXA;AACA;;AAIA;AACA;;AAXA;AACA;;;;;;;;;;;;;;;;;;;;AD7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AD7jBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkeA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AA+GA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAnWA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAfA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AA0BA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAkTA;AAAA;AAEA;AAAA;AACA;AACA;AADA;;;;AA5ZA;AAAA;AAIA;AAAA;;;;AAyVA;AAGA;AACA;;;AACA;;;AACA;;;AACA;;;AACA;;;AACA;;AARA;;AAxHA;AAAA;AAEA;AAAA;AACA;AACA;AADA;;;;AA0GA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAJA;;AA6GA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAHA;;AA5TA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAzBA;;AAqOA;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAJA;;AAFA;;;AA7QA;AAAA;AACA;AAAA;;AACA;AADA;;AAEA;AAFA;;AAAA;;;AAdA;AAAA;AACA;AAAA;;AACA;AADA;;AAEA;AAFA;;AAAA;;;AAgFA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAzBA;;AAFA;;;AA3HA;AAAA;AACA;;;AA9BA;AACA;;AAqBA;AAEA;AAAA;AACA;AAAA;AADA;AACA;;;;AAiNA;AAAA;AAEA;AAAA;AACA;AACA;AADA;;;;AA5KA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;AA2XA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAHA;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADhmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAGA;AAAA;;;AAIA;AAEA;;;AACA;AACA;AAAA;AAMA;AACA;;;;;;;;;AD/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ADxCA;AAAA;AAAA;AAAA;AAAA;AAaA;AACA;;AAGA;AAEA;AAAA;AAEA;AAAA;;AACA;AAHA;AAIA;;AAJA;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AD/BA;;;;;;;;;;;;;;;ADXA;;;;;;;;;;;;;;;ADSA;;;;AACE;AAAF;;AAGA;AAEA;AAFA;AACA;;AAHE;AAAF;;;;;;;;;;;ADlBA;AACA"}